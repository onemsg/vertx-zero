{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Zero Framework Docs","text":"<p>Zero is a middleware framework based on Vert.x and it could help software engineers focus on business requirements instead of technical detail of Vert.x. The original idea of this framework came from Spring Boot as that there is no approximative tools in Vert.x sphere at that time.</p> <p>Zero has two metaphors, the original name is \"Zero Up\", \"Up\" means that I want to build a system that could be always running up online, \"Zero\" means no more workload for high production and you can build your own system efficiently with the default configuration only.</p> <p>The latest Zero Micro Architecture ( Aeon System ) will be deployed to K8S with Istio environment, it's a future focused method to build mature system with native cloud nature for more enterprise to execute critical valuable business efficiently. And I hope it could act as an important tool for more enterprise to complete digital transformation to satisfy the sustainable development, it could be high efficiently digital middleware in your side!</p> <ul> <li>Gitee Repo: https://gitee.com/silentbalanceyh/vertx-zero</li> </ul>"},{"location":"#1-features","title":"1. Features","text":"<p>Critical For Beginner: Zero Framework has been re-factor many times, the features are very complex now, you can refer following link for more details to know the power of Zero.</p> <ul> <li>\u529f\u80fd\u652f\u6301\u8868/Feature List</li> </ul>"},{"location":"#11-structure","title":"1.1. Structure","text":"<p>Zero Framework ( Latest Version ) contains five major projects as following:</p> Name Comment vertx-gaia Zero Core Runtime, it contains minimum zero environment and you can deploy your projects on zero. vertx-ifx Infix Architecture, Useful plug-ins that could be supported by Zero and you can choose as required. vertx-import Zero Usage dependency to perform development, it provides uniform entrance for your projects. vertx-semper Aeon System, The native cloud environment based on K8S with Istio. vertx-pin Zero Extension Modules, it provides common business features to satisfy many enterprise requirements such as ODOO."},{"location":"#12-usage-links","title":"1.2. Usage Links","text":"Name Comment Zero Ui Zero UI Framework based on React and Ant Design. Zero Ai Zero Ai Toolkit for rapid development. Zero Example Zero original example demos for beginner. Old Official Document The previous zero document before <code>0.4.8</code>, EN version. \u300aZero\u51a5\u601d\u5f55\u300b The core training course for beginner to study Zero Framework, CN version. \u300aVert.x\u9010\u9646\u8bb0\u300b The basic vert.x framework training course, ( In Progress ) \u300aZero\u4e91\u5e73\u53f0\u767d\u76ae\u4e66\u300b The specification and guide for developer to process zero cloud platform / application. ( Include Zero Extension, Zero UI, Aeon Platform &amp; Zero Ai etc ), CN version."},{"location":"#13-agreed-metadata-specification-ams","title":"1.3. Agreed Metadata Specification ( AMS )","text":"<p>In latest version <code>0.9.0</code>, I have published a new project <code>vertx-ams</code> under <code>vertx-gaia</code> project, it's a shared library that could be cross Vertx, Spring and other project etc, it provide common features of JVM language and could help you to do development more efficiently instead of <code>Util</code>. For more details you can refer \u300a9.\u6807\u51c6\u5316\u300b.</p> <p>The reference link is : https://gitee.com/silentbalanceyh/vertx-zero/tree/master/vertx-gaia/vertx-ams, you can add following segment to your own project:</p> <pre><code>&lt;dependency&gt;\n&lt;artifactId&gt;vertx-ams&lt;/artifactId&gt;\n&lt;groupId&gt;cn.vertxup&lt;/groupId&gt;\n&lt;version&gt;${ZERO_VERSION}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"#2-overlook","title":"2. Overlook","text":"<p>Here I provide another view to let you know Zero Framework for more details.</p>"},{"location":"#21-modulat","title":"2.1. Modulat","text":"<p>Zero Extension has been designed and re-factor to modulat environment, you can configure the modules as required, all the modules could support following:</p> <ul> <li>OSGI Specification</li> <li>JDK 9 Module</li> </ul> <p>here are some standard modules in Zero Extension.</p> <p></p>"},{"location":"#22-topology","title":"2.2. Topology","text":"<p>The whole Zero Framework ( Aeon Environment ) is as following:</p> <p></p>"},{"location":"#23-modeling","title":"2.3. Modeling","text":"<p>The latest version <code>0.9.0</code> has involved the specification of Industry Modeling to support more factors:</p> <ul> <li>ISO Specification such as ISO-27001, ISO-20000, ISO-9001 etc.</li> <li>Eclipse Modeling Framework supported ( EMF ), include UML generator for reverse engineering.</li> <li>BPMN 2.0 Specification supported.</li> </ul>"},{"location":"#23-schematic","title":"2.3. Schematic","text":"<p>I have published the design schematic diagram of zero to: Zero Architecture, you can refer the interaction graphic online and this working is on going. The main diagram of Zero Booting is as following:</p> <p></p>"},{"location":"#3-envrionment","title":"3. Envrionment","text":"<ul> <li>Back-End: You can download scaffold project from https://gitee.com/silentbalanceyh/vertx-zero-scaffold to   initialize zero environment.</li> <li>Front-End: You can use command <code>ai init -name</code> instead,   refer Front-End Initialize.</li> </ul>"},{"location":"#31-configuration-in-pomxml","title":"3.1. Configuration in pom.xml","text":"<p>If you want to use Zero framework, you can add following dependency into you <code>pom.xml</code> to use Zero:</p> JDK 17+, vert.x 4.xJDK 11+, vert.x 4.xJDK 8, vert.x 3.9.x <pre><code>&lt;parent&gt;\n&lt;artifactId&gt;vertx-import&lt;/artifactId&gt;\n&lt;groupId&gt;cn.vertxup&lt;/groupId&gt;\n&lt;version&gt;0.9.0&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre> <pre><code>&lt;parent&gt;\n&lt;artifactId&gt;vertx-import&lt;/artifactId&gt;\n&lt;groupId&gt;cn.vertxup&lt;/groupId&gt;\n&lt;version&gt;0.8.1&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre> <pre><code>&lt;parent&gt;\n&lt;artifactId&gt;vertx-import&lt;/artifactId&gt;\n&lt;groupId&gt;cn.vertxup&lt;/groupId&gt;\n&lt;version&gt;0.6.2&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre>"},{"location":"#32-start-up-core","title":"3.2. Start Up ( Core )","text":"<p>In your project, you can provide main entry only as following to run Zero ( Annotated with <code>@Up</code> ) .</p> <pre><code>import io.vertx.up.VertxApplication;\nimport io.vertx.up.annotations.Up;\n@Up\npublic class Driver {\npublic static void main(final String[] args) {\nVertxApplication.run(Driver.class);\n}\n}\n</code></pre> <p>Once the Zero is up, you can see following logs in your console ( The default port is <code>6083</code> ):</p> <pre><code>[ ZERO ] ZeroHttpAgent Http Server has been started successfully. \\\n    Endpoint: http://0.0.0.0:6083/\n</code></pre>"},{"location":"#33-start-up-native-cloud","title":"3.3. Start Up ( Native Cloud )","text":"<p>When you want to enable Aeon System, you can switch the code as following:</p> <pre><code>import io.vertx.aeon.AeonApplication;\nimport io.vertx.up.annotations.Up;\n@Up\npublic class Driver {\npublic static void main(final String[] args) {\nAeonApplication.run(Driver.class);\n}\n}\n</code></pre>"},{"location":"#4-tips","title":"4. Tips","text":""},{"location":"#41-data-specification","title":"4.1. Data Specification","text":"<p>In zero framework, we designed uniform data specification as following response data format for business usage:</p> <pre><code>{\n\"data\":\n}\n</code></pre> <p>After <code>0.5.2</code>, it could support freedom data format response as you wanted such as:</p> <pre><code>Hello World\n1\n...\n</code></pre> <p>If you want to switch to freedom mode, you can set the configuration in <code>vertx.yml</code> file:</p> <pre><code>zero:\nfreedom: true     # The default value of `freedom` is false.\n</code></pre>"},{"location":"#42-logging-in-zero","title":"4.2. Logging in Zero","text":"<p>You can use following function in your coding to get Logger component instead of <code>log4j</code> because we have re-designed the detail implementation of logging system.</p> <pre><code>// Zero Logger initialized, connect to vert.x logging system directly \n// but uniform managed by zero.\nimport io.horizon.log.Annal;\n// Then in your class\npublic final class Statute {\nprivate static final Annal LOGGER = Annal.get(Statute.class);\n......\n}\n</code></pre>"},{"location":"#43-oracle-issue","title":"4.3. Oracle Issue","text":"<p>From <code>0.8.0</code>, if you want to use Zero Extension of Dynamic Modeling, you need the project of https://github.com/silentbalanceyh/vertx-zero/tree/master/vertx-pin/zero-vista. The latest version is <code>0.8.0-SNAPSHOT</code>, you can modify the version and rebuild it. This feature is not needed in Core Framework.</p> <p>Above issue has been fixed in <code>0.9.0</code>.</p>"},{"location":"#5-other-information","title":"5. Other Information","text":""},{"location":"#51-cases-list","title":"5.1. Cases List","text":"<p>Because of Contract and Confidentiality Agreement, removed Sensitive information of customer include system name, customer name etc.</p> <ul> <li>Deprecated: Not Running Now</li> <li>In Progress: In Development or Upgraded Development</li> <li>Running: Running on Production Environment</li> </ul> System Information Zero Version Type System Status TLK Video Mobile System 0.4.6 Commercial Deprecated ISCCC Enterprise Evaluation 0.8.1 Commercial Running Digitization Cooperation Office 0.8.1 Commercial Running Commercial Opportunity Management 0.8.1 Commercial Running Fruit PSI Management System 0.8.1 Commercial Running Government Procurement System 0.8.1 Commercial Running Invoice Verification Connector 0.8.1 Commercial Running CMDB Platform of Bank Latest Commercial Running ITSM Platform of Bank Latest Commercial Running Integration of PBC Bank Latest Commercial Running ISO27000 Management Platform Latest Commercial Running Zero Training Platform Latest Internal Running Data Analyzing Exam Latest Internal Running Aeon Native Cloud Platform Latest Internal In Progress Development Center Latest Internal In Progress K8S Integration Monitor System Latest Internal In Progress Medical Appliance Management Latest Commercial In Progress Hotel Management Platform Latest Commercial In Progress IoT Control System Latest Commercial In Progress Specification Management Platform Latest Commercial In Progress"},{"location":"#52-wechat-group","title":"5.2. WeChat Group","text":"<p>You can send request to me: <code>445191171</code> to contact with the author of zero.</p> <p></p>"},{"location":"#designed-in-china","title":"DESIGNED IN CHINA\uff08\u4e2d\u56fd\u8bbe\u8ba1\uff09","text":""},{"location":"0-offical-document/","title":"Official Document","text":"<ol> <li>1 - Getting Start</li> <li>Environment<ol> <li>2.1 - Docker Environment</li> <li>2.2 - Isito Environment</li> <li>2.3 - Micro Service Environment</li> </ol> </li> <li>Parameters ( JSR311 )<ol> <li>3.1 - Interface annotation ( Non Event )</li> <li>3.2 - Restful Api, @Path usage</li> <li>3.3 - ( JSR 311 Extend ) @BodyParam usage</li> <li>3.4 - Set POJO as parameters</li> <li>3.5 - File/FileUpload as parameters</li> </ol> </li> <li>Mime Supported Matrix<ol> <li>4.1 - Parameter type supported</li> <li>4.2 - Mime type Matrix</li> </ol> </li> <li>Request Flow<ol> <li>5.1 - How to enable Event Bus</li> <li>5.2 - (Recommend) Event Bus sample version</li> <li>5.3 - Request Workflow Introduction</li> <li>5.4 - How to use Envelop ( Uniform Resource Model )</li> <li>5.5 - (Recommend) Example 1: Advanced usage for Envelop</li> </ol> </li> <li>Plugin<ol> <li>6.1 - How to use MongoClient in Zero</li> <li>6.2 - How to use MySqlClient in Zero</li> <li>6.3 - How to use RpcClient in Zero</li> </ol> </li> <li>Dependency Injection<ol> <li>7.1 - How to use Dependency Injection ( JSR330 )</li> </ol> </li> <li>Exception ( Error )<ol> <li>8.1 - How to define Web Exception</li> <li>8.2 - How to validate request ( JSR 303 with Hibernate-Validator )</li> <li>8.3 - Advanced Validation ( Rule for @BodyParam )</li> </ol> </li> <li>Security<ol> <li>9.1 - Enable Basic Authorization</li> </ol> </li> <li>Micro Service<ol> <li>10.1 - Rpc Configuration</li> <li>10.2 - Rpc Basic in Zero</li> <li>10.3 - Example: Single Request</li> </ol> </li> </ol>"},{"location":"101-rpc-configuration/","title":"Rpc Configuration","text":"<p>This document is for rpc configuration in zero system. You can configure current zero instance as two Rpc roles:  Server/Client, Rpc require micro service environment instead of standalone, it means that you must read this document first: 2.3 - Micro Service Environment .</p>"},{"location":"101-rpc-configuration/#1-rpc-server","title":"1. Rpc Server","text":"<p>You can configure rpc server in <code>vertx-server.yml</code> directly, it's not needed to create new configuration files.</p> <pre><code>- name: ipc-cronus\ntype: ipc\nconfig:\nport: 6883\nhost: 0.0.0.0\nssl: false\ntype: PEM\n</code></pre> <p>You can add new node of <code>type=ipc</code> IPC ( Internal Process Calling ) instead of <code>http</code>, Here are some additional configuration info of rpc to enable SSL.</p> <ul> <li>ssl: Whether enable SSL communication with Rpc</li> <li>type: Here are three types of SSL, please refer gRpc/vertx document to see more details of the types:<ul> <li>JKS</li> <li>PKCS12</li> <li>PEM</li> </ul> </li> </ul>"},{"location":"101-rpc-configuration/#2-rpc-client","title":"2. Rpc Client","text":"<p>Rpc client configuration must be configured standalone. Here are the comments:</p> <p>In your <code>vertx.yml</code> configuration up.god.file, you must extend another <code>lime</code> node as following:</p> <pre><code>zero:\nlime: etcd3, rpc\n</code></pre> <p>Then you must create new up.god.file <code>vertx-rpc.yml</code> with following content:</p> <pre><code>rpc:\nssl: false\nuniform:\ntype: PEM\nextension:\n{name}:\ntype: XXX\n</code></pre> <p>Please be careful about the attributes <code>uniform</code> and <code>extension</code>it's the same except following:</p> <ul> <li>The system will scan all client configuration under extension by name setted first. For example the target name   is <code>up-ceous</code>, you must set {name} to <code>up-ceous</code>, then when current service communicate with up-ceous service, the   client configuration will use it under extension instead of uniform.</li> <li>If there is no configuration under extension, the uniform configuration will be used. uniform just like default client   configuration.</li> </ul> <p>This configuration up.god.file is only used in SSL mode.</p>"},{"location":"101-rpc-configuration/#3-ssl-configuraiton-examples","title":"3. SSL Configuraiton ( Examples )","text":"<p>Here are some examples of Rpc SSL configuration.</p> <p><pre><code>## vertx-server.yml\n# Rpc Server with PEM ( OpenSSLEngine )\n- name: ipc-cronus\ntype: ipc\nconfig:\nport: 6883\nhost: 0.0.0.0\nssl: true\ntype: PEM\ncert: tlk/server-cert.pem\nkey: tlk/server-key.pem\n# Rpc Server with Jsk ( JSKEngine )\n- name: ipc-cronus\ntype: ipc\nconfig:\nport: 6883\nhost: 0.0.0.0\nssl: true\ntype: JKS\njsk: tlk/server-key.jks\npassword: wibble\n</code></pre> <pre><code>## vertx-rpc.yml ( The name depend on lime )\n# Rpc Client use default\nrpc:\nssl: true\nuniform:\ntype: PEM\ncert: tlk/server-cert.pem\nkey: tlk/server-key.pem\n</code></pre> <pre><code># Rpc Client with spec service\nrpc:\nssl: true\nuniform:\ntype: PEM\ncert: tlk/server-cert.pem\nkey: tlk/server-key.pem\nextension:\nup-cerous:\ntype: JKS\njsk: tlk/server-key.jks\npassword: wibble\n</code></pre></p>"},{"location":"102-single-rpc/","title":"Rpc Basic in Zero","text":"<p>In zero system, the developer could focus on code logical instead of Rpc internally, this example will describe Rpc development for micro service communication. For environment preparing, please refer following document</p> <ul> <li>2.3 - Micro Service Environment</li> <li>10.1 - Rpc Configuration</li> </ul> <p>Then you can write your code in zero service.</p>"},{"location":"102-single-rpc/#1-rpc-workflow","title":"1. Rpc Workflow","text":"<p>In zero system, it only support three rpc node:</p> <ul> <li>Originator</li> <li>Coordinator</li> <li>Terminator</li> </ul> <p>Here are some different code.</p>"},{"location":"102-single-rpc/#11-originator","title":"1.1. Originator","text":"<pre><code>    @Ipc(to = \"IPC://EVENT/ADDR\", name = \"ipc-coeus\")\npublic JsonObject ipc(@BodyParam final JsonObject data) ...\n</code></pre>"},{"location":"102-single-rpc/#12-coordinator","title":"1.2. Coordinator","text":"<pre><code>    @Ipc(value = \"IPC://EVENT/ADDR\",\nname = \"ipc-crius\", to = \"IPC://EVENT/FINAL\")\npublic String send(final Envelop envelop) ...\n</code></pre>"},{"location":"102-single-rpc/#13-terminator","title":"1.3. Terminator","text":"<pre><code>    @Ipc(value = \"IPC://EVENT/FINAL\")\npublic String send(final Envelop envelop) ...\n</code></pre>"},{"location":"102-single-rpc/#14-workflow","title":"1.4. Workflow","text":"<p>As above describe, in one request, there should be following roles ( Here are two Rpc request flow ):</p> <p></p> <ul> <li>Originator and Terminator must be only one in IPC workflow.</li> <li>Coordinator could contains one or more.</li> </ul>"},{"location":"102-single-rpc/#2-limitation","title":"2. Limitation","text":"<p>Because the Originator offten send request from Agent class, the signature of method is freedom. But for  Coordinator &amp; Terminator, the method signature must obey following rules:</p> <ul> <li>This method must contains return value;</li> <li>If there are some async workflow, you can return Future&lt;T&gt; as result;</li> <li>The argument must be length = 1 and type = Envelop; ( Zero defined )</li> </ul>"},{"location":"103-example-single-request/","title":"Example: Single Request","text":"<p>This document describe the simplest Rpc workflow in zero system. please refer following pictures:</p>"},{"location":"103-example-single-request/#1-originator","title":"1. Originator","text":"<p>In your originator, you can write code as following:</p> <pre><code>import io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport io.vertx.up.annotations.Ipc;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/cronus\")\npublic class SpeakApi {\n@Path(\"/forward\")\n@POST\n@Ipc(to = \"IPC://EVENT/ADDR\", name = \"ipc-coeus\")\npublic JsonObject ipc(@BodyParam final JsonObject data) {\nSystem.out.println(data);\nreturn data;\n}\n}\n</code></pre>"},{"location":"103-example-single-request/#2-terminator","title":"2. Terminator","text":"<p>You must be sure current terminator name is \"ipc-coeus\" in <code>vertx-server.yml</code> as following:</p> <pre><code>- name: ipc-coeus\ntype: ipc\nconfig:\nport: 6884\nhost: 0.0.0.0\n</code></pre> <p>Then you can write the code as following:</p> <pre><code>import io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class SpeakWorker {\n@Ipc(value = \"IPC://EVENT/ADDR\")\npublic String send(final Envelop envelop) {\nfinal JsonObject data = envelop.data(JsonObject.class);\ndata.put(\"role\", \"Terminator\");\nreturn data.encode();\n}\n}\n</code></pre> <p>*: Be sure the \"to\" attribute in Originator is the same as \"value\" in Terminator</p>"},{"location":"103-example-single-request/#3-start-up","title":"3. Start Up","text":"<p>In the coeus console you should see following:</p> <pre><code>    [ Up Rpc   ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Rpc   ] Configuration Rpc Point = /zero/zero-istio/ipc/routes/ipc-coeus:10.0.0.7:6884, \n    [ Up Rpc   ] Service Name = ipc-coeus,\n    [ Up Rpc   ] Ipc Channel = grpc://10.0.0.7:6884\n    [ Up Rpc   ] Ipc Address = \n    [ Up Rpc \u221a ]     IPC://EVENT/ADDR\n    [ Up Rpc   ] \u221a Successfully to registered IPCs, wait for community......SUCCESS \u221a\n</code></pre> <p>Then in cronus console you should see following:</p> <pre><code>    [ Up Micro ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Micro ] Configuration Path = /zero/zero-istio/endpoint/routes/up-cronus:10.0.0.7:6083, \n    [ Up Micro ] Service Name = up-cronus,\n    [ Up Micro ] EndPoint = http://10.0.0.7:6083\n    [ Up Micro ] Route Uris = \n    [ Up Micro ]     /cronus/direct\n    [ Up Micro ]     /cronus/forward\n    [ Up Micro ] \u221a Successfully to registered Routes, wait for discovery......SUCCESS \u221a\n</code></pre>"},{"location":"103-example-single-request/#4-send-request","title":"4. Send request","text":"<p>Send request to http://10.0.0.7:6083/cronus/forward, you should see following output</p> <p>Request Body:</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"password\":\"173AFAD5992A3F73A472FC09B05B1FB7\"\n}\n</code></pre> <p>Response Body:</p> <pre><code>{\n\"data\": {\n\"username\": \"lang.yu\",\n\"password\": \"173AFAD5992A3F73A472FC09B05B1FB7\",\n\"role\": \"Terminator\"\n}\n}\n</code></pre> <p>In this way, these two services communicated and the second service put the \"Terminator\" value in \"role\" key, the request flow in zero should be as following ( up-coeus / up-cronus ) are both two different micro services:</p> <pre><code>1. Client Request -&gt; ( Origanitor ) Service = up-cronus\n2. ( Origanitor ) -&gt; ( Terminator ) Service = up-coeus, Ipc = ipc-coeus\n3. ( Terminator ) -&gt; Call method to put role=Terminator into data\n4. ( Terminator ) -&gt; Generate new response -&gt; Client Request\n</code></pre>"},{"location":"23-micro-service-environment/","title":"Micro Service Environment","text":"<p>Zero system support micro service environment from 0.4.5, it's for mesh. Here are some configuration in micro service.</p>"},{"location":"23-micro-service-environment/#1-etcd-environment","title":"1. Etcd Environment","text":"<p>Zero system used etcd3 as configuration center and service registry center. Here are docker environment preparing</p> <pre><code>Files\nzero-etcd3 ( Dockerfile )\nzero-etcd3.sh\nzero-etcd3-run.sh\n\n## zero-etcd3 content\nFROM quay.io/coreos/etcd:latest\n\n## zero-etcd3.sh\n#!/usr/bin/env bash\nimg_name=\"etcd3\"\ncontainer_name=up_${img_name}\n\ndocker stop ${container_name}\ndocker rm ${container_name}\ndocker rmi ${img_name}:latest\n\ndocker build -t ${img_name}:latest -f zero-etcd3 .\ndocker run -d \\\n  -p 6189:2379 \\\n  -p 6190:2380 \\\n  --volume=${DATA_DIR}:/etcd-data \\\n  --name ${container_name} ${img_name} \\\n  /usr/local/bin/etcd \\\n  --initial-cluster ${ETCD_NAME}=http://${ETCD_HOST}:2380 \\\n  --initial-advertise-peer-urls http://${ETCD_HOST}:2380 \\\n  --data-dir=/etcd-data --name ${ETCD_NAME} \\\n  --listen-peer-urls http://${ETCD_HOST}:2380 \\\n  --listen-client-urls http://${ETCD_HOST}:2379 \\\n  --advertise-client-urls http://${ETCD_HOST}:2379\n\n## zero-etcd3-run.sh\n#!/usr/bin/env bash\nexport DATA_DIR=/Users/lang/Runtime/service-mesh/etcd/data\nexport ETCD_NAME=up.zero3\nexport ETCD_HOST=0.0.0.0\n./zero-etcd3.sh\n</code></pre>"},{"location":"23-micro-service-environment/#2-micro-service","title":"2. Micro Service","text":"<p>Once you have prepared the environment of Etcd3, You can configure service node and Api gateway node.</p>"},{"location":"23-micro-service-environment/#21-service-node","title":"2.1. Service Node","text":"<p>In your up.god.file vertx.yml, you can extend node as following:</p> <pre><code>zero:\nlime: mongo, etcd3\n</code></pre> <p>Here etcd3 is only the up.god.file suffix, not fixed, you can set any name for files. Because above lime is <code>etcd3</code>, then create new up.god.file <code>vertx-etcd3.yml</code> in your resources as following:</p> <pre><code>etcd:\nmicro: zero-istio\nnodes:\n- host: localhost\nport: 6189\ntimeout: 2\n</code></pre> <p>Please be careful about <code>micro</code>property, it means that you can run multi Cluster/Application with one etcd environment, the micro describe the name for all micro services in one application, different micro name will not be communicated inner zero system. You must set all your micro service zero instances with one unique name. Please refer following pictures:</p> <p></p> <p>The micro attribute just like application namespace concept, as above pictures there are two applications:  zero-istio &amp; app-tlk, these two applications shared one Etcd3 as registry data center but these two applications are not related ( Could not communicate with Ipc ).</p>"},{"location":"23-micro-service-environment/#22-api-gateway","title":"2.2. Api Gateway","text":"<p>Once you have set service node, you can set Api Gateway node, there are two points for configuration:</p> <p>In <code>vertx-server.yml</code>, you must define new node for Api Gateway as following, be sure the type is api instead:</p> <pre><code>server:\n- name: gateway-cronus\ntype: api\nconfig:\nport: 6099\nhost: 0.0.0.0\n</code></pre> <p>Also you must set the same configuration for etcd in Api Gateway project. The last point is that the launcher class is different from Service Node.</p> <p>In service node, you start up zero instance as following:</p> <pre><code>import io.vertx.up.VertxApplication;\nimport io.vertx.up.annotations.Up;\n@Up\npublic class io.god.Anchor {\npublic static void main(final String[] args) {\nVertxApplication.run(io.god.Anchor.class);\n}\n}\n</code></pre> <p>But in api gateway, you must use another class for start up, you must use <code>io.vertx.up.annotations.ApiGateway</code> annotation for launcher:</p> <pre><code>import io.vertx.up.VertxApplication;\nimport io.vertx.up.annotations.ApiGateway;\nimport io.vertx.up.annotations.Up;\n@Up\n@ApiGateway\npublic class io.god.Anchor {\npublic static void main(final String[] args) {\nVertxApplication.run(io.god.Anchor.class);\n}\n}\n</code></pre>"},{"location":"23-micro-service-environment/#3-rpc-configuration","title":"3. Rpc Configuration","text":"<p>If you want to enable Rpc communication, you can refer document: 10.1 - Rpc Configuration for more details.</p>"},{"location":"35-filefileupload-as-parameters/","title":"File/FileUpload as parameters","text":""},{"location":"35-filefileupload-as-parameters/#1-source-code","title":"1. Source Code","text":"<p>EndPoint Code</p> <pre><code>package up.god.apollo.exp6;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Codex;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport jakarta.ws.rs.StreamParam;\nimport java.io.File;\n@EndPoint\n@Path(\"/exp6/\")\npublic class FileUpload {\n@POST\n@Path(\"/upload\")\npublic JsonObject upload(@Codex @StreamParam final File file) {\nSystem.out.println(file.getAbsoluteFile());\nreturn null;\n}\n}\n</code></pre>"},{"location":"35-filefileupload-as-parameters/#2-points","title":"2. Points","text":"<p>Be careful about the parameter annotation, the file uploading parameter must be annotated with <code>@StreamParam</code>\uff0cIt's for binary mode to get all bytes data from client. Now the parameter type support <code>java.io.File</code> and <code>io.vertx.ext.web.FileUpload</code>\uff0cbut we recommend use <code>FileUpload</code> type instead of <code>java.io.File</code> because this object contains many metadata information such as filename, filesize etc.</p> <p>\u0000`</p>"},{"location":"63-how-to-use-rpcclient-in-zero/","title":"How to use RpcClient in Zero","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:7983d6ea255087f026156cdd964865e91c52178ceb1c27129f91e5421388ba90 size 2964</p>"},{"location":"91-enable-basic-authorization/","title":"Enable Basic Authorization","text":"<p>You can enable authorization in zero system as following steps:</p>"},{"location":"91-enable-basic-authorization/#1-configuration","title":"1. Configuration","text":"<p>In your configuration <code>vertx.yml</code>, you must define lime extend node as following:</p> <pre><code>zero:\nlime: secure\n</code></pre> <p>Then it means that you must create new up.god.file named <code>vertx-secure.yml</code> instead with following content:</p> <pre><code>secure:\n# Standard Type\nmongox:\ntype: mongo\nconfig:\ncollectionName: DB_USER\nsaltStyle: NO_SALT\n</code></pre> <p>Zero system provide some standard authorization by type ( Now support mongo ).</p>"},{"location":"91-enable-basic-authorization/#2-create-new-class","title":"2. Create new class","text":"<p>Then you can create new class as following:</p> <pre><code>import io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.mongo.MongoAuth;\nimport io.vertx.ext.web.handler.AuthHandler;\nimport io.vertx.up.annotations.Authenticate;\nimport io.vertx.up.annotations.Wall;\nimport io.vertx.tp.plugin.mongo.MongoInfix;\nimport io.vertx.up.secure.component.BasicOstium;\n@Wall(value = \"mongox\", path = \"/exp4/*\")\npublic class MongoKeeper {\n@Authenticate\npublic AuthHandler authenticate(final JsonObject config) {\nreturn BasicOstium.create(\nMongoAuth.create(MongoInfix.getClient(), config)\n);\n}\n}\n</code></pre> <p>This class is annotated with @Wall, if the path is not set, it will be the value <code>/*</code> for all routes, the value should be configured in <code>vertx-secure.yml.</code>in current example it's <code>mongox</code>. You can define more than one walls for each routes. Then you must create the <code>AuthHandler</code> method to create the AuthHandler, now you can use <code>BasicOstium</code> to create basic authorization handler, also this method must be annotated with <code>@Authenticate</code>.</p> <ul> <li>The method must be annotated with <code>@Authenticate</code> to mean that this method will provide <code>AuthHandler</code> for   authenticate.</li> <li>In this class, you must mot use any Inject Dependency to get instance such as <code>MongoClient</code>, because this @Wall will   be processed in start up phase instead of request phase.</li> <li>We recommend to use <code>BasicOstium</code> instead of standard vert.x <code>BasicAuthHandler</code> because the class <code>BasicOstium</code> will   bind to Resource Model instance <code>Envelop</code> to provide zero format http response.</li> </ul>"},{"location":"91-enable-basic-authorization/#3-example-response","title":"3. Example response","text":"<p>Once you set the @Wall, you must send request with Authorization http header or your'll get following response:</p> <pre><code>{\n\"code\": -60012,\n\"message\": \"[ERR-60012] (BasicPhylum) Web Exception occus: (401) - (Security) Unauthorized request met in request.\"\n}\n</code></pre>"},{"location":"FEATURES/","title":"Support Feature List","text":"<p>I recommend to download the latest zero framework from https://gitee.com/silentbalanceyh/vertx-zero.git, so you can use the whole features.</p> <ul> <li>Micro means \"Micro Service Environment\"</li> <li>Aeon Environment is Native Cloud Environment. </li> </ul>"},{"location":"FEATURES/#1-jsr","title":"1. JSR","text":"Name Comment JSR311 RESTful specification supported, you can use most of JSR311 annotations. Extend JSR311 Defined new annotations <code>@BodyParam</code>, <code>@StreamParam</code>, <code>@Codex</code> to process web request. JSR330 Dependency injection specification supported, this feature is implemented with Google Guice in latest version. JSR303 Bean validation specification supported. Extend JSR303 Provide validation based on rule configuration ( yaml definition ) to verify the data in json format <code>JsonObject/JsonArray</code>. JSR340 Web-filter specification supported, defined new annotation <code>@WebFilter</code> in Zero."},{"location":"FEATURES/#2-common","title":"2. Common","text":"Keyword Comment Re-Actor This design patterns splitted zero components into <code>Agent</code> and <code>Worker</code> instead of multi-tier structure ( <code>Service/Dao/Model</code> ), the communication between above two are designed by name address instead of java <code>interface</code>, they are not coupling. Non-Blocking All the components in zero framework are asychronous and the container process web request very smartly without any blocking, it require you do more FP style programming in Zero instead of traditional style. Yaml All critical configuration files are formatted with yaml syntax, and it's similar with spring framework. Jooq Zero framework access different SQL database via Jooq as standard way, and I provide user-defined Query Engine ( json syntax ) to support complex querying such as pagination, sorting, grouping, joining and advanced searching. MongoDb Support mongo db toolkit to access mongo database very cool, as the Query Engine syntax is the same as SQL database, they shared uniform API in programming. AOP Security Zero Authorization support the whole mode that Vert.x supported ( Basic, OAuth etc) , you can provide your own implementation to process code logical details. All the authoentication(401)/authorization(403) components are designed in AOP part, it could be plug-in/plug-out smartly and all the security components and business components are not coupling. Exception Zero provides a dynamic mgaic exception system to catch different errors that you needed in enterprise application, You can write very less code to implement zero exception and throw out, it will be captured by container. Data Contract Zero designed uniform data format between front-end / back-end communication, there is another project zero ui, it's frant-end application. Query Engine Zero provides query engine interface to face three situations: SQL database, excel table, mongo database, it uses uniform syntax ( Json Format ) to support different data querying. Job Zero provides background scheduler/jobs sub-system to support task processing, the default task manager is implemented with <code>vert.x</code>, you can provide other implementations. Plugin All the zero components are mixed by Infix Architecture, you can write extensions in zero framework by yourselves. History Zero provide default history system to record all the data histories in historical database ( The secondary database here ), you can do any changes in your application and rollback the data to fixed version that you needed. Multi- Zero could support following multi environments, they could run in uniform environment such as platform here: Multi-Application, Multi-Language, Multi-Tenant. WebSocket Zero provides websocket feature in the latest version, it's implemented based on Stomp. EMF Zero support modeling method via Java class and the table of database, also it support dynamic modeling based on configuration, the dynamic modeling feature support Eclipse Modeling Framework specification. Monad Most components in Zero were designed based on FP programming, the framework provides Ux/Ut/Fn supervise toolkit API to help developers to implement monad development smartly."},{"location":"FEATURES/#3-micro-service","title":"3. Micro Service","text":"Keyword Comment gRPC Zero used gRPC as default communication equipments, it hides the details of gRPC, the developers could write code with common programming-style. This feature resolves service communication between different micor-services. etcd3 When you want to implement registry center in micro environment, zero use <code>etcd3</code> as default ( Also you can provide other implementations ). It let zero could run on k8s environment very soon. istio zero-micro implementation uses k8s / istio / etcd3 as default architecture, all the applications could run on above platform directly, running on istio is experimental in progress. mesh Zero-micro provides new architecture based on service mesh concept, it defined <code>originator/coordinator/terminator</code> to mark each node or service, for data-communication, developers are not needed to know the details with common-programing. gateway Zero provides Api Gateway to connect different micro-services, it implement perfect web request forwarding and monitoring. K8S Aeon Environment is running on K8S environment, it built Native Cloud system for users."},{"location":"FEATURES/#4-business-components","title":"4. Business Components","text":"<p>All the business part that you can refer <code>vertx-pin</code> project ( zero extensions ).</p>"},{"location":"FEATURES/#5-integration-clients","title":"5. Integration Clients","text":"<p>Below are all supported clients to connect ( Infix Architecture )</p> <ul> <li>Radis</li> <li>Feign</li> <li>ElasticSearch</li> <li>MySql</li> <li>Mongo DB</li> <li>Neo4j: Graphic Database</li> <li>Jooq</li> <li>Etcd3</li> <li>FTP</li> <li>Git: Low-Code back-end</li> <li>gRPC: Zero micro environment</li> <li>Apache Poi: Excel Importing / Exporting</li> <li>Liquibase: SQL Auto Deployment</li> <li>Shell Framework: DevOps shell administration</li> <li>Stomp: Websocket Enabled.</li> <li>\u7231\u5947\u827a\u89c6\u9891\u5ba2\u6237\u7aef</li> <li>\u963f\u91cc\u4e91\u77ed\u4fe1\u5ba2\u6237\u7aef</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"vertx-zero-tutorial/","title":"Vertx zero tutorial","text":""},{"location":"zero-di/","title":"Dependency Injection ( JSR 330 )","text":"<p>To avoid object relationship complex, zero also support Simple dependency injection based on JSR 330.</p>"},{"location":"zero-di/#vertx-way","title":"Vert.x Way","text":"<p>All the vert.x specific object could be inject as following way.</p> <pre><code>import javax.inject.infix.Mongo;\nimport javax.inject.infix.MySql;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\npublic class InjectApi {\n@MySql\nprivate transient SQLClient sqlClient;\n@Mongo\nprivate transient MongoClient mongo;\n// ......\n}\n</code></pre> <p>The following object is supported by current zero version</p> <ul> <li>[x] <code>javax.inject.infix.@Mongo</code>: <code>io.vertx.ext.mongo.MongoClient</code></li> <li>[x] <code>javax.inject.infix.@MySql</code>: <code>io.vertx.ext.sql.SQLClient</code></li> </ul>"},{"location":"zero-di/#common-way-jsr-330","title":"Common Way ( JSR 330 )","text":""},{"location":"zero-di/#1-class-implementation","title":"1. Class implementation","text":"<p>Target Class</p> <pre><code>import io.vertx.ext.mongo.MongoClient;\nimport io.vertx.up.commune.Envelop;\nimport javax.inject.infix.Mongo;\npublic class InjectDao {\n@Mongo\nprivate transient MongoClient client;\npublic void async(final Envelop envelop) {\nSystem.out.println(this.client);\n}\n}\n</code></pre> <p>Inject <code>InjectDao</code></p> <pre><code>import javax.inject.Inject;\n@Queue\npublic class InjectWorker {\n@Inject\nprivate transient InjectDao dao;\n// ......\n}\n</code></pre>"},{"location":"zero-di/#2-interface-with-unique-implementation","title":"2. Interface with Unique implementation","text":"<p>Interface Definition</p> <pre><code>public interface InjectStub {\n}\n</code></pre> <p>Implementation Class</p> <pre><code>public class InjectInstance implements InjectStub {\n}\n</code></pre> <p>Inject <code>InjectStub -&gt; InjectInstance</code></p> <pre><code>import javax.inject.Inject;\n@Queue\npublic class InjectWorker {\n@Inject\nprivate transient InjectStub stub;\n// ......\n}\n</code></pre> <p>*: One limitation for this situation is that there are only one implementation of interface InjectStub.</p>"},{"location":"zero-di/#3-interface-with-multi-implementations","title":"3. Interface with Multi implementations","text":"<p>Interface Definition</p> <pre><code>public interface InjectA {\n}\n</code></pre> <p>Implementation Class</p> <p>InjectB</p> <pre><code>import javax.inject.Named;\n@Named(\"NameInjectA\")\npublic class InjectB implements InjectA {\n}\n</code></pre> <p>InjectC</p> <pre><code>@Named\npublic class InjectC implements InjectA {\n}\n</code></pre> <p>Inject <code>InjectA -&gt; InjectB</code></p> <pre><code>import io.vertx.up.annotations.Qualifier;\nimport javax.inject.Inject;\n@Queue\npublic class InjectWorker {\n@Inject\n@Qualifier(\"NameInjectA\")\nprivate transient InjectA injectA;\n</code></pre> <p>You can use <code>@Qualifier</code> to set which implementation should be inject.</p>"},{"location":"zero-di/#rules","title":"Rules","text":"<ul> <li>All this kind of classes are initialized with <code>singleton</code> mode, you shouldn't inject Value Object, POJO.</li> <li>All the injection points are based on some part of <code>JSR330</code> but not all.</li> </ul>"},{"location":"zero-docker/","title":"Docker Environment","text":""},{"location":"zero-docker/#0-port-list","title":"0. Port List","text":"<ul> <li>neo4j:<ul> <li>6074 ( http://localhost:6074, neo4j:neo4j )</li> <li>6073</li> <li>6075 ( bolt://localhost:6075, Database Links )</li> </ul> </li> <li>consul<ul> <li>6500 ( http://localhost:6500 )</li> <li>6300</li> </ul> </li> <li>mongo<ul> <li>6017</li> </ul> </li> <li>mysql<ul> <li>6036 ( root:zero )</li> </ul> </li> <li>postgres<ul> <li>6432 ( postgres:zero )</li> </ul> </li> <li>rabbit-mq<ul> <li>6369</li> <li>6571</li> <li>6572</li> <li>6671</li> <li>6672 ( http://localhost:6672, guest:guest )</li> <li>6272</li> </ul> </li> <li>redis<ul> <li>6379</li> </ul> </li> <li>etcd2<ul> <li>6179</li> <li>6180</li> <li>6181</li> </ul> </li> <li>etcd3<ul> <li>6189</li> <li>6190</li> <li>6191</li> </ul> </li> </ul>"},{"location":"zero-docker/#1-setup","title":"1. Setup","text":""},{"location":"zero-docker/#11-neo4j","title":"1.1. neo4j","text":"<pre><code>docker pull neo4j\nshell/zero-neo4j.sh\n</code></pre>"},{"location":"zero-docker/#12-consul","title":"1.2. consul","text":"<pre><code>docker pull consul:1.0.1\nshell/zero-consul.sh\n</code></pre>"},{"location":"zero-docker/#13-mongo","title":"1.3. mongo","text":"<pre><code>docker pull mongo:3.5.13\nshell/zero-mongo.sh\n</code></pre>"},{"location":"zero-docker/#14-mysql","title":"1.4. mysql","text":"<pre><code>docker pull mysql:5.7\nshell/zero-mysql.sh\n</code></pre>"},{"location":"zero-docker/#15-postgres","title":"1.5. postgres","text":"<pre><code>docker pull postgres:latest\nshell/zero-postgres.sh\n</code></pre>"},{"location":"zero-docker/#16-rabbitmq","title":"1.6. rabbitmq","text":"<pre><code>docker pull rabbitmq:management\nshell/zero-rabbit-mq.sh\n</code></pre>"},{"location":"zero-docker/#17-redis","title":"1.7. redis","text":"<pre><code>docker pull redis:4.0.2\nshell/zero-redis.sh\n</code></pre>"},{"location":"zero-docker/#18-etcd-2-3","title":"1.8. etcd ( 2 &amp; 3 )","text":"<pre><code># etcd 3\ndocker pull quay.io/coreos/etcd:latest\nshell/zero-etcd3-run.sh\n\n# etcd 2\ndocker pull quay.io/coreos/etcd:v2.3.8\nshell/zero-etcd2-run.sh\n\n# etcd ui\nFROM nikfoundas/etcd-viewer\n</code></pre> <p>You can modify the environment variable in <code>zero-etcd-run.sh</code> as following:</p> <pre><code># etcd 2\nexport DATA_DIR=/Users/lang/Runtime/service-mesh/etcd/data\nexport ETCD_NAME=up.zero2\nexport ETCD_HOST=127.0.0.1\n./zero-etcd2.sh\n\n# etcd 3\n#!/usr/bin/env bash\nexport DATA_DIR=/Users/lang/Runtime/service-mesh/etcd/data\nexport ETCD_NAME=up.zero3\nexport ETCD_HOST=127.0.0.1\n./zero-etcd3.sh\n</code></pre> <ul> <li>DATA_DIR: Data folder to store etcd data;</li> <li>ETCD_NAME: The name for current node here ( default up.zero )</li> <li>ETCD_HOST: The host to run etcd here ( default is 127.0.0.1 )</li> </ul>"},{"location":"zero-ebs/","title":"Event Bus only version","text":"<p>In most situation, the sender is not needed, zero also support another sample version to transfer the data to event bus directly.</p>"},{"location":"zero-ebs/#1-source-code","title":"1. Source Code","text":""},{"location":"zero-ebs/#11-sender-interface-only","title":"1.1. Sender Interface Only","text":"<p>In this kind of version, the request will go through based on interface and transfer the data to worker directly. Be careful this class is interface instead of class.</p> <pre><code>import io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/cronus\")\npublic interface SpeakAddrApi {\n@Path(\"/direct\")\n@POST\n@Address(\"ZUES://DIRECT\")\nJsonObject speak(@BodyParam JsonObject data);\n}\n</code></pre>"},{"location":"zero-ebs/#12-consumer","title":"1.2. Consumer","text":"<pre><code>import io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class SpeakAddrWorker {\n@Address(\"ZUES://DIRECT\")\npublic void direct(final Message&lt;Envelop&gt; data) {\nfinal JsonObject replied = (data.body().data(0, JsonObject.class));\ndata.reply(Envelop.success(replied));\n}\n}\n</code></pre> <p>This version will skip no code logical agent and send the data to worker directly.</p>"},{"location":"zero-ebs/#13-argument-mapping","title":"1.3. Argument Mapping","text":"<p>Be careful about the data method of Envelop in above code:</p> <pre><code>public &lt;T&gt; T data(final Integer argIndex, final Class&lt;T&gt; clazz)\n</code></pre> <p>Actually, the message will transfer the parameters from interface definition by index as JsonObject key to extract the data from EventBus. Other rules will be useful to apply all the type here, you also could use POJO type as the second argument.</p>"},{"location":"zero-ebs/#14-limitation","title":"1.4. Limitation","text":"<p>*     1. Hibernate Validation will be failure because there is no implementation class, but advanced validation could be        used <code>@Codex</code>. *     2. The worker method must be a specification under zero definition.</p>"},{"location":"zero-envelop/","title":"Resource Model","text":""},{"location":"zero-envelop/#1-envelop","title":"1. Envelop","text":"<p>Envelop word refer from SOAP web service, and it contains following field:</p> <ol> <li>status: <code>io.horizon.eon.em.web.HttpStatusCode</code> - Http Status Enum data.</li> <li>headers: <code>io.vertx.core.MultiMap</code> - Http Headers ( Direct from Vert.x )</li> <li>error: <code>io.horizon.exception.WebException</code> - Abstract Web Error defined by Zero</li> <li>data: <code>io.vertx.core.json.JsonObject</code> - Data Part in current Envelop</li> <li>user: <code>io.vertx.ext.auth.User</code> - User Info ( Direct from Vert.x )</li> </ol>"},{"location":"zero-envelop/#2-common-api","title":"2. Common Api","text":"<pre><code>// Extract data from Envelop\nfinal JsonObject data = message.data();\n// Extract T from Envelop\nfinal Demo user = message.data(Demo.class);\n// Extract data from Message&lt;Envelop&gt;, static ( Be careful )\nfinal Demo user = Envelop.data(message, Demo.class);\n// Build Successful Envelop\nfinal Envelop envelop = Envelop.ok();\n// Build Successful Envelop with data\nDemo user = ...\nfinal Envelop envelop = Envelop.success( user );\n// Build Error Envelop with WebException\nWebException exception = ...\nfinal Envelop error = Envelop.failure(exception);\n</code></pre>"},{"location":"zero-envelop/#4-data-format","title":"4. Data Format","text":"<p>Success:</p> <pre><code>{\n\"data\": \"Different data format for this field\"\n}\n</code></pre> <p>Failure</p> <pre><code>{\n\"message\": \"Error message description\",\n\"code\": -40013\n}\n</code></pre> <ul> <li>brief: Http Status</li> <li>status: Http Status Code</li> <li>data: Data part ( Successful only )</li> <li>code: Zero Error Code ( Negative number )</li> <li>message: Zero Message ( Describe the number meaning )</li> </ul>"},{"location":"zero-error/","title":"Define WebException","text":"<p>Zero system provide simple error define for user.</p>"},{"location":"zero-error/#1-configuration","title":"1. Configuration","text":"<p>In your class path, create a new up.god.file named <code>vertx-error.yml</code>\uff0cthe format is as following:</p> <pre><code>E100001: User defined Error {0}, details = {1}\n</code></pre> <p>The detail implementation used MessageFormat, do not support named parameters.</p>"},{"location":"zero-error/#2-create-class","title":"2. Create Class","text":"<p>Create new class that you wanted as following</p> <pre><code>import io.horizon.exception.WebException;\npublic class TestRequestException extends\nWebException {\npublic TestRequestException(final Class&lt;?&gt; clazz,\nfinal String name,\nfinal String detail) {\nsuper(clazz, name, detail);\n}\n@Override\npublic int getCode() {\nreturn -100001;\n}\n}\n</code></pre> <ul> <li>Please ignore the first parameter <code>Class&lt;?&gt;</code>, it's for Zero to detect the error happened class position;</li> <li>The rest parameters could be pass any length, you could call <code>super(clazz, arg0, arg1, ...)</code></li> <li>Be sure to write the <code>getCode()</code> method, this method must be match with the <code>vertx-error.yml</code> prefix: <code>E&lt;code&gt;</code> as   message key</li> <li>If you want to change HttpStatusCode, you could overwrite <code>getStatus()</code> as following:</li> </ul> <pre><code>    public HttpStatusCode getStatus() {\n// Default exception for 400\nreturn HttpStatusCode.BAD_REQUEST;\n}\n</code></pre>"},{"location":"zero-error/#3-build-envelop-with-error","title":"3. Build Envelop with Error","text":"<p>Then in your code, write following code:</p> <pre><code>    @Address(\"ZERO://USER\")\npublic Envelop reply(final Envelop message) {\nfinal User user = message.data(User.class);\nfinal WebException error = new TestRequestException(getClass(),\n\"Lang\", \"Detail\");\nreturn Envelop.failure(error);\n}\n</code></pre>"},{"location":"zero-error/#4-running-the-app","title":"4. Running the App","text":"<p>You'll see following error response:</p> <pre><code>{\n\"brief\": \"Bad Request\",\n\"status\": 400,\n\"code\": -100001,\n\"message\": \"[ERR-100001] (UserWorker) ZeroException occurs: User defined Error Lang, details = Detail.\"\n}\n</code></pre>"},{"location":"zero-fling/","title":"Fling Function","text":"<ul> <li>Fling is similiar with throw out action, it means that the exception must be throw out in these actions, it could   simply the code flow to throw out specific exception.</li> </ul>"},{"location":"zero-fling/#1-definition","title":"1. Definition","text":"<pre><code>/**\n *  1. If the condition is true ( arg 0 ), Zero system will build the target Exception \n *  with Class&lt;?&gt; ( arg 2 ) and arguments ( arg 3 ).\n *  2. Once exception build successfully, the Annal ( arg 1 ) will record the exception first\n *  3. Then the exception will be throw out.\n **/\npublic static void flingZero(\nfinal boolean condition,\nfinal Annal logger,\nfinal Class&lt;? extends ZeroException&gt; zeroClass,\nfinal Object... args\n) throws ZeroException\npublic static void flingUp(\nfinal boolean condition,\nfinal Annal logger,\nfinal Class&lt;? extends ZeroRunException&gt; upClass,\nfinal Object... args\n)\n</code></pre>"},{"location":"zero-fling/#2-example","title":"2. Example","text":""},{"location":"zero-fling/#21-flingzero","title":"2.1. flingZero","text":"<pre><code>        final JsonObject data = this.NODE.read();\nFn.flingZero(null == data || !data.containsKey(Key.SERVER), LOGGER,\nServerConfigException.class,\ngetClass(), null == data ? null : data.encode());\nreturn visit(data.getJsonArray(Key.SERVER));\n</code></pre> <p>Code Flow</p> <ol> <li>This function verify the condition <code>null == data || !data.containsKey(Key.SERVER)</code>;</li> <li>Once the condition is checked correct, it means that the exception will be throw out;</li> <li>Then zero system will build exception <code>ServerConfigException</code> with arguments <code>Class&lt;?&gt;, String</code>;</li> <li>Then zero system record the exception information with <code>LOGGER</code> first. Refer Home Page to check Logging    initialization.</li> <li>Then the function throw out the exception and the programming terminaled.</li> </ol>"},{"location":"zero-fling/#22-flingup","title":"2.2. flingUp","text":"<p>The method <code>flingUp</code> code flow is the same as <code>flingZero</code> except the exception type.</p> <ul> <li><code>flingZero</code>: Throw out <code>io.horizon.exception.ProgramException</code> ( Checked )</li> <li><code>flingUp</code>\uff1aThrow out <code>io.horizon.exception.AbstractException</code> ( Runtime )</li> </ul>"},{"location":"zero-flow/","title":"Zero flow","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:f784c06755caceb78c4b203df124552aa0922cf35ef07eb48985d97b8e3377b5 size 1233</p>"},{"location":"zero-get/","title":"Get Function","text":"<ul> <li>get is the function to execute and return to generic T object reference.</li> </ul>"},{"location":"zero-get/#1-definition","title":"1. Definition","text":"<pre><code>    /**\n     * If supplier throw out exception, set return value to defaultValue\n     * If all input objects are null, set return value to defaultValue\n     **/\npublic static &lt;T&gt; T getJvm(\nfinal T defaultValue,\nfinal JvmSupplier&lt;T&gt; supplier,\nfinal Object... input\n)\n/**\n     * default value is null\n     **/\npublic static &lt;T&gt; T getJvm(\nfinal JvmSupplier&lt;T&gt; supplier,\nfinal Object... input\n)\npublic static &lt;T&gt; T get(\nfinal Supplier&lt;T&gt; supplier,\nfinal Object... input\n) public static &lt;T&gt; T get(\nfinal T defaultValue,\nfinal Supplier&lt;T&gt; supplier,\nfinal Object... input\n)\npublic static &lt;T&gt; T getSemi(\nfinal boolean condition,\nfinal Annal logger,\nfinal Supplier&lt;T&gt; tSupplier,\nfinal Supplier&lt;T&gt; fSupplier\n)\npublic static &lt;T&gt; T getSemi(\nfinal boolean condition,\nfinal ZeroSupplier&lt;T&gt; tSupplier,\nfinal ZeroSupplier&lt;T&gt; fSupplier\n) throws ZeroException\n</code></pre>"},{"location":"zero-get/#2-example","title":"2. Example","text":""},{"location":"zero-get/#21-getjvm","title":"2.1. getJvm","text":"<pre><code>        return Fn.getJvm(() -&gt; {\nfinal BufferedReader reader =\nnew BufferedReader(\nnew InputStreamReader(in, Values.ENCODING)\n);\n// Character stream\nString line;\nwhile (null != (line = reader.readLine())) {\nbuffer.append(line);\n}\nreader.close();\nreturn buffer.toString();\n}, in);\n</code></pre> <p>Code Flow</p> <ol> <li>The system checked the <code>in</code> variable first ( If null );</li> <li>If it's not null, the function body will execute;</li> <li>The function body will throw <code>java.lang.Exception</code>, once it occurs it will be caught;</li> </ol>"},{"location":"zero-get/#22-get","title":"2.2. get","text":"<p>This function <code>get</code> code flow is the same as <code>getJvm</code>, but there is no exception in function body. Be careful the last argument could support more than one object reference checking.</p> <pre><code>    Fn.getJvm(() -&gt; {\n// ... Do something\n}, arg1, arg2, arg3);\n</code></pre>"},{"location":"zero-get/#23-getsemi","title":"2.3. getSemi","text":"<pre><code>    return Fn.getSemi(null == config, LOGGER,\nClusterOptions::new,\n() -&gt; new ClusterOptions(config));\n</code></pre> <p>This code flow is a little same as <code>safeSemi</code>, but there should be value returned.</p> <p>Code Flow</p> <ol> <li>If config is null, the first function will execute;</li> <li>Otherwise, the second function will execute;</li> <li>Once met the exception, LOGGER will record the exception details.</li> </ol>"},{"location":"zero-get/#3-summary","title":"3. Summary","text":"<p>Each <code>getX</code> function has a version to provide default value as following:</p> <pre><code>    public static &lt;T&gt; T get(\nfinal T defaultValue,\nfinal Supplier&lt;T&gt; supplier,\nfinal Object... input\n)\n</code></pre> <p>In this situation, it means that once each element of input are all null, return <code>defaultValue</code> instead of return null.</p>"},{"location":"zero-hoc/","title":"Function Programming","text":""},{"location":"zero-hoc/#1-function-interface","title":"1. Function interface","text":"<p>Zero system extend function interface system based on java8.</p> <ul> <li><code>java.util.function.Consumer&lt;T&gt;</code>\uff1a<code>void accept(T t)</code>\uff1b</li> <li><code>java.util.function.BiConsumer&lt;T, U&gt;</code>\uff1a<code>void accept(T t, U u)</code>\uff1b</li> <li><code>java.util.function.Predicate&lt;T&gt;</code>\uff1a<code>boolean test(T t)</code>;</li> <li><code>java.util.function.Supplier&lt;T&gt;</code>\uff1a<code>T get()</code>\uff1b</li> <li><code>java.util.function.Function&lt;T, R&gt;</code>\uff1a<code>R apply(T t)</code>\uff1b</li> </ul> <p>Extension by zero for specifical usage.</p> <ul> <li><code>io.horizon.fn.Actuator</code>\uff1a<code>void execute()</code>\uff1b</li> <li><code>io.horizon.fn.ExceptionSupplier&lt;T&gt;</code>\uff1a<code>T get() throws Exception</code>\uff1b</li> <li><code>io.horizon.fn.ExceptionActuator</code>\uff1a<code>void execute() throws Exception</code>\uff1b</li> <li><code>io.horizon.fn.ProgramActuator</code>\uff1a<code>void execute() throws ZeroException</code>\uff1b</li> <li><code>io.horizon.fn.ProgramSupplier&lt;T&gt;</code>\uff1a<code>T get() throws ZeroException</code>\uff1b</li> <li><code>io.horizon.fn.ProgramBiConsumer&lt;T,R&gt;</code>: <code>void accept(T input, R second) throws ZeroException</code></li> </ul>"},{"location":"zero-hoc/#2-fn","title":"2. Fn","text":"<p>In Zero system, there defined a supper static class for function abstract to simply the coding, this class is <code>io.vertx.up.fn.Fn</code>, You also could use following function in your coding.</p> <pre><code>// Zero Logger initialized, connect to vert.x logging system directly but uniform managed by zero.\nimport io.horizon.log.Annal;\n// Then in your class\npublic final class Statute {\nprivate static final Annal LOGGER = Annal.get(Statute.class);\n......\n}\n</code></pre>"},{"location":"zero-hoc/#21-fling","title":"2.1. Fling","text":"<ul> <li>Fling is similiar with throw out action, it means that the exception must be throw out in these actions.</li> </ul> <pre><code>/**\n *  1. If the condition is true ( arg 0 ), Zero system will build the target Exception \n *  with Class&lt;?&gt; ( arg 2 ) and arguments ( arg 3 ).\n *  2. Once exception build successfully, the Annal ( arg 1 ) will record the exception first\n *  3. Then the exception will be throw out.\n **/\npublic static void flingZero(\nfinal boolean condition,\nfinal Annal logger,\nfinal Class&lt;? extends ZeroException&gt; zeroClass,\nfinal Object... args\n) throws ZeroException\npublic static void flingUp(\nfinal boolean condition,\nfinal Annal logger,\nfinal Class&lt;? extends ZeroRunException&gt; upClass,\nfinal Object... args\n)\n</code></pre>"},{"location":"zero-hoc/#22-safe-running","title":"2.2. Safe Running","text":"<ul> <li>safe is be sure in any situation the code could execute correctly.</li> </ul> <pre><code>    /**\n     *  Once the actuator executing met JVM exception ( inherit from Throwable ), the logger will record the error message.\n     **/\npublic static void safeJvm(\nfinal JvmActuator actuator,\nfinal Annal logger\n)\npublic static &lt;T&gt; T safeJvm(\nfinal JvmSupplier&lt;T&gt; supplier,\nfinal Annal logger\n)\n/**\n     *  Once the actuator executing met JVM exception ( inherit from ZeroException ), the logger will record the error message.\n     **/\npublic static void safeZero(\nfinal ZeroActuator actuator,\nfinal Annal logger\n)\npublic static &lt;T&gt; T safeZero(\nfinal ZeroSupplier&lt;T&gt; supplier,\nfinal Annal logger\n)\n/** \n     * Once all the input objects are null, the Actuator function will not execute, be sure no null pointer object input into actuator.\n     **/\npublic static void safeNull(\nfinal Actuator actuator,\nfinal Object... input\n) public static &lt;T&gt; void safeNull(\nfinal Consumer&lt;T&gt; consumer,\nfinal T input\n)\n/**\n     * If condition is true, execute tSupplier, otherwise execute fSupplier.\n     */\npublic static void safeSemi(\nfinal boolean condition,\nfinal Annal logger,\nfinal Actuator tSupplier,\nfinal Actuator fSupplier\n)\n</code></pre>"},{"location":"zero-hoc/#23-transshunt","title":"2.3. Trans/Shunt","text":"<ul> <li>trans means there exist exception converter from Throwable to ZeroException</li> <li>shunt means there may throw out exception ( ZeroException / ZeroRunException ) only</li> </ul> <pre><code>    public static &lt;T&gt; T transRun(\nfinal Supplier&lt;T&gt; supplier,\nfinal Class&lt;? extends ZeroRunException&gt; runCls,\nfinal Object... args\n)\npublic static void shuntRun(\nfinal Actuator actuator,\nfinal Annal logger\n)\npublic static void shuntZero(\nfinal ZeroActuator actuator,\nfinal Object... input\n) throws ZeroException\n</code></pre>"},{"location":"zero-hoc/#24-get","title":"2.4. Get","text":"<pre><code>    /**\n     * If supplier throw out exception, set return value to defaultValue\n     * If all input objects are null, set return value to defaultValue\n     **/\npublic static &lt;T&gt; T getJvm(\nfinal T defaultValue,\nfinal JvmSupplier&lt;T&gt; supplier,\nfinal Object... input\n)\n/**\n     * default value is null\n     **/\npublic static &lt;T&gt; T getJvm(\nfinal JvmSupplier&lt;T&gt; supplier,\nfinal Object... input\n)\npublic static &lt;T&gt; T get(\nfinal Supplier&lt;T&gt; supplier,\nfinal Object... input\n) public static &lt;T&gt; T get(\nfinal T defaultValue,\nfinal Supplier&lt;T&gt; supplier,\nfinal Object... input\n)\npublic static &lt;T&gt; T getSemi(\nfinal boolean condition,\nfinal Annal logger,\nfinal Supplier&lt;T&gt; tSupplier,\nfinal Supplier&lt;T&gt; fSupplier\n)\npublic static &lt;T&gt; T getSemi(\nfinal boolean condition,\nfinal ZeroSupplier&lt;T&gt; tSupplier,\nfinal ZeroSupplier&lt;T&gt; fSupplier\n) throws ZeroException\n</code></pre>"},{"location":"zero-hoc/#25-collection","title":"2.5. Collection","text":"<pre><code>    public static &lt;K, V&gt; void itMap(\nfinal ConcurrentMap&lt;K, V&gt; map,\nfinal BiConsumer&lt;K, V&gt; fnEach)\n)\npublic static &lt;V&gt; void itSet(\nfinal Set&lt;V&gt; set,\nfinal BiConsumer&lt;V, Integer&gt; fnEach\n)\npublic static &lt;V&gt; void itList(\nfinal List&lt;V&gt; list,\nfinal BiConsumer&lt;V, Integer&gt; fnEach\n)\npublic static &lt;T&gt; void itJObject(\nfinal JsonObject data,\nfinal BiConsumer&lt;T, String&gt; fnEach\n)\npublic static &lt;T&gt; void etJObject(\nfinal JsonObject data,\nfinal ZeroBiConsumer&lt;T, String&gt; fnIt\n) throws ZeroException\npublic static &lt;T&gt; void itJArray(\nfinal JsonArray array,\nfinal Class&lt;T&gt; clazz,\nfinal BiConsumer&lt;T, Integer&gt; fnEach\n)\npublic static &lt;T&gt; void etJArray(\nfinal JsonArray dataArray,\nfinal Class&lt;T&gt; clazz,\nfinal ZeroBiConsumer&lt;T, Integer&gt; fnIt\n) throws ZeroException\npublic static &lt;T&gt; void etJArray(\nfinal JsonArray dataArray,\nfinal ZeroBiConsumer&lt;T, String&gt; fnIt\n) throws ZeroException\n</code></pre>"},{"location":"zero-hoc/#26-poolgroupzipper","title":"2.6. Pool/Group/Zipper","text":"<pre><code>    public static &lt;K, V&gt; V pool(\nfinal ConcurrentMap&lt;K, V&gt; pool,\nfinal K key,\nfinal Supplier&lt;V&gt; poolFn)\npublic static &lt;V&gt; V poolThread(\nfinal ConcurrentMap&lt;String, V&gt; pool,\nfinal Supplier&lt;V&gt; poolFn)\npublic static &lt;K, V, E&gt; ConcurrentMap&lt;K, List&lt;V&gt;&gt; packet(\nfinal Collection&lt;E&gt; object,\nfinal Function&lt;E, K&gt; keyFn,\nfinal Function&lt;E, V&gt; valueFn\n)\npublic static &lt;K, V, E&gt; ConcurrentMap&lt;K, V&gt; zipper(\nfinal E[] object,\nfinal Function&lt;E, K&gt; keyFn,\nfinal Function&lt;E, V&gt; valueFn)\npublic static &lt;K, V, E&gt; ConcurrentMap&lt;K, V&gt; zipper(\nfinal Collection&lt;E&gt; object,\nfinal Function&lt;E, K&gt; keyFn,\nfinal Function&lt;E, V&gt; valueFn\n)\n</code></pre>"},{"location":"zero-hoc/#27-nullflow","title":"2.7. NullFlow","text":"<pre><code>    public static &lt;T, F&gt; T nullFlow(final F reference,\nfinal Function&lt;F, T&gt; tranFn,\nfinal Supplier&lt;T&gt; supplier)\n</code></pre>"},{"location":"zero-hoc/#3-summary","title":"3. Summary","text":"<p>Provide all these function could simply the code and write more defence code in your programming, it could avoid some common exception such as NullPointer, IndexOf etc. Also it could simple some collection iterator and caculation.</p> <p>Example 1:</p> <pre><code>    public static ConcurrentMap&lt;String, Annotation&gt; get(final Class&lt;?&gt; clazz) {\nreturn Fn.get(() -&gt; {\nfinal Annotation[] annotationes = clazz.getDeclaredAnnotations();\n// Zipper\nreturn Fn.zipper(annotationes,\n(item) -&gt; item.annotationType().getName(),\n(item) -&gt; item);\n}, clazz);\n}\n// This function workflow is as following\n// 1. Check whether clazz is null, if null return directly.\n// 2. Get annotation array from clazz definition\n// 3. Generate map ( key = annotation name, value = Annotation )\n</code></pre> <p>Example 2:</p> <pre><code>        final JsonObject config = dyanmic.read();\n// If the config does not contain getKey() value, the exception will be throw out. \n// avoid config.getJsonObject cause ClassCastException, NullPointerException here.\nFn.flingUp(!config.containsKey(getKey()), getLogger(),\nConfigKeyMissingException.class, getClass(), getKey());\nreturn config.getJsonObject(this.getKey());\n</code></pre>"},{"location":"zero-interface/","title":"Interface Annotation","text":"<p>The interface annotation could be as following:</p>"},{"location":"zero-interface/#1-source-code","title":"1. Source Code","text":"<p>UserApi</p> <pre><code>import io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.NotNull;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@Path(\"/zero/user\")\n@EndPoint\npublic interface UserApi {\n@Path(\"/login\")\n@GET\nString login(\n@QueryParam(\"username\") @NotNull(message = \"\u7528\u6237\u540d\u4e0d\u80fd\u4e3a\u7a7a\")\nString username,\n@QueryParam(\"password\") @NotNull(message = \"\u5bc6\u7801\u4e0d\u80fd\u4e3a\u7a7a\")\nString password\n);\n}\n</code></pre> <p>UserActor</p> <pre><code>public class UserActor implements UserApi {\n@Override\npublic String login(final String username,\nfinal String password) {\nreturn \"Hello\";\n}\n}\n</code></pre>"},{"location":"zero-interface/#2-console","title":"2. Console","text":"<pre><code>[ ZERO ] ( 1 Event ) The endpoint io.vertx.up.example.api.jsr303.UserApi scanned 1 events of Event, ...\n...\n[ ZERO ] ( Uri Register ) \"/zero/user/login\" has been deployed by ZeroHttpAgent\n</code></pre>"},{"location":"zero-interface/#3-curl-testing","title":"3. Curl Testing","text":"<pre><code>curl http://localhost:6083/zero/user/login\n{\"brief\":\"OK\",\"status\":200,\"data\":\"Hello\"}\n</code></pre>"},{"location":"zero-interface/#4-hints","title":"4. Hints","text":"<ul> <li>This interface must contains only one implementation class, once it's more than 1, <code>DuplicatedImplException</code> will   throw out.</li> </ul>"},{"location":"zero-istio/","title":"Istio Environment","text":""},{"location":"zero-istio/#1-preparing-setup","title":"1. Preparing &amp; Setup","text":"<p>Before you want to setup local development environment, you must setup local k8s cluster first. Please refer following link to prepare it:</p> <p>VM Environment</p> <ul> <li>Install a hypervisor</li> <li>Install kubectl</li> <li>Install Minikube</li> </ul>"},{"location":"zero-istio/#11-install-vm-recommend-xhyve-on-mac","title":"1.1. Install VM ( Recommend xhyve on Mac )","text":"<p>Because the demo environment is MacOS, you can do as following:</p> <pre><code>brew install docker-machine-driver-xhyve\n\n# docker-machine-driver-xhyve need root owner and uid, following steps are required.\n$ sudo chown root:wheel $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve\n$ sudo chmod u+s $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve\n</code></pre>"},{"location":"zero-istio/#12-minikube-install","title":"1.2. Minikube Install","text":"<p>minikube</p> <p>MacOS</p> <pre><code>brew cask install minikube\n</code></pre> <p>For other system please refer above installing guide.</p>"},{"location":"zero-istio/#13-kubernete-client","title":"1.3. Kubernete Client","text":"<p>kubectl Installing</p> <p>MacOS</p> <pre><code>brew install kubectl\n</code></pre>"},{"location":"zero-istio/#14-start-environment","title":"1.4. Start Environment","text":"<ol> <li>Start minikube</li> </ol> <p><pre><code>&gt;&gt; minikube start\nStarting local Kubernetes v1.8.0 cluster...\nStarting VM...\nGetting VM IP address...\nMoving files into cluster...\nSetting up certs...\nConnecting to cluster...\nSetting up kubeconfig...\nStarting cluster components...\nKubectl is now configured to use the cluster.\nLoading cached images from config up.god.file.\n</code></pre> 2. Version checking</p> <p><pre><code>&gt;&gt; kubectl version\nClient Version: version.Info{Major:\"1\", Minor:\"8\", GitVersion:\"v1.8.4\", \\\nGitCommit:\"9befc2b8928a9426501d3bf62f72849d5cbcd5a3\", GitTreeState:\"clean\",  \\\nBuildDate:\"2017-11-20T19:11:02Z\", GoVersion:\"go1.9.2\", Compiler:\"gc\", Platform:\"darwin/amd64\"}\nServer Version: version.Info{Major:\"1\", Minor:\"8\", GitVersion:\"v1.8.0\", \\\nGitCommit:\"0b9efaeb34a2fc51ff8e4d34ad9bc6375459c4a4\",  GitTreeState:\"clean\", \\\nBuildDate:\"2017-11-29T22:43:34Z\", GoVersion:\"go1.9.1\", Compiler:\"gc\", Platform:\"linux/amd64\"}\n</code></pre> 3. Setup \"Hello World\" with kubectl</p> <p><pre><code>&gt;&gt; kubectl run hello-minikube --image=gcr.io/google_containers/echoserver:1.8 --port=6001\ndeployment \"hello-minikube\" created\n</code></pre> 4. Deploy the first service</p> <p><pre><code>&gt;&gt; kubectl expose deployment hello-minikube --type=NodePort\nservice \"hello-minikube\" exposed\n</code></pre> 5. Open dashboard</p> <p><pre><code>&gt;&gt; minikube dashboard\nOpening kubernetes dashboard in default browser...\n</code></pre> 6. Then you should see that browser has been opened and following page will be showed.</p> <p></p> <p>Then your basic environment has been finished.</p>"},{"location":"zero-istio/#2-istio-envrionment","title":"2. Istio Envrionment","text":"<p>Quick Start</p> <p>Demo example will be install istio to <code>~/Tool/Zero/</code></p> <ol> <li>Install and download istio</li> </ol> <pre><code>curl -L https://git.io/getLatestIstio | sh -\n...... # Wait for ISO up.god.file downloading finished.\n</code></pre> <ol> <li>Set Up environment.</li> </ol> <p><pre><code>Add /Users/lang/Tool/Zero/istio-0.2.12/bin to your path; \\\n    e.g copy paste in your shell and/or ~/.profile:\nexport PATH=\"$PATH:/Users/lang/Tool/Zero/istio-0.2.12/bin\"\n# Then be sure the command \"istioctl\" could be used. ( Latest 0.2.12 )\nistioctl version\nVersion: 0.2.12\nGitRevision: 998e0e00d375688bcb2af042fc81a60ce5264009\nGitBranch: release-0.2\nUser: releng@0d29a2c0d15f\nGolangVersion: go1.8\n</code></pre> 3. Install \"istio\" on local K8s</p> <pre><code>&gt;&gt; cd istio-0.2.12\n\n&gt;&gt; pwd\n/Users/lang/Tool/Zero/istio-0.2.12\n\n&gt;&gt; kubectl get svc -n istio-system\nNo resources found.\n\n&gt;&gt; kubectl apply -f install/kubernetes/istio.yaml ( None TLS mode )\nnamespace \"istio-system\" created\n...... ( All the progress logs will be output )\ndeployment \"istio-ca\" created\n</code></pre> <ol> <li>Ensure the four services: <code>istio-pilot, istio-mixer, istio-ingress, istio-egress</code></li> </ol> <pre><code>&gt;&gt; kubectl get svc -n istio-system\nNAME            TYPE           CLUSTER-IP       ......\nistio-egress    ClusterIP      10.97.67.39     ......\nistio-ingress   LoadBalancer   10.111.235.49   ......\nistio-mixer     ClusterIP      10.106.88.96    ......\nistio-pilot     ClusterIP      10.106.188.200  ......\n&gt;&gt; kubectl get pods -n istio-system\nistio-ca-5cd46b967c-kmx58        1/1       Running   0          4m\nistio-egress-56c4d999bc-dv8md    1/1       Running   0          4m\nistio-ingress-5747bb855f-n74sz   1/1       Running   0          4m\nistio-mixer-77487797f6-d5ns9     2/2       Running   0          4m\nistio-pilot-86ddcb7ff5-cmcr5     1/1       Running   0          4m\n</code></pre> <ol> <li>Select \"istio-system\" on the dashboard left menu</li> </ol> <p></p>"},{"location":"zero-istio/#3-addon-for-istio","title":"3. Addon for Istio","text":"<p>If you want to enable metrics collection, you can do as following:</p> <p>Reference</p> <pre><code>kubectl apply -f install/kubernetes/addons/prometheus.yaml\nkubectl apply -f install/kubernetes/addons/grafana.yaml\nkubectl apply -f install/kubernetes/addons/servicegraph.yaml\n</code></pre> <p>It may take some time to process all the components installed.</p>"},{"location":"zero-istio/#31-install-grafana","title":"3.1. Install Grafana","text":"<ol> <li>You can type following command to configure port-forwarding for <code>grafana</code></li> </ol> <p><pre><code>kubectl -n istio-system port-forward \\\n    $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') \\\n        3000:3000 &amp;\n</code></pre> 2. Then open uri <code>http://localhost:3000/dashboard/db/istio-dashboard</code> with your browser. 3. You should see following page:</p> <p></p>"},{"location":"zero-istio/#32-service-graph","title":"3.2. Service Graph","text":"<ol> <li>You can type following command to configure port-forwarding for <code>servicegraph</code></li> </ol> <p><pre><code>kubectl -n istio-system port-forward \\\n    $(kubectl get pod -n istio-system -l app=servicegraph -o jsonpath='{.items[0].metadata.name}') \\\n        8088:8088 &amp;\n</code></pre> 2. Then open url <code>http://localhost:8088/dotviz</code> or <code>http://localhost:8088/graph</code> with your browser, if there exist the    services, you should see JSON data or graph.</p>"},{"location":"zero-istio/#33-zipkin-dashboard","title":"3.3. Zipkin Dashboard","text":"<ol> <li>You can type following command to configure port-forwarding for <code>zipkin</code></li> </ol> <p><pre><code>kubectl -n istio-system port-forward \\\n    $(kubectl get pod -n istio-system -l app=zipkin -o jsonpath='{.items[0].metadata.name}') \\\n        9411:9411 &amp;\n</code></pre> 2. Then open uri <code>http://localhost:9411/zipkin/</code> with your browser: 3. You should see following page:</p> <p></p>"},{"location":"zero-istio/#34-prometheus","title":"3.4. Prometheus","text":"<ol> <li>You can type following command to configure port-forwarding for <code>prometheus</code></li> </ol> <p><pre><code> kubectl -n istio-system port-forward \\\n     $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') \\\n         9090:9090 &amp;   \n</code></pre> 2. Then open uri <code>http://localhost:9090/graph</code> with your browser: 3. You should see following page:</p> <p></p>"},{"location":"zero-istio/#summary","title":"Summary","text":"<p>Then the docker and istio environments have been both prepared.</p>"},{"location":"zero-it/","title":"It Function","text":"<ul> <li>It means iteration on collections instead of java iteration</li> </ul>"},{"location":"zero-it/#1-definition","title":"1. Definition","text":"<pre><code>    public static &lt;K, V&gt; void itMap(\nfinal ConcurrentMap&lt;K, V&gt; map,\nfinal BiConsumer&lt;K, V&gt; fnEach)\n)\npublic static &lt;V&gt; void itSet(\nfinal Set&lt;V&gt; set,\nfinal BiConsumer&lt;V, Integer&gt; fnEach\n)\npublic static &lt;V&gt; void itList(\nfinal List&lt;V&gt; list,\nfinal BiConsumer&lt;V, Integer&gt; fnEach\n)\npublic static &lt;T&gt; void itJObject(\nfinal JsonObject data,\nfinal BiConsumer&lt;T, String&gt; fnEach\n)\npublic static &lt;T&gt; void etJObject(\nfinal JsonObject data,\nfinal ZeroBiConsumer&lt;T, String&gt; fnIt\n) throws ZeroException\npublic static &lt;T&gt; void itJArray(\nfinal JsonArray array,\nfinal Class&lt;T&gt; clazz,\nfinal BiConsumer&lt;T, Integer&gt; fnEach\n)\npublic static &lt;T&gt; void etJArray(\nfinal JsonArray dataArray,\nfinal Class&lt;T&gt; clazz,\nfinal ZeroBiConsumer&lt;T, Integer&gt; fnIt\n) throws ZeroException\npublic static &lt;T&gt; void etJArray(\nfinal JsonArray dataArray,\nfinal ZeroBiConsumer&lt;T, String&gt; fnIt\n) throws ZeroException\n</code></pre>"},{"location":"zero-it/#2-example","title":"2. Example","text":""},{"location":"zero-it/#21-one-point","title":"2.1. One Point","text":"<p>This article will not record some common example for collection iteration, instead, please refer following point:</p> <ol> <li>Zero will check the element type to see whether it's null, these functions will ignore all the null element ( null    key, null value );</li> <li>The <code>it</code> prefix will do iteration without any exception throw out;</li> <li>The <code>et</code> prefix will do iteration with <code>ZeroException</code> out instead of no exception;</li> <li><code>List, Set</code> will append <code>index</code> for iteration as the second argument;</li> <li>Specific Iteration for JsonArray provided ( <code>1st level -&gt; 2nd level</code> );</li> </ol>"},{"location":"zero-it/#22-specific-iteration","title":"2.2. Specific Iteration","text":"<p>This function is a little different from other:</p> <pre><code>    public static &lt;T&gt; void etJArray(\nfinal JsonArray dataArray,\nfinal ZeroBiConsumer&lt;T, String&gt; fnIt\n) throws ZeroException </code></pre> <p>This function will iterate each element inner JsonObject,</p> <ol> <li>The function iterate the <code>JsonArray</code> as 1st level;</li> <li>Then the function iterate the <code>JsonObject</code> ( Each array element must be JsonObject) as 2nd level;</li> <li>The function body only focus on the <code>JsonObject</code> ( key = value );</li> </ol>"},{"location":"zero-mime/","title":"Mime type supported","text":""},{"location":"zero-mime/#1-types","title":"1. Types","text":""},{"location":"zero-mime/#11-mime-types","title":"1.1. Mime Types","text":"<ul> <li>Text: <code>text/*</code></li> <li>Multipart: <code>multipart/*</code></li> <li>Application: <code>application/*</code></li> <li>Message: <code>message/*</code></li> <li>Image: <code>image/*</code></li> <li>Audio: <code>audio/*</code></li> <li>Video: <code>video/*</code></li> </ul>"},{"location":"zero-mime/#12-java-annotations","title":"1.2. Java Annotations","text":"<ul> <li>[x] <code>javax.ws.rs.QueryParam</code></li> <li>[x] <code>javax.ws.rs.FormParam</code></li> <li>[ ] <code>javax.ws.rs.MatrixParam</code></li> <li>[x] <code>javax.ws.rs.PathParam</code></li> <li>[x] <code>javax.ws.rs.HeaderParam</code></li> <li>[x] <code>javax.ws.rs.CookieParam</code></li> <li>[x] <code>jakarta.ws.rs.BodyParam</code></li> <li>[x] <code>jakarta.ws.rs.StreamParam</code></li> <li>[x] <code>jakarta.ws.rs.SessionParam</code></li> </ul>"},{"location":"zero-mime/#2-java-types","title":"2. Java Types","text":""},{"location":"zero-mime/#21-primary","title":"2.1. Primary","text":"<p>Ignored <code>java.lang.char</code> and <code>java.lang.byte</code> because it's not common.</p> <ul> <li><code>java.lang.int</code></li> <li><code>java.lang.short</code></li> <li><code>java.lang.long</code></li> <li><code>java.lang.double</code></li> <li><code>java.lang.float</code></li> <li><code>java.lang.boolean</code></li> </ul>"},{"location":"zero-mime/#22-wrapper","title":"2.2. Wrapper","text":"<ul> <li><code>java.lang.Integer</code></li> <li><code>java.lang.Short</code></li> <li><code>java.lang.Long</code></li> <li><code>java.lang.Double</code></li> <li><code>java.lang.Float</code></li> <li><code>java.lang.Enum</code></li> <li><code>java.lang.Boolean</code></li> <li><code>java.lang.String</code></li> <li><code>java.lang.StringBuilder</code></li> <li><code>java.lang.StringBuffer</code></li> <li><code>java.math.BigDecimal</code></li> <li><code>java.util.Date</code></li> <li><code>java.util.Calendar</code> - Abstract Class</li> <li><code>java.util.Set</code> - Interface</li> <li><code>java.util.List</code> - Interface</li> <li><code>java.util.Collection</code> - Interface</li> <li><code>io.vertx.core.json.JsonArray</code></li> <li><code>io.vertx.core.json.JsonObject</code></li> <li><code>io.vertx.core.buffer.Buffer</code></li> <li><code>java.lang.byte[]</code> - Array</li> <li><code>java.lang.Byte[]</code> - Array</li> <li><code>Pojo Object - T</code></li> <li><code>Pojo Collection - Collection&lt;T&gt;</code></li> <li><code>Pojo Array - T[]</code></li> </ul>"},{"location":"zero-mime/#23-typed-no-annotation","title":"2.3. Typed ( No annotation )","text":"<ul> <li><code>io.vertx.ext.web.Session</code></li> <li><code>io.vertx.core.http.HttpServerRequest</code></li> <li><code>io.vertx.core.http.HttpServerResponse</code></li> <li><code>io.vertx.core.eventbus.EventBus</code></li> <li><code>io.vertx.core.Vertx</code></li> <li><code>io.vertx.ext.auth.User</code></li> <li><code>io.vertx.ext.web.RoutingContext</code></li> </ul>"},{"location":"zero-mime/#3-specification-definition","title":"3. Specification Definition","text":""},{"location":"zero-mode/","title":"Request Mode","text":"<p>Zero system support five request modes as following ( Please ignore the name of the mode, it's for distinguish differences only )</p>"},{"location":"zero-mode/#1-mode-1-sync-mode","title":"1. Mode 1: Sync Mode","text":"<p>This mode is used for request response mode in vert.x, you can define your method as following:</p> <pre><code>    @GET\n@Path(\"/sync/string\")\npublic String syncRequest(\n@QueryParam(\"email\") final String email\n) {\nfinal String response = \"Testing finished\";\nreturn response;\n}\n</code></pre> <p>Rule:</p> <ol> <li>The return type of method type mustn't be <code>void</code>;</li> <li>Do not use <code>@Address</code> annotation on this method;</li> </ol> <p>Workflow</p> <p></p>"},{"location":"zero-mode/#2-mode-2-block-mode","title":"2. Mode 2: Block Mode","text":"<p>This mode is used for request only mode in vert.x, you cand define your method as following:</p> <pre><code>    @GET\n@Path(\"/block/{name}\")\npublic void blockRequest(\n@PathParam(\"name\") final String name) {\nSystem.out.println(\"block request\");\n}\n</code></pre> <p>Rule</p> <ol> <li>The return type of method must be <code>void</code>;</li> <li>Do not want to get any data from response, this kind of mode only provide status of this job</li> </ol> <p>Workflow</p> <p></p>"},{"location":"zero-mode/#3-mode-3-one-way-mode","title":"3. Mode 3: One Way Mode","text":"<p>This mode is samiliar with Mode2, but the data will send to event bus to execute async jobs. ( Will be removed )</p> <p>Sender</p> <pre><code>    @POST\n@Path(\"/one-way/user\")\n@Address(\"ZERO://USER\")\npublic String sendNotify(\n@BodyParam final User user) {\nfinal String response = Jackson.serialize(user);\nreturn response;\n}\n</code></pre> <p>Consumer</p> <pre><code>    @Address(\"ZERO://USER\")\npublic void reply(final Envelop message) {\nfinal User user = message.data(User.class);\n// Do somethings\n}\n</code></pre> <p>Rule</p> <ol> <li>The methods of <code>@EndPoint</code> and <code>@Queue</code> must be annotated with <code>@Address</code> and they are the same between sender and    consumer</li> <li>The return type of method in <code>@EndPoint</code> mustn't be <code>void</code></li> <li>You must be define the consumer method signature to <code>public void xxx(Envelop)</code></li> </ol> <p>Workflow</p> <p></p>"},{"location":"zero-mode/#4-mode-4-async-mode-java-style","title":"4. Mode 4: Async Mode ( Java Style )","text":"<p>This mode is async request response mode between consumer and sender on event bus.</p> <p>Sender</p> <pre><code>    @POST\n@Path(\"/async/user\")\n@Address(\"ZERO://ROLE\")\npublic String sendAsync(\n@BodyParam final User user) {\nfinal String response = Jackson.serialize(user);\nreturn response;\n}\n</code></pre> <p>Consumer</p> <pre><code>    @Address(\"ZERO://USER\")\npublic Envelop reply(final Envelop message) {\nfinal User user = message.data(User.class);\nfinal WebException error = new TestRequestException(getClass(),\n\"Lang\", \"Detail\");\nreturn Envelop.failure(error);\n}\n</code></pre> <p>Rule</p> <ol> <li>The methods of <code>@EndPoint</code> and <code>@Queue</code> must be annotated with <code>@Address</code> and they are the same between sender and    consumer</li> <li>The return type of method in <code>@EndPoint</code> mustn't be <code>void</code></li> <li>You must be define the consumer method signature to <code>public Envelop xxx(Envelop)</code></li> </ol> <p>Workflow</p> <p></p>"},{"location":"zero-mode/#4-mode-5-vertx-async-mode-vertx-style","title":"4. Mode 5: Vert.x Async Mode ( Vert.x Style )","text":"<p>This mode is supported for some vert.x component use in service layer of the system such as MongoClient, SQLClient etc.</p> <p>Sender ( The same as mode 4 )</p> <pre><code>    @Path(\"/event\")\n@POST\n@Address(\"ZERO://EVENT\")\npublic JsonObject sayEvent(\n@BodyParam final JsonObject data) {\nreturn data;\n}\n</code></pre> <p>Consumer</p> <pre><code>    @Mongo\nprivate transient MongoClient client;\n@Address(\"ZERO://ROLE\")\npublic void async(final Message&lt;Envelop&gt; message) {\nfinal User user = Envelop.data(message, User.class);\nfinal JsonObject userData = new JsonObject(Jackson.serialize(user));\nthis.client.save(\"DB_USER\", userData, res -&gt; {\nif (res.succeeded()) {\nmessage.reply(Envelop.success(\"Hello World\"));\n} else {\nres.cause().printStackTrace();\n}\n});\n}\n</code></pre> <p>Rule</p> <ol> <li>The methods of <code>@EndPoint</code> and <code>@Queue</code> must be annotated with <code>@Address</code> and they are the same between sender and    consumer</li> <li>The return type of method in <code>@EndPoint</code> mustn't be <code>void</code></li> <li>You must be define the consumer method signature to <code>public void xxx(Message&lt;Envelop&gt;)</code></li> <li>Don't forget call <code>reply(Envelop</code> in call back on <code>Message&lt;Envelop&gt;</code></li> </ol> <p>Workflow</p> <p></p> <p>All above request mode could describe different usage, but we recomment to use Mode 4 &amp; Mode 5. </p>"},{"location":"zero-mongo/","title":"Enable mongo-db","text":""},{"location":"zero-mongo/#1-configuration","title":"1. Configuration","text":"<p>In your classpath:</p> <p>vertx.yml</p> <pre><code>zero:\nlime: mongo\nvertx:\ninstance:\n- name: vx-zero\noptions:\nmaxEventLoopExecuteTime: 30000000000\n</code></pre> <p>vertx-mongo.yml</p> <pre><code>mongo: # The key must be mongo, could not be replaced.\ndb_name: vertx_zero_up\nport: 27017\nhost: 127.0.0.1\n</code></pre> <p>*: Here ignored sender code, the mongo db only supported in consumer class in standard way. Also the lime part is random, for example: Once you set the code as following:</p> <pre><code>    lime: mongo-db\n</code></pre> <p>You must set the up.god.file name in resource path is as <code>vertx-mongo-db.yml</code>, then you could set mongo db configuration in this up.god.file.</p> <p>vertx-inject.yml</p> <pre><code>mongo: io.vertx.tp.plugin.mongo.MongoInfix\n</code></pre>"},{"location":"zero-mongo/#2-consumer-code","title":"2. Consumer Code","text":"<pre><code>import io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.mongo.MongoClient;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport javax.inject.infix.Mongo;\nimport io.vertx.up.commune.Envelop;\nimport io.vertx.up.util.Jackson;\n@Queue\npublic class UserWorker {\n@Mongo\nprivate transient MongoClient client;\n@Address(\"ZERO://ROLE\")\npublic void async(final Message&lt;Envelop&gt; message) {\nfinal User user = Envelop.data(message, User.class);\nfinal JsonObject userData = new JsonObject(Jackson.serialize(user));\nthis.client.save(\"DB_USER\", userData, res -&gt; {\nif (res.succeeded()) {\nmessage.reply(Envelop.success(\"Hello World\"));\n} else {\nres.cause().printStackTrace();\n}\n});\n}\n}\n</code></pre>"},{"location":"zero-mysql/","title":"How to use MySqlClient in Zero","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:c28ff7df8ed8ffdc601bb0c20ede5d4831e9f6776bceaa6af072a8574b12607e size 1118</p>"},{"location":"zero-param/","title":"@BodyParam","text":"<p><code>javax.ws.rs.@BodyParam</code> does not belong to JSR311 but extend by Zero.</p>"},{"location":"zero-param/#1-source-code","title":"1. Source Code","text":"<pre><code>package org.exmaple;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.*;\n@Path(\"/up/example\")\n@EndPoint\npublic class ZeroExpApi {\n// Other part\n@POST\n@Path(\"/body/json\")\npublic JsonObject sayBody(\n@BodyParam final JsonObject data\n) {\nreturn data;\n}\n}\n</code></pre>"},{"location":"zero-param/#2-console","title":"2. Console","text":"<pre><code>[ ZERO ] ( Uri Register ) \"/up/example/body/json\" has been deployed by ZeroHttpAgent ...\n</code></pre>"},{"location":"zero-param/#3-curl-testing","title":"3. Curl Testing","text":"<pre><code>curl -H \"Content-Type:application/json\" -X POST --data '{\"message\": \"lang Zero\"}' \\\nhttp://localhost:6083/up/example/body/json\n{\"brief\":\"OK\",\"status\":200,\"data\":{\"message\":\"lang Zero\"}}\n</code></pre>"},{"location":"zero-param/#4-hints","title":"4. Hints","text":"<ul> <li>The <code>@BodyParam</code> will be serialized with Jackson, but it's extend by zero to support more types such as<ul> <li><code>io.vertx.core.buffer.Buffer</code></li> <li><code>io.vertx.core.json.JsonObject</code></li> <li><code>io.vertx.core.json.JsonArray</code></li> </ul> </li> <li>For POJO type, it will be also serialized with Jackson</li> <li> <p>Be careful about the method return type, if we changed <code>JsonObject</code> to <code>String</code> by default configuration, the response   will be as following:</p> <pre><code>{\"brief\":\"OK\",\"status\":200,\"data\":\"{\\\"message\\\":\\\"lang Zero\\\"}\"}\n</code></pre> </li> </ul>"},{"location":"zero-path/","title":"@Path annotation","text":"<p>Zero support two mode for <code>@Path</code> annotation.</p> <ol> <li>Annotated on Class and Method both;</li> <li>Annotated on Method only;</li> </ol> <p>For the first point please refer Getting Start</p>"},{"location":"zero-path/#1-source-code","title":"1. Source Code","text":"<pre><code>package org.exmaple;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\npublic class ZeroNoPathApi {\n@GET\n@Path(\"/up/example/non-path\")\npublic String getZero(\n@QueryParam(\"name\") final String name) {\nreturn \"No Path \" + name;\n}\n}\n</code></pre>"},{"location":"zero-path/#2-console","title":"2. Console","text":"<pre><code>...\n[ ZERO ] ( 1 Event ) The endpoint org.exmaple.ZeroNoPathApi scanned 1 events of Event, ...\n...\n[ ZERO ] ( Uri Register ) \"/up/example/non-path\" has been deployed by ZeroHttpAgent, ...\n...\n</code></pre>"},{"location":"zero-path/#3-curl-testing","title":"3. Curl Testing","text":"<pre><code>curl http://localhost:6083/up/example/non-path\n{\"brief\":\"OK\",\"status\":200,\"data\":\"No Path null\"}                                                          \ncurl http://localhost:6083/up/example/non-path\\?name\\=Lang\n{\"brief\":\"OK\",\"status\":200,\"data\":\"No Path Lang\"}\n</code></pre>"},{"location":"zero-pojo/","title":"Set POJO as parameters","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:fad7354dc19040795484afb341c74094ac9968ec33c603219c5dd4af9fdbd162 size 891</p>"},{"location":"zero-pool/","title":"Pool/Packet/Zipper","text":""},{"location":"zero-pool/#1-definition","title":"1. Definition","text":"<pre><code>    public static &lt;K, V&gt; V pool(\nfinal ConcurrentMap&lt;K, V&gt; pool,\nfinal K key,\nfinal Supplier&lt;V&gt; poolFn)\npublic static &lt;V&gt; V poolThread(\nfinal ConcurrentMap&lt;String, V&gt; pool,\nfinal Supplier&lt;V&gt; poolFn)\npublic static &lt;K, V, E&gt; ConcurrentMap&lt;K, List&lt;V&gt;&gt; packet(\nfinal Collection&lt;E&gt; object,\nfinal Function&lt;E, K&gt; keyFn,\nfinal Function&lt;E, V&gt; valueFn\n)\npublic static &lt;K, V, E&gt; ConcurrentMap&lt;K, V&gt; zipper(\nfinal E[] object,\nfinal Function&lt;E, K&gt; keyFn,\nfinal Function&lt;E, V&gt; valueFn)\npublic static &lt;K, V, E&gt; ConcurrentMap&lt;K, V&gt; zipper(\nfinal Collection&lt;E&gt; object,\nfinal Function&lt;E, K&gt; keyFn,\nfinal Function&lt;E, V&gt; valueFn\n)\n</code></pre>"},{"location":"zero-pool/#2-example","title":"2. Example","text":""},{"location":"zero-pool/#21-poolpoolthread","title":"2.1. pool/poolThread","text":"<pre><code>    private static final ConcurrentMap&lt;String, JsonObject&gt; RULE_MAP =\nnew ConcurrentHashMap&lt;&gt;();\n// ......\nreturn Fn.pool(RULE_MAP, filename, () -&gt; IO.getYaml(filename));\n</code></pre> <p>Code Flow</p> <ol> <li>Input <code>filename</code> as key of <code>RULE_MAP</code>;</li> <li>Check whether this key exsiting in RULE_MAP;</li> <li>If existing, return the <code>RULE_MAP.get(key)</code> directly;</li> <li>Otherwise call the function body to create new insteance and put into <code>RULE_MAP</code>;</li> <li>Finally return valid object;</li> </ol> <p>*: poolThread only consider <code>Thread.currentThread().getName()</code> as key instead of user-defined.</p>"},{"location":"zero-pool/#22-packet","title":"2.2. packet","text":"<pre><code>    final Set&lt;Class&lt;?&gt;&gt; agents =\nclasses.stream()\n.filter((item) -&gt; item.isAnnotationPresent(Agent.class))\n.collect(Collectors.toSet());\nreturn Fn.packet(agents,\nZeroHelper::getAgentKey,\n(item) -&gt; item); // Return type: ConcurrentMap&lt;ServerType, List&lt;Class&lt;?&gt;&gt;&gt;\n</code></pre> <p>Code Flow</p> <ol> <li>The collection will be iterated and extract ( key, value ) to group the map structure;</li> <li><code>ZeroHelper::getAgentKey</code> result should be ServerType;</li> <li><code>item -&gt; item</code> result should be <code>List&lt;Class&lt;?&gt;&gt;</code> item type <code>Class&lt;?&gt;</code>, the <code>List</code> container is appent to each group    directly.</li> </ol>"},{"location":"zero-pool/#23-zipper","title":"2.3. zipper","text":"<pre><code>        final Annotation[] annotationes = clazz.getDeclaredAnnotations();\n// Zapper\nreturn Fn.zipper(annotationes,\n(item) -&gt; item.annotationType().getName(),\n(item) -&gt; item);\n// Return Type: ConcurrentMap&lt;String, Annotation&gt;\n</code></pre> <p>Code Flow</p> <p>The collection will be iterated and then extract the <code>key = value</code> based on the collection, convert the collection to map directly.</p>"},{"location":"zero-safe/","title":"Safe Function","text":"<ul> <li>Safe is be sure in any situation the code could be execute correctly.</li> </ul>"},{"location":"zero-safe/#1-definition","title":"1. Definition","text":"<pre><code>    /**\n     *  Once the actuator executing met JVM exception ( inherit from Throwable ), the logger will record the error message.\n     **/\npublic static void safeJvm(\nfinal JvmActuator actuator,\nfinal Annal logger\n)\npublic static &lt;T&gt; T safeJvm(\nfinal JvmSupplier&lt;T&gt; supplier,\nfinal Annal logger\n)\n/**\n     *  Once the actuator executing met JVM exception ( inherit from ZeroException ), the logger will record the error message.\n     **/\npublic static void safeZero(\nfinal ZeroActuator actuator,\nfinal Annal logger\n)\npublic static &lt;T&gt; T safeZero(\nfinal ZeroSupplier&lt;T&gt; supplier,\nfinal Annal logger\n)\n/** \n     * Once all the input objects are null, the Actuator function will not execute, be sure no null pointer object input into actuator.\n     **/\npublic static void safeNull(\nfinal Actuator actuator,\nfinal Object... input\n) public static &lt;T&gt; void safeNull(\nfinal Consumer&lt;T&gt; consumer,\nfinal T input\n)\n/**\n     * If condition is true, execute tSupplier, otherwise execute fSupplier.\n     */\npublic static void safeSemi(\nfinal boolean condition,\nfinal Annal logger,\nfinal Actuator tSupplier,\nfinal Actuator fSupplier\n)\n</code></pre>"},{"location":"zero-safe/#2-example","title":"2. Example","text":""},{"location":"zero-safe/#21-safejvm","title":"2.1. safeJvm","text":"<pre><code>            Fn.safeJvm(() -&gt; {\nfinal Field field = instance.getClass().getDeclaredField(name);\nif (!field.isAccessible()) {\nfield.setAccessible(true);\n}\nfield.set(instance, value);\n}, LOGGER);\n</code></pre> <p>Code Flow</p> <ol> <li>The function body will throw out exception: <code>java.lang.NoSuchFieldException</code> ( Checked Jvm Exception )</li> <li>In <code>safeJvm</code>, once the body throw out the exception, the <code>LOGGER</code> will record the exception first ( null != LOGGER )</li> <li>If there is no exception occurs, the code executed normally.</li> </ol>"},{"location":"zero-safe/#22-safezero","title":"2.2. safeZero","text":"<pre><code>        Fn.safeZero(() -&gt; {\n// Init for VertxOptions, ClusterOptions Visit Vertx\nif (VX_OPTS.isEmpty() || null == CLUSTER) {\nfinal NodeVisitor visitor =\nUt.singleton(VertxVisitor.class);\nVX_OPTS.putAll(visitor.visit());\n// Must after visit\nCLUSTER = visitor.getCluster();\n}\n// Init for HttpServerOptions\nif (SERVER_OPTS.isEmpty()) {\nfinal ServerVisitor&lt;HttpServerOptions&gt; visitor =\nUt.singleton(HttpServerVisitor.class);\nSERVER_OPTS.putAll(visitor.visit());\n}\n// Init for all plugin options.\nZeroAmbient.init();\n}, LOGGER);\n</code></pre> <p>The <code>safeZero</code> code flow is also the same as <code>safeJvm</code>, but the exception type is different, this function body exception type is <code>io.horizon.exception.ProgramException</code> ( Checked )</p>"},{"location":"zero-safe/#23-safenull","title":"2.3. safeNull","text":"<pre><code>        Fn.safeNull(() -&gt; {\nfinal Class&lt;?&gt; clazz = Instance.clazz(managerObj.toString());\nFn.safeNull(() -&gt; {\n// If null, keep default\nfinal ClusterManager manager = Instance.instance(clazz);\nobj.setManager(manager);\n}, clazz);\n}, managerObj);\n</code></pre> <p>Code Flow</p> <ol> <li>Zero system detect the input objects to check whether it's null.</li> <li>If it's not null, the function body will execute, the last argument support more than one, and you can check many    input source.</li> <li>This function is provided to avoid unexpected <code>NullPointerException</code>.</li> </ol>"},{"location":"zero-safe/#24-safesemi","title":"2.4. safeSemi","text":"<pre><code>        Fn.safeSemi(clazz.isAnnotationPresent(Path.class), LOGGER,\n() -&gt; {\n// 3.1. Append Root Path\nfinal Path path = ZeroHelper.getPath(clazz);\nassert null != path : \"Path should not be null.\";\nresult.addAll(extract(clazz, PathResolver.resolve(path)));\n},\n() -&gt; {\n// 3.2. Use method Path directly\nresult.addAll(extract(clazz, null));\n});\n</code></pre> <p>Code Flow</p> <ol> <li>Zero system check the first argument condition.</li> <li>Once it's true, the first function will execute, otherwize the second function will execute.</li> <li>The LOGGER is reserved for future use ( Now it's only provided to avoid overloading ).</li> </ol>"},{"location":"zero-starter/","title":"Getting Start","text":"<p>This article is a sample demo to describe how to use vert.x zero in your project.</p>"},{"location":"zero-starter/#1-source-code","title":"1. Source Code","text":"<pre><code>package org.exmaple;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@Path(\"/up/example\")\n@EndPoint\npublic class ZeroExpApi {\n@GET\n@Path(\"/first/{name}\")\npublic String sayZero(\n@PathParam(\"name\") final String name) {\nreturn \"Hello \" + name;\n}\n}\n</code></pre>"},{"location":"zero-starter/#2-console","title":"2. Console","text":"<p>Then you can run your api with the booter, for booter detail please refer to the home page of this project. You should see following logs in your console</p> <pre><code>...\n[ ZERO ] ( 1 Event ) The endpoint org.exmaple.ZeroExpApi scanned 1 events of Event,  ...\n...\n[ ZERO ] ( Uri Register ) \"/up/exmaple/first/:name\" has been deployed by ZeroHttpAgent, ...\n...\n</code></pre>"},{"location":"zero-starter/#3-curl-testing","title":"3. Curl Testing","text":"<pre><code>curl http://localhost:6083/up/example/first/zero\n{\"brief\":\"OK\",\"status\":200,\"data\":\"Hello zero\"}\n</code></pre>"},{"location":"zero-starter/#4-hints","title":"4. Hints","text":"<p>This is very simple demo endpoint api. Here are two comments for this example:</p> <ul> <li>All api class must be marked with <code>io.vertx.up.annotation.@EndPoint</code>, this kind of class could be scanned by Zero.</li> <li>Zero has implemented some part of JSR311, you can use some annotations that JSR311 provided such   as: <code>javax.ws.rs.@GET</code>, <code>java.ws.rs.@Path</code> etc.</li> <li>Your method must be marked with one of the method annotation: as <code>javax.ws.rs.@GET</code> above, Zero will ignore the method   that was not marked with http method annotation.</li> </ul>"},{"location":"zero-trans-shunt/","title":"Trans/Shunt Function","text":"<ul> <li>trans means there exist exception converter from Throwable to ZeroException</li> <li>shunt means there may throw out exception ( ZeroException / ZeroRunException ) only</li> </ul>"},{"location":"zero-trans-shunt/#1-definition","title":"1. Definition","text":"<pre><code>    public static &lt;T&gt; T transRun(\nfinal Supplier&lt;T&gt; supplier,\nfinal Class&lt;? extends ZeroRunException&gt; runCls,\nfinal Object... args\n)\npublic static void shuntRun(\nfinal Actuator actuator,\nfinal Annal logger\n)\npublic static void shuntZero(\nfinal ZeroActuator actuator,\nfinal Object... input\n) throws ZeroException\n</code></pre>"},{"location":"zero-trans-shunt/#2-example","title":"2. Example","text":""},{"location":"zero-trans-shunt/#21-transrun","title":"2.1. transRun","text":"<pre><code>        return Fn.transRun(() -&gt; new JsonArray(getString(filename)),\nJsonFormatException.class, filename);\n</code></pre> <p>Code Flow</p> <ol> <li>The code body executed first.</li> <li>Once the executing met the issue of <code>java.lang.Throwable</code>, it will be caught.</li> <li>Then the system will convert <code>java.lang.Throwable</code> to <code>JsonFormatException</code> exception instead of Jvm exception.</li> <li><code>JsonFormatException</code> must has a constructor that last argument is <code>Throwable</code> such as following:</li> </ol> <pre><code>public JsonFormatException(final String filename, final Throwable ex) {\nsuper(MessageFormat.format(Info.JSON_MSG, filename, ex.getCause()));\n}\n</code></pre>"},{"location":"zero-trans-shunt/#22-shuntrun","title":"2.2. shuntRun","text":"<pre><code>        Fn.shuntRun(() -&gt; {\n// Run vertx application.\nnew VertxApplication(clazz).run(args);\n}, LOGGER);\n</code></pre> <p>Code Flow</p> <ol> <li>The function body executed first.</li> <li>Once the body met exception, the system will record with <code>LOGGER</code> and catch.</li> <li>But when the body met <code>io.horizon.exception.AbstractException</code>, this kind of exception will throw out.</li> </ol>"},{"location":"zero-trans-shunt/#23-shuntzero","title":"2.3. shuntZero","text":"<p>The code flow is the same as <code>shuntRun</code>, but exception type is <code>io.horizon.exception.ProgramException</code> ( Checked ).</p>"},{"location":"zero-typed/","title":"Parameter type supported.","text":"<p>The parameters ( Not belong to specific ), must be annotated with following</p> <ul> <li>[x] <code>javax.ws.rs.QueryParam</code></li> <li>[x] <code>javax.ws.rs.FormParam</code></li> <li>[ ] <code>javax.ws.rs.MatrixParam</code></li> <li>[x] <code>javax.ws.rs.PathParam</code></li> <li>[x] <code>javax.ws.rs.HeaderParam</code></li> <li>[x] <code>javax.ws.rs.CookieParam</code></li> <li>[x] <code>jakarta.ws.rs.BodyParam</code></li> <li>[x] <code>jakarta.ws.rs.StreamParam</code></li> <li>[x] <code>jakarta.ws.rs.SessionParam</code></li> </ul> <p>The following parameter could be used by type without annotation ( Mustn't include )</p> <ul> <li><code>io.vertx.ext.web.Session</code></li> <li><code>io.vertx.core.http.HttpServerRequest</code></li> <li><code>io.vertx.core.http.HttpServerResponse</code></li> <li><code>io.vertx.core.eventbus.EventBus</code></li> <li><code>io.vertx.core.Vertx</code></li> <li><code>io.vertx.ext.auth.User</code></li> <li><code>io.vertx.ext.web.RoutingContext</code></li> </ul>"},{"location":"zero-typed/#1-source-code","title":"1. Source Code","text":"<pre><code>package org.exmaple;\nimport io.vertx.core.http.HttpServerRequest;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.*;\n@Path(\"/up/example\")\n@EndPoint\npublic class ZeroExpApi {\n// ... Other\n@GET\n@Path(\"/typed/request\")\npublic String sayBody(\nfinal HttpServerRequest request\n) {\nreturn request.absoluteURI();\n}\n}\n</code></pre>"},{"location":"zero-typed/#2-console","title":"2. Console","text":"<pre><code>[ ZERO ] ( Uri Register ) \"/up/example/typed/request\" has been deployed by ZeroHttpAgent\n</code></pre>"},{"location":"zero-typed/#3-curl-testing","title":"3. Curl Testing","text":"<pre><code>curl http://localhost:6083/up/example/typed/request\n{\"brief\":\"OK\",\"status\":200,\"data\":\"http://localhost:8083/up/example/typed/request\"}\n</code></pre>"},{"location":"zero-uniform/","title":"Advanced usage for Envelop","text":"<p>This chapter will introduce the usage for completed example in our project, it came from a app backend development based on zero system.</p> <ul> <li><code>Version &gt; 0.4.4</code></li> <li><code>Mongo Client</code></li> </ul> <p>The method to use event bus is the sample version, please refer Event Bus sample version to check more details about how to use event bus in another way instead of complex up.god.file structure.</p>"},{"location":"zero-uniform/#0-file-list","title":"0. File List","text":"<ul> <li><code>com.tlk.topic.api.TopicApi</code>\uff1a( Interface ) The interface definition for restful endpoint.</li> <li><code>com.tlk.topic.api.TopicWorker</code>\uff1aThe worker method definition to consume Envelop that came from <code>@Address</code> defined   in <code>TopicApi</code> directly.</li> <li><code>com.tlk.topic.api.TopicStub</code>\uff1a( Interface ) The service layer interface definition.</li> <li><code>com.tlk.topic.api.TopicService</code>\uff1aThe service interface implementation classes.</li> </ul> <p>Finally this service up.god.file structure should be as following, here ignored <code>Topic</code> domain class definition, it's sample POJO:</p> <p></p> <p>The request flow will be in following:</p> <pre><code>( Request ) -&gt; Api -&gt; ( Event Bus ) -&gt; Worker -&gt; Stub -&gt; Service\n</code></pre>"},{"location":"zero-uniform/#1-address-management","title":"1. Address Management","text":"<p>In this project, the address must be managed by constant up.god.file to avoid wrong user operations. It's defined in <code>com.tlk.up.god.cv.Addr</code> interface as constant values:</p> <pre><code>public interface Addr {\n// ......\nString TOPIC_HOT = \"TLK://TOPIC/HOT\";\nString TOPIC_LATEST = \"TLK://TOPIC/LATEST\";\nString TOPIC_MY = \"TLK://TOPIC/MY\";\n}\n</code></pre>"},{"location":"zero-uniform/#2-topicapi","title":"2. TopicApi","text":"<p>It's interface annotated with <code>@EndPoint</code>, the source code is as following:</p> <pre><code>package com.tlk.topic.api;\nimport com.tlk.up.god.cv.Addr;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@Path(\"/topic\")\n@EndPoint\npublic interface TopicApi {\n@GET\n@Path(\"/hot/{limit}\")\n@Address(Addr.TOPIC_HOT)\nString top(@PathParam(\"limit\") final Integer limit);\n@GET\n@Path(\"/latest/{limit}\")\n@Address(Addr.TOPIC_LATEST)\nString latest(@PathParam(\"limit\") final Integer limit);\n@GET\n@Path(\"/my/{limit}\")\n@Address(Addr.TOPIC_MY)\nString my(@PathParam(\"limit\") final Integer limit,\n@HeaderParam(\"X-User-Id\") final String userId);\n}\n</code></pre> <p>Be careful about following points:</p> <ol> <li>This class definition is java interface instead of class, it means that you could ignore the implementation.</li> <li>Hibernate validation is ignored in this mode, there is no proxy implementation class to validate parameters, in    this kind of situation you can use <code>@Codex</code> instead.</li> </ol>"},{"location":"zero-uniform/#3-topicworker","title":"3. TopicWorker","text":"<pre><code>package com.tlk.topic.api;\nimport com.tlk.up.god.cv.Addr;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.mongo.FindOptions;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport io.vertx.up.kidd.Rapider;\nimport javax.inject.Inject;\n@Queue\npublic class TopicWorker {\n@Inject\nprivate transient TopicStub stub;\n@Address(Addr.TOPIC_HOT)\npublic void hot(final Message&lt;Envelop&gt; message) {\nfinal Integer limit = Rapider.getInt(message, 0);\nstub.query(new JsonObject(), getOptions(\"subscribers\", limit), message);\n}\n@Address(Addr.TOPIC_LATEST)\npublic void latest(final Message&lt;Envelop&gt; message) {\nfinal Integer limit = Rapider.getInt(message, 0);\nstub.query(new JsonObject(), getOptions(\"createdTime\", limit), message);\n}\n@Address(Addr.TOPIC_MY)\npublic void my(final Message&lt;Envelop&gt; message) {\nfinal Integer limit = Rapider.getInt(message, 0);\nfinal String userId = Rapider.getString(message, 1);\nstub.query(new JsonObject().put(\"ownerId\", userId),\ngetOptions(\"createdTime\", limit), message);\n}\nprivate FindOptions getOptions(final String sortField,\nfinal Integer limit) {\nfinal FindOptions options = new FindOptions();\noptions.setLimit(limit);\nfinal JsonObject sort = new JsonObject().put(sortField, -1);\noptions.setSort(sort);\nreturn options;\n}\n}\n</code></pre> <p>Be careful about following code</p> <pre><code>        final Integer limit = Rapider.getInt(message, 0);\nfinal String userId = Rapider.getString(message, 1);\n</code></pre> <p>It's new api that provided by <code>io.vertx.up.kidd.Rapider</code>, kidd means <code>Kidd</code>, this name refer to a person \"Kid the Phantom Thief\", it means that in this request mode, zero system hidden the implementation just like a thief to steal the request data from agent interface to worker directly, it skipped the agent implementation, also <code>Rapider</code> hidden the details that how to convert the request data to expected params. Above code we could get path variable <code>limit</code> and header parameter <code>X-User-Id</code>.</p>"},{"location":"zero-uniform/#4-topicstub","title":"4. TopicStub","text":"<pre><code>package com.tlk.topic.api;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.mongo.FindOptions;\nimport io.vertx.up.commune.Envelop;\npublic interface TopicStub {\nvoid query(final JsonObject filter,\nfinal FindOptions options,\nfinal Message&lt;Envelop&gt; message);\n}\n</code></pre>"},{"location":"zero-uniform/#5-topicservice","title":"5. TopicService","text":"<pre><code>package com.tlk.topic.api;\nimport com.tlk.atom.Topic;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.mongo.FindOptions;\nimport io.vertx.ext.mongo.MongoClient;\nimport io.vertx.up.commune.Envelop;\nimport io.vertx.up.kidd.Heart;\nimport javax.inject.infix.Mongo;\npublic class TopicService implements TopicStub {\n@Mongo\nprivate transient MongoClient client;\n@Override\npublic void query(final JsonObject filter,\nfinal FindOptions options,\nfinal Message&lt;Envelop&gt; message) {\n// 1. Mongo Client to query by filter.\nclient.findWithOptions(Topic.TABLE, filter, options, res -&gt; {\n// 2. Build response.\nfinal Envelop envelop = Heart.getReacts(getClass())\n.connect(res).result().to();\nmessage.reply(envelop);\n});\n}\n}\n</code></pre> <p>Here provide another response building called <code>Heart</code>, it could help us to build expected result rapidly such as following:</p> <pre><code>final Envelop envelop = Heart.getReacts(getClass())\n.connect(res).result().to();\n</code></pre> <ol> <li>Once there are errors, 500 Server Internal Error will be filled into Envelop.</li> <li>The <code>_id</code> will be replaced with <code>key</code> in request/response because React will use <code>key</code> as primary key, but mongo will    use <code>_id</code> as primary key, also you can replace <code>Spy</code> with connect <code>Spy&lt;T&gt;</code> to set this code logical.</li> <li>The result() will build <code>JsonArray</code> data structure and returned the list result as expected.</li> </ol>"},{"location":"zero-uniform/#summary","title":"Summary","text":"<p>We will add more features into zero system focus on how to normalize request/response working flow, also limit the developer random operations, but you also could ignore above specifical code to implement your code logical by yourself, it's free to developers. Only one point is that be sure the uniform model used <code>Envelop</code>. Please refer reference to check Uniform Resource Model: How to use Envelop ( Uniform Resource Model ). </p>"},{"location":"zero-validate/","title":"How to validate request (JSR 303 with Hibernate-Validator)","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:5dd4971fe9525d120dca5571f9d0d02760a6062689b7870d03cfb086173726f4 size 2975</p>"},{"location":"zero-verify/","title":"Advanced Validation","text":"<p>Once the parameter are annotated with @BodyParam and typed with JsonObject, zero system also support another method to verify request data here.</p>"},{"location":"zero-verify/#1-source-code","title":"1. Source Code","text":"<pre><code>import io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Codex;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/zero/type\")\npublic class BasicTypeApi {\n@Path(\"/json\")\n@POST\npublic String testInteger(\n@BodyParam\n@Codex final JsonObject data) {\nreturn \"Number: \" + data.encode();\n}\n}\n</code></pre>"},{"location":"zero-verify/#2-configuration","title":"2. Configuration","text":"<p>In this kind of situation, you need to use <code>@Codex</code> annotation only, but you must provide the configuration up.god.file in your class path as following:</p> <pre><code>src/main/resources/codex/zero.type.json.post.yml\n</code></pre> <p>The configuration up.god.file name should be <code>path + method</code>, once you met the path variable such as <code>:name</code>, you can replace <code>:</code> with <code>_</code> instead to set the filename.</p>"},{"location":"zero-verify/#3-yml-content","title":"3. Yml content","text":"<pre><code>username:\n- type: \"required\"\nmessage: \"User name should not be null.\uff01\"\n- type: \"length\"\nmin: 6\nmax: 16\nmessage: \"User name length must be between 6 adn 16\uff01\"\npassword:\n- type: \"required\"\nmessage: \"Password should not be null\uff01\"\n- type: \"minlength\"\nmin: 8\nmessage: \"Password min length should be 8\uff01\"\n</code></pre> <ul> <li>Each field should be a node ( <code>key = JsonArray</code> ), the json array listed all the rules that will be applied to this   field.</li> <li>Each element of JsonArray must contains <code>type</code> and <code>message</code> attribute to describe the rule, other attributes are   configuration.</li> <li>For the type, please refer following chapter.</li> </ul>"},{"location":"zero-verify/#4-support-validation-type","title":"4. Support Validation Type","text":"<ul> <li>[x] <code>required</code>: No configuration</li> <li>[x] <code>length</code>\uff1aConfiguration: <code>min, max</code></li> <li>[x] <code>minlength</code>\uff1aConfiguration\uff1a<code>min</code></li> <li>[x] <code>maxlength</code>\uff1aConfiguration\uff1a<code>max</code></li> </ul> <p>Others are in future...</p>"},{"location":"zero-worker/","title":"Enable Eventbus","text":"<p>Vert.x provide event but to process async request workflow, Zero also support standard Event Bus</p>"},{"location":"zero-worker/#1-source-code","title":"1. Source Code","text":""},{"location":"zero-worker/#11-sender","title":"1.1. Sender","text":"<p>The sender will send the data processed to EventBus</p> <pre><code>package org.exmaple;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@Path(\"/up/example\")\n@EndPoint\npublic class ZeroSender {\n@Path(\"/event\")\n@POST\n@Address(\"ZERO://EVENT\")\npublic JsonObject sayEvent(\n@BodyParam final JsonObject data) {\nreturn data;\n}\n}\n</code></pre>"},{"location":"zero-worker/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package org.exmaple;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class ZeroConsumer {\n@Address(\"ZERO://EVENT\")\npublic Envelop reply(final Envelop message) {\n// JsonObject could be extract directly, not needed to pass T.class\nfinal JsonObject data = message.data();\nreturn Envelop.success(data);\n}\n}\n</code></pre>"},{"location":"zero-worker/#13-console","title":"1.3. Console","text":"<pre><code>...\nVert.x zero has found 3 incoming address from the system. Incoming address list as below: \n        Addr : ZERO://EVENT\n...\n[ ZERO ] ( Uri Register ) \"/up/example/event\" has been deployed by ZeroHttpAgent, ...\n</code></pre>"},{"location":"zero-worker/#14-curl","title":"1.4. Curl","text":"<pre><code>curl -H \"Content-Type:application/json\" -X POST --data '{\"name\":\"Lang\",\"email\":\"silentbalanceyh@126.com\"}' \\\n    http://localhost:6083/up/example/event\n{\"brief\":\"OK\",\"status\":200,\"data\":{\"name\":\"Lang\",\"email\":\"silentbalanceyh@126.com\"}}\n</code></pre>"},{"location":"zero-worker/#15-hints","title":"1.5. Hints","text":"<ul> <li>The address of Sender/Consumer must be one to one matching.</li> <li>The consumer class only support following two method signature:</li> </ul> <pre><code>// Java Style\npublic Envelop reply(final Envelop message)\n// Vert.x Style\npublic void async(final Message&lt;Envelop&gt; message)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/asking%20a%20question/","title":"Asking a question","text":""},{"location":"contributing/reporting%20a%20bug/","title":"Reporting a bug","text":""},{"location":"contributing/reporting%20a%20docs%20issue/","title":"Reporting a docs issue","text":""},{"location":"contributing/requesting%20a%20change/","title":"Requesting a change","text":""},{"location":"vertx-zero-tutorial/0-start-up/","title":"Getting Start","text":"<p>This article belong to new tutorials of Vert.x Zero Up Framework for developer, you can refer all the articles to know how to use it in your real project. At first you must know what is Vert.x Zero Up Framework ? It's a framework in service mesh environment to prevent developers to know details of micro services, but the developers could go through all the business development in this framework.</p> <p>All examples will be put in <code>vertx-zeus</code> sub projects.</p> <p>This chapter described how to start up zero.</p>"},{"location":"vertx-zero-tutorial/0-start-up/#1-standalone-zero","title":"1. Standalone Zero","text":"<p>If you used zero up only in standalone environment, you can put following simple code in your <code>main</code> entry of java.</p> <pre><code>package up.god;\nimport io.vertx.up.VertxApplication;\nimport io.vertx.up.annotations.Up;\n@Up\npublic class io.god.Anchor {\npublic static void main(final String[] args) {\nVertxApplication.run(io.god.Anchor.class);\n}\n}\n</code></pre> <p>Then you can run this program as Java Application, you'll see some logs in your console:</p> <pre><code>......\n[ ZERO ] ( Http Server ) ZeroHttpAgent Http Server has been started successfully. \\n\nEndpoint: http://172.20.16.41:6083/.\n......\n</code></pre> <p>The default http server port is 6083.</p>"},{"location":"vertx-zero-tutorial/0-start-up/#2-micro-zero","title":"2. Micro Zero","text":"<p>Except about standalone mode, zero also support another mode ( Micro ) to deploy all nodes in micro service environment, please be careful about micro environment, there need some additional configuration for zero to support micro services environment, please refer following tutorial to do the preparing works first. The demo projects are following in <code>vertx-zeus</code>,</p> <ul> <li>Api Gateway - 6100 : <code>vertx-athena</code></li> <li>Service - 6002: <code>vertx-uranus</code></li> </ul>"},{"location":"vertx-zero-tutorial/0-start-up/#21-api-gateway-configuration","title":"2.1. Api Gateway Configuration","text":"<p>In your resources folder, you should prepare following configuration files:</p> <pre><code>src/main/resources/vertx.yml\nsrc/main/resources/vertx-etcd3.yml\nsrc/main/resources/vertx-server.yml\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#vertxyml","title":"vertx.yml","text":"<p><code>vertx.yml</code>up.god.file must contains extend lime node as following:</p> <pre><code>zero:\nlime: etcd3      # This configuration is required for microservice environment\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#vertx-serveryml","title":"vertx-server.yml","text":"<p><code>vertx-server.yml</code> up.god.file must define another server type for Api Gateway</p> <pre><code>server:\n- name: gateway-athena\ntype: api        # This configuration type is different from service default.\nconfig:\nport: 6000\nhost: 0.0.0.0\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#vertx-etcd3yml","title":"vertx-etcd3.yml","text":"<p><code>vertx-etcd3.yml</code> up.god.file contains etcd3 registry center configuration information:</p> <pre><code>etcd:\nmicro: zero-istio      # Be sure the micro of api/service are both the same, then they could communicate.\nnodes:\n- host: localhost\nport: 6181\n- host: localhost\nport: 6180\n- host: localhost\nport: 6179\ntimeout: 2\n</code></pre> <p>In zero framework, the etcd3 used e3w, please refer the link to check how to preparing e3w to start etcd3 registry center. https://github.com/soyking/e3w , you can install the tool etcd3-viewer to manage etcd3 data from Web Client: https://github.com/nikfoundas/etcd-viewer. In zero, the default ports of e3w have been modified to <code>6181, 6180, 6179</code>.</p>"},{"location":"vertx-zero-tutorial/0-start-up/#22-api-gateway","title":"2.2. Api Gateway","text":"<p>Api Gateway source code is the same as standalone service as following:</p> <pre><code>package up.god;\nimport io.vertx.up.VertxApplication;\nimport io.vertx.up.annotations.Up;\n@Up\npublic class io.god.Anchor {\npublic static void main(final String[] args) {\nVertxApplication.run(io.god.Anchor.class);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#23-service-configuration","title":"2.3. Service Configuration","text":"<p>Then you can prepare following service node of zero to support micro environment and communicate with api gateway.</p> <pre><code>src/main/resources/vertx.yml\nsrc/main/resources/vertx-etcd3.yml\nsrc/main/resources/vertx-server.yml\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#vertxyml_1","title":"vertx.yml","text":"<p><code>vertx.yml</code> up.god.file is the same as api gateway, be sure instance name are the same as api gateway.</p> <pre><code>zero:\nlime: etcd3\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#vertx-serveryml_1","title":"vertx-server.yml","text":"<p><code>vertx-server.yml</code> up.god.file should be default configuration, you can set port for this micro service node.</p> <pre><code>server:\n- name: up-uranus\ntype: http\nconfig:\nport: 6002\nhost: 0.0.0.0\n</code></pre> <p>Here ignore <code>vertx-etcd3.yml</code> up.god.file content because they are the same. If you put all service node in one environment, all the service nodes configuration of etcd3 must be the same.</p>"},{"location":"vertx-zero-tutorial/0-start-up/#24-service","title":"2.4. Service","text":"<p>Service source code is the same as Standalone mode here.</p> <pre><code>package up.god;\nimport io.vertx.up.VertxApplication;\nimport io.vertx.up.annotations.Up;\n@Up\npublic class io.god.Anchor {\npublic static void main(final String[] args) {\nVertxApplication.run(io.god.Anchor.class);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#3-console-in-micro-zero","title":"3. Console in Micro Zero","text":"<p>Once you have finished micro zero configurations, you can start micro zero. Because api gateway will look up all the service nodes, it's no impact for all service node start up sequence. You can start api gateway first and then service node, or you also could start up service node first and then api gateway.</p>"},{"location":"vertx-zero-tutorial/0-start-up/#31-service-node","title":"3.1. Service Node","text":"<p>You should see following output in your console:</p> <pre><code>......\n    [ Up Micro ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Micro ] Configuration Path = /zero/zero-istio/endpoint/routes/up-uranus:172.20.16.41:6002, [ Up Micro ] Service Name = up-uranus,\n    [ Up Micro ] EndPoint = http://172.20.16.41:6002\n    [ Up Micro ] Route Uris = [ Up Micro ]     [ Up Micro ] \u221a Successfully to registered Routes, wait for discovery......SUCCESS \u221a\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/0-start-up/#32-api-gateway","title":"3.2. Api Gateway","text":"<p>You should see following logs in api gateway instead of information of standalone mode:</p> <pre><code>......\n[ ZERO ] ( Api Gateway ) ZeroApiAgent (id = ae815cba-4016-43f5-9be2-71a4ee23247c) has deployed on 6000.\n[ ZERO ] ( Api Gateway ) ZeroApiAgent has been started successfully. Endpoint: http://0.0.0.0:6000/.\n......\n</code></pre> <p>Then you should see following logs every 3 seconds</p> <pre><code>......\n[ ZERO ] ( Discovery ) Records ( added = 0, updated = 1, deleted = 0 ) have been refreshed!\n[ ZERO ] ( Discovery ) Records ( added = 0, updated = 1, deleted = 0 ) have been refreshed!\n......\n</code></pre> <p>Here are some reports of api gateway to discovery service counting.</p>"},{"location":"vertx-zero-tutorial/0-start-up/#4-summary","title":"4. Summary","text":"<p>Here are getting start for you to start zero, in total zero support two modes: Standalone &amp; Micro. The micro mode is a little complex to start up, for standalone mode, it's very simple to start up. Now once you have finish current tutorial you should know:</p> <ul> <li>How to write launcher code in standalone / micro modes</li> <li>How to configure micro mode for api gateway / service node</li> <li>How to write launcher code for api gateway</li> </ul>"},{"location":"vertx-zero-tutorial/d10002-origin-story-hi-zero/","title":"Origin Story, Hi Zero","text":"<p>You may meet many stories in software engineering, the first program called \"Hello World\", I think maybe you have been very tired to meet this old friend that called \"Hello World\", so we call the first program named \"Origin\", it means that all your stories could start from here. This tutorial will describe the first simple api development.</p>"},{"location":"vertx-zero-tutorial/d10002-origin-story-hi-zero/#1-source-code","title":"1. Source Code","text":"<p>Once your environment have been set up and you have started the first launcher, you can write your first restful endpoint. Zero restful kernel specification is JSR 311 ( JAX-RS: The Java API for RESTful Web Services ) , except JSR311 zero also extend it to create more useful annotation to satisfy business requirement.</p> <p>The demo project is in <code>vertx-zeus</code> , the project name is <code>up-rhea</code>.</p> <ul> <li>Standalone - 8083: <code>up-rhea</code></li> </ul> <pre><code>package up.god.micro.origin;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api\")\npublic class FirstHi {\n@GET\n@Path(\"hi\")\npublic String hi(@QueryParam(\"name\") final String name) {\nreturn null == name ?\n\"Hi, Input your name\" :\n\"Hi \" + name + \", welcome to Origin\";\n}\n}\n</code></pre> <p>Then restart zero, you should see following information in your console:</p> <pre><code>......\n[ ZERO ] ( 1 EndPoint ) The Zero system has found 1 components of @EndPoint.\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.origin.FirstHi scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/hi\" has been deployed by ZeroHttpAgent, Options = Route[ ....\n[ ZERO ] ( Http Server ) ZeroHttpAgent Http Server has been started successfully. \\\nEndpoint: http://172.20.16.41:6083/.\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10002-origin-story-hi-zero/#2-testing","title":"2. Testing","text":"<p>Once zero is up, you can test this endpoint with postman tool or curl, you should get following results:</p>"},{"location":"vertx-zero-tutorial/d10002-origin-story-hi-zero/#21-request-1","title":"2.1. Request 1","text":"<p>URL: http://localhost:6083/api/hi Method: GET</p> <pre><code>{\n\"data\": \"Hi, Input your name\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10002-origin-story-hi-zero/#22-request-2","title":"2.2. Request 2","text":"<p>URL: http://localhost:6083/api/hi?name=Lang Method: GET</p> <pre><code>{\n\"data\": \"Hi Lang, welcome to Origin\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10002-origin-story-hi-zero/#3-summary","title":"3. Summary","text":"<p>Now zero is up, the first example has been finished. here <code>@GET, @Path, @QueryParam</code> belong to JSR 311, you also could use other JSR 311 annotations to write different endpoint. But one thing is that you must define the class as EndPoint with zero annotation <code>io.vertx.up.annotations.EndPoint</code> , it will tell zero system to scan this class to extract all the restful endpoints that will be published. In total:</p> <ul> <li>All api classes must be annotated with <code>io.vertx.up.annotations.EndPoint</code>, this kind of classes will be scanned by   zero.</li> <li>Zero implemented some part of JSR311, you can use JSR311 annotations such as <code>javax.ws.rs.@GET</code>, <code>javax.ws.rs.@Path</code>,   etc.</li> <li>Your methods must be marked with one of the method annotations of JSR311, if you missed these annotations, zero system   will ignore the method and that will not be mounted to routing system.</li> </ul>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/","title":"JSR311, @Path Usage for EndPoint","text":"<p>This tutorial will focus on the usage of JSR311 annotation <code>javax.ws.rs.Path</code>, in zero system, it support two modes:</p> <ul> <li>Annotated on Class / Method both;</li> <li>Annotated on Method only;</li> </ul> <p>Demo project:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/#1-class-method-both","title":"1. Class / Method both","text":"<p>The first mode is using <code>javax.ws.rs.Path</code>on class and method both as following:</p> <pre><code>package up.god.micro.path;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class PathBoth {\n@Path(\"/path/both\")\n@GET\npublic String sayBoth() {\nreturn \"Hi, welcome to path both ( Class / Method )\";\n}\n}\n</code></pre> <p>This example is used in previous tutorials, it's common usage here.</p>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/#2-method-only","title":"2. Method Only","text":"<p>Another mode for <code>javax.ws.rs.Path</code> usage is as following:</p> <pre><code>package up.god.micro.path;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@EndPoint\npublic class PathMethod {\n@Path(\"/api/path/method\")\n@GET\npublic String sayBoth() {\nreturn \"Hi, welcome to path both ( Method Only )\";\n}\n}\n</code></pre> <p>Please compare above two examples, the <code>PathMethod</code> is not annotated with <code>javax.ws.rs.PATH</code> , but it's still correct to be let zero scanning. zero system will scan above two examples both.</p>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/#3-console","title":"3. Console","text":"<p>Then start your zero application, you should see following output:</p> <pre><code>......\n[ ZERO ] ( 3 EndPoint ) The Zero system has found 3 components of @EndPoint.\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.path.PathBoth scanned 1 events of Event, \\\nwill be mounted to routing system.\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.path.PathMethod scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/path/both\" has been deployed by ZeroHttpAgent, Options = Route ...\n[ ZERO ] ( Uri Register ) \"/api/path/method\" has been deployed by ZeroHttpAgent, Options = Route ...\n[ ZERO ] ( Http Server ) ZeroHttpAgent Http Server has been started successfully. \\\nEndpoint: http://172.20.16.41:6083/.\n.....\n</code></pre>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/#4-testing","title":"4. Testing","text":"<p>Once zero is up, you can test both endpoints.</p>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/#41-request-1","title":"4.1. Request 1","text":"<p>URL: http://localhost:6083/api/path/method</p> <p>Method: GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, welcome to path both ( Method Only )\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/#42-request-2","title":"4.2. Request 2","text":"<p>URL: http://localhost:6083/api/path/both</p> <p>Method: GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, welcome to path both ( Class / Method )\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10003-jsr311-path-usage/#5-summary","title":"5. Summary","text":"<p>Now zero is up, both apis have been published. From this tutorial you should know:</p> <ul> <li><code>javax.ws.rs.@Path</code> could be used on Class/Method both.</li> <li><code>javax.ws.rs.@Path</code> could be used on Method only.</li> </ul>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/","title":"JSR311, @GET, @POST...Http Method","text":"<p>This tutorial will focus on different Http Method usage based on JSR311. Here are annotations of JSR311 for Http Method.</p> <ul> <li><code>javax.ws.rs.GET</code></li> <li><code>javax.ws.rs.POST</code></li> <li><code>javax.ws.rs.DELETE</code></li> <li><code>javax.ws.rs.PUT</code></li> <li><code>javax.ws.rs.HEAD</code></li> <li><code>javax.ws.rs.OPTIONS</code></li> <li><code>javax.ws.rs.PATCH</code></li> </ul> <p>Zero system support all method mounting on routing system, the common usage of restful api contains <code>GET, DELETE, POST, PUT</code> methods.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#1-method-usage","title":"1. Method usage","text":"<p>Please refer following entire class source code for different usage of Http Method</p> <pre><code>package up.god.micro.method;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.*;\n@EndPoint\n@Path(\"/api\")\npublic class MethodUsage {\n@GET\n@Path(\"/method\")\npublic String sayGet() {\nreturn \"Hi, HttpMethod = GET\";\n}\n@POST\n@Path(\"/method\")\npublic String sayPost() {\nreturn \"Hi, HttpMethod = POST\";\n}\n@DELETE\n@Path(\"/method\")\npublic String sayDelete() {\nreturn \"Hi, HttpMethod = DELETE\";\n}\n@PUT\n@Path(\"/method\")\npublic String sayPut() {\nreturn \"Hi, HttpMethod = PUT\";\n}\n@OPTIONS\n@Path(\"/method\")\npublic String sayOptions() {\nreturn \"Hi, HttpMethod = OPTIONS\";\n}\n@PATCH\n@Path(\"/method\")\npublic String sayPatch() {\nreturn \"Hi, HttpMethod = PATCH\";\n}\n}\n</code></pre> <p>Above example contains 6 http methods usage in zero system, once you have finished, you can start up zero.</p>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#2-console","title":"2. Console","text":"<p>You should see following information in console when starting zero:</p> <pre><code>......\n[ ZERO ] ( 6 Event ) The endpoint up.god.micro.method.MethodUsage scanned 6 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/method\" has been deployed by ZeroHttpAgent, Options = Route... \\\n...methods:[PUT]]@685473710.\n[ ZERO ] ( Uri Register ) \"/api/method\" has been deployed by ZeroHttpAgent, Options = Route... \\\n...methods:[PATCH]]@1243852804.\n[ ZERO ] ( Uri Register ) \"/api/method\" has been deployed by ZeroHttpAgent, Options = Route... \\\n...methods:[OPTIONS]]@766024960.\n[ ZERO ] ( Uri Register ) \"/api/method\" has been deployed by ZeroHttpAgent, Options = Route... \\\n...methods:[POST]]@675804188.\n[ ZERO ] ( Uri Register ) \"/api/method\" has been deployed by ZeroHttpAgent, Options = Route... \\\n...methods:[DELETE]]@935640745.\n[ ZERO ] ( Uri Register ) \"/api/method\" has been deployed by ZeroHttpAgent, Options = Route... \\\n...methods:[GET]]@1098033693.\n......\n</code></pre> <p>You could see the suffix of each logging line for routing to describe the method. different method could be triggered by different Http method in request.</p>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#3-testing","title":"3. Testing","text":"<p>Once zero is up, you can test the same uri with different Http Method.</p>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#31-get-request","title":"3.1. GET Request","text":"<p>URL: http://localhost:6083/api/method</p> <p>Method: GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, HttpMethod = GET\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#32-post-request","title":"3.2. POST Request","text":"<p>URL: http://localhost:6083/api/method</p> <p>Method: POST</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, HttpMethod = POST\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#33-put-request","title":"3.3. PUT Request","text":"<p>URL: http://localhost:6083/api/method</p> <p>Method: PUT</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, HttpMethod = PUT\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#34-delete-request","title":"3.4. DELETE Request","text":"<p>URL: http://localhost:6083/api/method</p> <p>Method: DELETE</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, HttpMethod = DELETE\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#35-options-request","title":"3.5. OPTIONS Request","text":"<p>URL: http://localhost:6083/api/method</p> <p>Method: OPTIONS</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, HttpMethod = OPTIONS\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#36-patch-request","title":"3.6. PATCH Request","text":"<p>URL: http://localhost:6083/api/method</p> <p>Method: PATCH</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, HttpMethod = PATCH\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10004-httpmethod-usage/#4-summary","title":"4. Summary","text":"<p>Current tutorial described different http method usage in zero system based on JSR311, JSR311 only support 7 annotations for <code>GET, POST, DELETE, OPTIONS, PATCH, PUT, HEAD</code>. They are all supported by zero system.</p> <ul> <li>The common usage are <code>GET, DELETE, PUT, POST</code></li> <li>In some cross domain business requirement, the <code>OPTIONS</code> method will be used, you can ignore the user   defined <code>OPTIONS</code> instead of write the method code logical.</li> <li>We recommend to use <code>PATCH</code> method to update some parts of information instead of <code>PUT</code> method because zero now   support <code>PATCH</code> method.</li> </ul>"},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/","title":"@QueryParam...Parameters","text":"<p>This tutorial focus on query string parameter usage in zero system, here zero system support two types of query string parameters.</p> <ul> <li>Encoded</li> <li>Plain Text</li> </ul> <p>Also zero system will process encoded parameters automatically and you could pass above two format of parameters.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/#1-source-code","title":"1. Source Code","text":"<p>Here are example for <code>@QueryParam</code> annotation in zero system:</p> <pre><code>package up.god.micro.params;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api\")\npublic class QueryParamExecutor {\n@Path(\"param/query\")\n@GET\npublic String sayQuery(\n@QueryParam(\"name\") final String name) {\nreturn \"Hello: Get \" + name;\n}\n@Path(\"param/query\")\n@POST\npublic String sayPostQuery(\n@QueryParam(\"name\") final String name) {\nreturn \"Hello: Post \" + name;\n}\n@Path(\"param/query-encode\")\n@GET\npublic String sayEncodeQuery(\n@QueryParam(\"name\") final String name) {\nreturn \"Hello: Encoded \" + name;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/#2-console","title":"2. Console","text":"<p>Then you should see the logs in console as following:</p> <pre><code>......\n[ ZERO ] ( 3 Event ) The endpoint up.god.micro.params.QueryParamExecutor scanned 3 events of Event,\\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/query\" has been deployed by ZeroHttpAgent, Options = Route[...\n[ ZERO ] ( Uri Register ) \"/api/param/query\" has been deployed by ZeroHttpAgent, Options = Route[...\n[ ZERO ] ( Uri Register ) \"/api/param/query-encode\" has been deployed by ZeroHttpAgent, Options = Route[...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/#31-get-request","title":"3.1. Get Request","text":"<p>URI: http://localhost:6083/api/param/query?name=Lang Yu</p> <p>Method: GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello: Get Lang Yu\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/#32-post-request","title":"3.2. Post Request","text":"<p>URI: http://localhost:6083/api/param/query?name=Lang Yu</p> <p>Method: POST</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello: Post Lang Yu\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/#33-get-request-encoded","title":"3.3. Get Request ( Encoded )","text":"<p> URI: http://localhost:6083/api/param/query-encode?name=Lang Yu</p> <p>Method: GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello: Encoded Lang Yu\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-queryparam-usage/#4-summary","title":"4. Summary","text":"<p>Zero system support both Plain Text &amp; Encoded parameters in query string, you could annotated the parameters with JSR311 annotations directly and then in your application you can use these parameters directly.</p>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/","title":"Vert.x Native, SharedData","text":"<p>Actually, shared client is not native client, but we wrapper a concept in vert.x named SharedData , this client used this concept provide following features.</p> <ul> <li>Temporary storage of Map to store the data such as verification code etc.</li> <li>Temporary storage of Map to store the data that will be used once.</li> </ul>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#1-configuration","title":"1. Configuration","text":"<p>This chapter is duplicated with D10106 - Configuration, vertx-tp.yml, it's pre-condition to use SharedClient.</p>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#11-vertxyml","title":"1.1. vertx.yml","text":"<p>In major configuration up.god.file, you must extend to <code>vertx-tp.yml</code> up.god.file to enable this configuration.</p> <pre><code>zero:\nlime: mongo,readible,secure,tp\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#12-vertx-tpyml","title":"1.2. vertx-tp.yml","text":"<p>This up.god.file must contain shared data information, actually there is only one configuration node named <code>shared</code>\uff0cif you want to enable this feature you can set as following:</p> <pre><code>shared:\nconfig:\nasync: true\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#13-vertx-injectxml","title":"1.3. vertx-inject.xml","text":"<p>The last configuration for shared data usage is that you must set <code>inject</code> in your configuration:</p> <pre><code>shared: io.vertx.tp.plugin.shared.MapInfix\n</code></pre> <p>Once you have finished above three configuration, the shared data will be enabled.</p>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#2-source-code","title":"2. Source Code","text":"<pre><code>package up.god.micro;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport io.vertx.up.annotations.Plugin;\nimport io.vertx.tp.plugin.shared.SharedClient;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class SharedActor {\n@Plugin\nprivate transient SharedClient&lt;String, String&gt; sharedClient;\n@Path(\"/shared\")\n@GET\npublic JsonObject sayShared() {\nSystem.out.println(this.sharedClient);\nreturn new JsonObject();\n}\n}\n</code></pre> <p>When you test this url, you should see following information in output console:</p> <pre><code>io.vertx.tp.plugin.shared.SharedClientImpl@245fc212\n</code></pre> <p>It means that you have got reference of <code>SharedClient</code>, then we'll move to some apis of SharedClient to see how to use this client in different situations.</p>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#3-usage","title":"3. Usage","text":""},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#31-definition-of-shareclient","title":"3.1. Definition of ShareClient","text":"<p>Here shared client contains following definition:</p> <pre><code>public interface SharedClient&lt;K, V&gt; { ... }\n</code></pre> <p>Here are two generic types: <code>K, V</code>, these two types described key type and value type, that's why we could see following reference definition:</p> <pre><code>private transient SharedClient&lt;String,String&gt; ...\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#32-get-reference","title":"3.2. Get reference","text":"<p>Here are two important api to get reference of <code>AsyncMap/LocalMap</code> of vert.x as following:</p> <pre><code>    /**\n     * Get reference of AsyncMap\n     */\nAsyncMap&lt;K, V&gt; fetchAsync();\n/**\n     * Get reference of LocalMap\n     */\nLocalMap&lt;K, V&gt; fetchSync();\n</code></pre> <p>It means that some vert.x native developers want to use <code>AsyncMap/LocalMap</code> directly, in this situation you can call above two APIs to get reference.</p> <p>But you must be careful about the configuration <code>config -&gt; async</code>, in zero system you must use correct mode of SharedData that reflect to <code>async</code> , in other words, async = true, you can use AsyncMap, async = false, you can use LocalMap.</p>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#33-switch-pool","title":"3.3. Switch Pool","text":"<p>In zero system, except the default shared pool, you also could switch to create new pool by following API:</p> <pre><code>    SharedClient&lt;K, V&gt; switchClient(final String name);\n</code></pre> <p>The new created <code>SharedClient</code> generic type <code>K, V</code> must be the same as original. The concept is as following:</p> <p></p> <p>You can use SharedClient create any new SharedClient, all the APIs belong to the client must impact each one in the same Data Pool. If you did not create any new SharedClient, the client must refer the default.</p> <pre><code>private static final String NAME = \"ZERO_MAP_POOL\";\n</code></pre>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#34-common-apis","title":"3.4. Common APIs","text":"<p>The last APIs of SharedClient are as following:</p> <pre><code>    KeyPair&lt;K, V&gt; put(K key, V value);\nKeyPair&lt;K, V&gt; remove(K key);\nV get(K key);\n@Fluent\nSharedClient&lt;K, V&gt; put(K key, V value, Handler&lt;AsyncResult&lt;KeyPair&lt;K, V&gt;&gt;&gt; handler);\n@Fluent\nSharedClient&lt;K, V&gt; remove(K key, Handler&lt;AsyncResult&lt;KeyPair&lt;K, V&gt;&gt;&gt; handler);\n@Fluent\nSharedClient&lt;K, V&gt; get(K key, Handler&lt;AsyncResult&lt;V&gt;&gt; handler);\n</code></pre> <p>Above six APIs described common operations such as <code>put, remove, get</code> by different mode ( <code>async/sync</code> ), these APIs is common used in HashMap and zero provide to developer to do some temp storage.</p>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#35-onceexpired","title":"3.5. Once/Expired","text":"<p>Except common data pool, zero support two special map:</p> <pre><code>    KeyPair&lt;K, V&gt; put(K key, V value, int expiredSecs);\n@Fluent\nSharedClient&lt;K, V&gt; put(K key, V value, int expiredSecs, Handler&lt;AsyncResult&lt;KeyPair&lt;K, V&gt;&gt;&gt; handler);\n</code></pre> <p>Here are additional <code>int expiredSecs</code>, it means that the <code>key = value</code> will be expired in <code>expiredSecs</code> seconds, it could be used to store some verification code ( by mobile ) or other data that should be expired duration limit seconds.</p> <pre><code>    V get(K key, boolean once);\n@Fluent\nSharedClient&lt;K, V&gt; get(K key, boolean once, Handler&lt;AsyncResult&lt;V&gt;&gt; handler);\n</code></pre> <p>Another map is that when you get data from data pool, you can provide the parameter <code>once</code>, if it's false, the usage is the same as common API, if it's true, after you get the data from data pool, the <code>key = value</code> will be removed and it's once consume for developers.</p>"},{"location":"vertx-zero-tutorial/d10005-vertx-native-shareddata/#4-summary","title":"4. Summary","text":"<p>This tutorial described the SharedData feature that zero system provided, it could be used in many business situations such as</p> <ul> <li>Mobile verification code by sms ( The code must be expired in 30 seconds );</li> <li>Authorization Code to exchange token ( The code must be used once );</li> </ul> <p>Then you can consider to use the data map in your projects.</p>"},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/","title":"JSR311, @PathParam...Parameters","text":"<p>Path variables are common used in Restful endpoint, zero system also support path variable with annotation <code>javax.ws.rs.PathParam</code>, you can define path parameters in your code.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.params;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.*;\n@EndPoint\n@Path(\"/api\")\npublic class PathParamExecutor {\n@Path(\"param/path1/{name}\")\n@GET\npublic String sayPath(\n@PathParam(\"name\") final String name\n) {\nreturn \"Hello: Path Get: \" + name;\n}\n@Path(\"param/path1/{name}\")\n@POST\npublic String sayPath2(\n@PathParam(\"name\") final String name\n) {\nreturn \"Hello: Path Post: \" + name;\n}\n@Path(\"param/path1/{name}\")\n@PUT\npublic String sayPath3(\n@PathParam(\"name\") final String name\n) {\nreturn \"Hello: Path Put: \" + name;\n}\n}\n</code></pre> <p>In zero system, all http methods include POST/PUT also support path variables to extract and put in using in future.</p>"},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/#2-console","title":"2. Console","text":"<p>Then you should see the logs in console as following:</p> <pre><code>......\n[ ZERO ] ( 3 Event ) The endpoint up.god.micro.params.PathParamExecutor scanned 3 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/path1/:name\" has been deployed by ZeroHttpAgent, Options = Route...\n    order:5000000 methods:[POST]]@738775182.\n[ ZERO ] ( Uri Register ) \"/api/param/path1/:name\" has been deployed by ZeroHttpAgent, Options = Route...\n    order:5000000 methods:[PUT]]@286864174.\n[ ZERO ] ( Uri Register ) \"/api/param/path1/:name\" has been deployed by ZeroHttpAgent, Options = Route...\n    order:5000000 methods:[GET]]@775245096.\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/#31-get-request","title":"3.1. Get Request","text":"<p>URL : http://localhost:6083/api/param/path1/lang.yu@hpe.com</p> <p>Method : GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello: Path Get: lang.yu@hpe.com\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/#32-post-request","title":"3.2. Post Request","text":"<p>URL : http://localhost:6083/api/param/path1/lang.yu@hpe.com</p> <p>Method : POST</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello: Path Post: lang.yu@hpe.com\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/#33-put-request","title":"3.3. Put Request","text":"<p>URL : http://localhost:6083/api/param/path1/lang.yu@hpe.com</p> <p>Method : PUT</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello: Path Put: lang.yu@hpe.com\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10006-jsr311-pathparamparameters/#4-summary","title":"4. Summary","text":"<p>You can use JSR311 annotations to setup your request path variables, but there are one rule that need to know:</p> <p>Path variables often let you set duplicated uri, such as <code>/api/{name}</code> and <code>/api/{age}</code>, do not set previous two uri with the same Http methods because zero system will consider these two are the same and will ignore one here.</p> <ul> <li>GET: <code>/api/{name}</code></li> <li>GET: <code>/api/{age}</code></li> </ul> <p>Above two examples are wrong for path variables.</p>"},{"location":"vertx-zero-tutorial/d10007-jsr311-formparamparameters/","title":"JSR311, @FormParam...Parameters","text":"<p>When you submit a form request with HTML, you often require the server could accept form parameters.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10007-jsr311-formparamparameters/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.params;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class FormParamExecutor {\n@Path(\"param/form\")\n@GET\npublic String sayFormGet(\n@FormParam(\"username\") final String username,\n@FormParam(\"password\") final String password) {\nreturn \"Hello: GET: \" + username + \", your password is: \" + password;\n}\n@Path(\"param/form\")\n@POST\npublic String sayFormPost(\n@FormParam(\"username\") final String username,\n@FormParam(\"password\") final String password) {\nreturn \"Hello: Post: \" + username + \", your password is: \" + password;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10007-jsr311-formparamparameters/#2-console","title":"2. Console","text":"<p>Then you should see the logs in console as following:</p> <pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.params.FormParamExecutor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/form\" has been deployed by ZeroHttpAgent, Options = Route... \\\norder:5000000 methods:[POST]]@1781967506.\n[ ZERO ] ( Uri Register ) \"/api/param/form\" has been deployed by ZeroHttpAgent, Options = Route... \\\norder:5000000 methods:[GET]]@570377242.\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10007-jsr311-formparamparameters/#3-testing","title":"3. Testing","text":"<p>Be sure you will send form request instead of restful request here.</p>"},{"location":"vertx-zero-tutorial/d10007-jsr311-formparamparameters/#31-get-request","title":"3.1. Get Request","text":"<p>You should write some static HTML form to submit Form Get Request instead of some tools because most of testing tools do not support send Form Get Request</p>"},{"location":"vertx-zero-tutorial/d10007-jsr311-formparamparameters/#32-post-request","title":"3.2. Post Request","text":"<p>URI: http://localhost:6083/api/param/form</p> <p>Method: POST</p> <p>Here we provide form request screen shot with Postman tool</p> <p>You should get response as following.</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello: Post: Lang, your password is: 11111111\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10007-jsr311-formparamparameters/#4-summary","title":"4. Summary","text":"<p>From above screen shot you'll see <code>form-data</code> and <code>x-www-form-urlencoded</code> both, for zero system it's the same because zero system will decode the data automatically, don't wrong about form request type when you are using zero system.</p>"},{"location":"vertx-zero-tutorial/d10008-jsr311-headerparamparameters/","title":"@HeaderParam...Parameters","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:c96847200ec03e1aa8fcd7ed48430ddb889985f72111a3fc560b34ba05653af8 size 1635</p>"},{"location":"vertx-zero-tutorial/d10009-jsr311-cookieparamparameters/","title":"JSR311, @CookieParam...Parameters","text":"<p>This example is a little complex to test, here we need to see the cookie value in your client tool first.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10009-jsr311-cookieparamparameters/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.params;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.CookieParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class CookieParamExecutor {\n@Path(\"param/cookie\")\n@GET\npublic String sayCookie(\n@CookieParam(\"cookie-id\") final String cookie\n) {\nreturn \"Hello, Cookie: \" + cookie;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10009-jsr311-cookieparamparameters/#2-console","title":"2. Console","text":"<p>Then you should see the logs in console as following:</p> <pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.params.CookieParamExecutor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/cookie\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10009-jsr311-cookieparamparameters/#3-testing","title":"3. Testing","text":"<p>URI: http://localhost:6083/api/param/cookie</p> <p>Method: GET</p> <p>Cookie: cookie-id=lang.yu-zero; path=/; domain=localhost; Expires=Tue, 19 Jan 2038 03:14:07 GMT;</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello, Cookie: lang.yu-zero\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10009-jsr311-cookieparamparameters/#4-summary","title":"4. Summary","text":"<p>Here you can get cookie data from http request, please be sure you have set the cookies in your request. For postman tools, you can set here:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10010-zero-jsr311-bodyparamparameters/","title":"Zero JSR311, @BodyParam...Parameters","text":"<p>Because body request often used in restful web service application, zero system extend JSR311 and defined new annotations for common usage.</p> <ul> <li><code>jakarta.ws.rs.BodyParam</code></li> <li><code>jakarta.ws.rs.SessionParam</code></li> <li><code>jakarta.ws.rs.StreamParam</code></li> </ul> <p>Above three annotations are defined by zero system, because it's useful in different requirements, current tutorial will describe the usage of @BodyParam. There are some simple rules for @BodyParam:</p> <ul> <li>There is no field name for @BodyParam, you must use it directly.</li> <li>The @BodyParam will bind to special java types, not all will be supported.</li> </ul> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10010-zero-jsr311-bodyparamparameters/#1-source-code","title":"1. Source Code","text":"<p>This example describe send the data to zero and serialized in two vertx types:</p> <ul> <li><code>io.vertx.core.json.JsonArray</code></li> <li><code>io.vertx.core.json.JsonObject</code></li> </ul> <p>Code:</p> <pre><code>package up.god.micro.params;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class BodyParamExecutor {\n@POST\n@Path(\"/param/body/json\")\npublic JsonObject sayJson(\n@BodyParam final JsonObject json\n) {\nreturn json;\n}\n@POST\n@Path(\"/param/body/jarray\")\npublic JsonArray sayJArray(\n@BodyParam final JsonArray jarray\n) {\nreturn jarray;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10010-zero-jsr311-bodyparamparameters/#2-console","title":"2. Console","text":"<p>Then you should see the logs in console as following:</p> <pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.params.BodyParamExecutor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/body/jarray\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/param/body/json\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10010-zero-jsr311-bodyparamparameters/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10010-zero-jsr311-bodyparamparameters/#31-jsonobject","title":"3.1. JsonObject","text":"<p>URI: http://localhost:6083/api/param/body/json</p> <p>Method: POST</p> <p>Request:</p> <pre><code>{\n\"username\":\"Lang.Yu\",\n\"mobile\":\"15922X114XX\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n\"data\": {\n\"username\": \"Lang.Yu\",\n\"mobile\": \"15922X114XX\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10010-zero-jsr311-bodyparamparameters/#32-jsonarray","title":"3.2. JsonArray","text":"<p>URI: http://localhost:6083/api/param/body/jarray</p> <p>Method: POST</p> <p>Request:</p> <pre><code>[\n{\n\"username\":\"Lang.Yu\",\n\"mobile\":\"15922X114XX\"\n}\n]\n</code></pre> <p>Response:</p> <pre><code>{\n\"data\": [\n{\n\"username\": \"Lang.Yu\",\n\"mobile\": \"15922X114XX\"\n}\n]\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10010-zero-jsr311-bodyparamparameters/#4-summary","title":"4. Summary","text":"<p>Above examples showed that how to read request body in zero system, if your request format is invalid, you'll get error from zero system.</p> <p>For example you provided following json format:</p> <pre><code>{\n\"username\":\"Lang.Yu\",\n\"mobile\":\"15922X114XX\",\n}\n</code></pre> <p>Above json format is invalid and it could not be converted into JsonObject, you'll get following error ( 400 Bad Request ):</p> <pre><code>{\n\"code\": -60004,\n\"message\": \"[ERR-60004] (JsonObjectSaber) Web Exception occus: (400) - Zero system detect ...\"\n}\n</code></pre> <p>Do remember that you should provide correct data format to zero system or zero system will reject your request with above standard errors.</p>"},{"location":"vertx-zero-tutorial/d10011-zero-jsr311-bodyparampojo/","title":"Zero JSR311, @BodyParam...Pojo","text":"<p>In many projects, you'll defined your own Data Object with Java Class, it means that you have your own type instead of <code>JsonObject</code> and <code>JsonArray</code>, in this situation zero also provide json serialization for different java type, especially for some user-defined POJO class.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10011-zero-jsr311-bodyparampojo/#1-source-code","title":"1. Source Code","text":"<p>Create your pojo class: <code>JsonUser</code> with lombok tool ( We recommend to use because the code could be simple ):</p> <pre><code>package up.god.micro.params;\nimport lombok.Data;\n@Data\npublic class JsonUser {\nprivate String username;\nprivate String email;\nprivate Integer age;\n}\n</code></pre> <p>Then you can create your own endpoint for <code>JsonUser</code></p> <pre><code>package up.god.micro.params;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n@EndPoint\n@Path(\"/api\")\npublic class PojoExecutor {\n@POST\n@Path(\"param/pojo\")\npublic JsonUser sayUser(\n@BodyParam final JsonUser user\n) {\nreturn user;\n}\n@POST\n@Path(\"param/pojos\")\npublic List&lt;JsonUser&gt; sayUsers(\n@BodyParam final Set&lt;JsonUser&gt; users\n) {\nreturn new ArrayList&lt;&gt;(users);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10011-zero-jsr311-bodyparampojo/#2-console","title":"2. Console","text":"<p>Then you should see the logs in console as following:</p> <pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.params.PojoExecutor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/pojo\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/param/pojos\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10011-zero-jsr311-bodyparampojo/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10011-zero-jsr311-bodyparampojo/#31-object-request","title":"3.1. Object Request","text":"<p>URL : http://localhost:6083/api/param/pojo</p> <p>Method: POST</p> <p>Request:</p> <pre><code>{\n\"username\":\"Lang\",\n\"age\":33\n}\n</code></pre> <p>Response:</p> <pre><code>{\n\"data\": {\n\"username\": \"Lang\",\n\"age\": 33\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10011-zero-jsr311-bodyparampojo/#32-collection-request","title":"3.2. Collection Request","text":"<p>URL: http://localhost:6083/api/param/pojos</p> <p>Method: POST</p> <p>Request:</p> <pre><code>[\n{\n\"username\":\"Lang\",\n\"age\":33\n},\n{\n\"username\":\"Xi\",\n\"email\":\"lang.xi@hpe.com\"\n}\n]\n</code></pre> <p>Response:</p> <pre><code>{\n\"data\": [\n{\n\"username\": \"Xi\",\n\"email\": \"lang.xi@hpe.com\"\n},\n{\n\"username\": \"Lang\",\n\"age\": 33\n}\n]\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10011-zero-jsr311-bodyparampojo/#4-summary","title":"4. Summary","text":"<p>In zero system, it support json serialization from literal to correct type for Pojo and Pojo collection, you can put your java class after @BodyParam annotation and zero system will convert it automatically for the parameters of endpoint method.</p>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/","title":"Zero JSR311, @StreamParam...Parameters","text":"<p>Zero system provide simple parameter annotation for up.god.file uploading, this kind of parameters must be annotated with <code>jakarta.ws.rs.StreamParam</code> here, it should support following type conversion automatically.</p> <ul> <li><code>byte[]</code></li> <li><code>io.vertx.core.buffer.Buffer</code></li> <li><code>java.io.File</code></li> <li><code>io.vertx.ext.web.FileUpload</code></li> </ul> <p>For common types, zero system will convert it automatically such as String to byte[] or byte[] to String.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.params;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport jakarta.ws.rs.StreamParam;\nimport java.nio.charset.Charset;\n@EndPoint\n@Path(\"/api\")\npublic class StreamParamExecutor {\n@Path(\"param/bytes\")\n@POST\npublic String sayBytes(@StreamParam final byte[] bytes) {\nSystem.out.println(bytes.length);\nreturn new String(bytes, Charset.defaultCharset());\n}\n@Path(\"param/buffer\")\n@POST\npublic String sayBuffer(@StreamParam final Buffer buffer) {\nSystem.out.println(buffer.toString());\nreturn buffer.toString();\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.params.StreamParamExecutor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/buffer\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/param/bytes\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#31-string-request","title":"3.1. String Request","text":"<p>URL: http://localhost:6083/api/param/bytes</p> <p>Method: POST</p> <p>Request:</p> <pre><code>[{\"username\":\"Lang\",\"age\":33}]\n</code></pre> <p>Response:</p> <pre><code>{\n\"data\": \"[{\\\"username\\\":\\\"Lang\\\",\\\"age\\\":33}]\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#32-file-uploading","title":"3.2. File Uploading","text":"<p>URL: http://localhost:6083/api/param/bytes</p> <p>Method: POST</p> <p>Request:</p> <p></p> <p>Response:</p> <pre><code>{\n\"data\": \"\\ufffdPNG\\r\\n\\u001a\\n\\u0000\\u0000\\u0000\\rIHDR.... ( Around 41500 bytes )\"\n}\n</code></pre> <p>This up.god.file is a picture with 41500 bytes, the response body reflect the whole image content here.</p>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#33-string-request-for-buffer","title":"3.3. String Request ( for Buffer )","text":"<p>URL: http://localhost:6083/api/param/buffer</p> <p>Method: POST</p> <p>Request:</p> <pre><code> [{\"username\":\"Lang\",\"age\":33}]\n</code></pre> <p>Response:</p> <pre><code>{\n\"data\": \"[{\\\"username\\\":\\\"Lang\\\",\\\"age\\\":33}]\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#34-file-uploading-for-buffer","title":"3.4. File Uploading ( for Buffer )","text":"<p>This example is the same result as 3.2 File Uploading, here ignore the testing result because the response are all the same. We only modified accept parameter types in @StreamParam.</p>"},{"location":"vertx-zero-tutorial/d10012-zero-jsr311-streamparamparameters/#4-summary","title":"4. Summary","text":"<p>This tutorial describe how to accept String/File to byte[] and Buffer, these data are all stored into your parameters. Then we'll introduce some advanced usage of @StreamParam.</p>"},{"location":"vertx-zero-tutorial/d10013-zero-jsr311-streamparamfilefileupload/","title":"Zero JSR311, @StreamParam...File/FileUpload","text":"<p>The data of byte[] or Buffer are the raw data of request, it could be used widely, but based on many requirements these two data types could not be managed easily, for developers following data types are more useful:</p> <ul> <li><code>java.io.File</code></li> <li><code>io.vertx.ext.web.FileUpload</code></li> </ul> <p>Above two objects could be used directly in your code.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10013-zero-jsr311-streamparamfilefileupload/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.params;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.web.FileUpload;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport jakarta.ws.rs.StreamParam;\nimport java.io.File;\n@EndPoint\n@Path(\"/api\")\npublic class FileParamExecutor {\n@Path(\"param/up.god.file\")\n@POST\npublic String sayFile(\n@StreamParam final File up.god.file) {\nreturn \"Hello, File = \" + up.god.file.getAbsolutePath();\n}\n@Path(\"param/fileupload\")\n@POST\npublic JsonObject sayFileUpload(\n@StreamParam final FileUpload fileUpload) {\nreturn new JsonObject()\n.put(\"filename\", fileUpload.fileName())\n.put(\"charset\", fileUpload.charSet())\n.put(\"content-type\", fileUpload.contentType())\n.put(\"size\", fileUpload.size())\n.put(\"name\", fileUpload.name());\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10013-zero-jsr311-streamparamfilefileupload/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.params.FileParamExecutor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/up.god.file\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/param/fileupload\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10013-zero-jsr311-streamparamfilefileupload/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10013-zero-jsr311-streamparamfilefileupload/#31-file-request","title":"3.1. File Request","text":"<p>URL: http://localhost:6083/api/param/up.god.file</p> <p>Method: POST</p> <p>Request:</p> <p></p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello, File = /xxxx/vertx-zero/up.god.file-uploads/a006c664-4bc9-4857-9a7c-fa110b3a25cf\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10013-zero-jsr311-streamparamfilefileupload/#32-file-request-fileupload-object","title":"3.2. File Request ( FileUpload object )","text":"<p>URL: http://localhost:6063/api/param/fileupload</p> <p>Method: POST</p> <p>Request:</p> <pre><code>{\n\"data\": {\n\"filename\": \"Screen Shot 2018-01-22 at 4.45.17 PM.png\",\n\"charset\": \"UTF-8\",\n\"content-type\": \"image/png\",\n\"size\": 175744,\n\"name\": \"\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10013-zero-jsr311-streamparamfilefileupload/#4-summary","title":"4. Summary","text":"<p>This tutorial described the common useful java object of <code>File/FileUpload</code> to provide easy way for developers to process up.god.file uploading or up.god.file processing in zero, zero extend @StreamParam parameters to process this kind of situation and you could do the tasks based on above two java objects.</p>"},{"location":"vertx-zero-tutorial/d10014-zero-jsr311-sessionparamparameters/","title":"Zero JSR311, @SessionParam...Parameters","text":"<p>In zero system, the session variables management is different from other variables because this variable is not provided by Http Request directly. Instead the user will send some request and stored the data into session first, and then when they send the request with the same session ( vertx-web.session is the same ), you could use the session variable in your application/code logical.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10014-zero-jsr311-sessionparamparameters/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.params;\nimport io.vertx.up.annotations.EndPoint;\nimport io.vertx.up.annotations.SessionData;\nimport javax.ws.rs.*;\n@EndPoint\n@Path(\"/api\")\npublic class SessionParamExecutor {\n@POST\n@Path(\"param/session/{id}\")\n@SessionData(\"user\")\npublic String saveSession(\n@PathParam(\"id\") final String id) {\nSystem.out.println(id);\nreturn id;\n}\n@GET\n@Path(\"param/session\")\npublic String saySession(\n@SessionParam(\"user\") final String user\n) {\nSystem.out.println(user);\nreturn user;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10014-zero-jsr311-sessionparamparameters/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.params.SessionParamExecutor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/session\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/param/session/:id\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10014-zero-jsr311-sessionparamparameters/#3-testing","title":"3. Testing","text":"<p>Current tutorial testing is different from previous because here we need two test cases.</p>"},{"location":"vertx-zero-tutorial/d10014-zero-jsr311-sessionparamparameters/#31-session-missing","title":"3.1. Session Missing","text":"<p>URL : http://localhost:6083/api/param/session</p> <p>Method: GET</p> <p>Response :</p> <pre><code>{\n\"data\": null\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10014-zero-jsr311-sessionparamparameters/#32-session-two-steps","title":"3.2. Session Two Steps","text":"<p>In this test case, we need two steps to process the situation.</p> <p>1 - First</p> <p>URL : http://localhost:6083/api/param/session/lang.yu-vertx</p> <p>Method: POST</p> <p>Response :</p> <pre><code>{\n\"data\": \"lang.yu-vertx\"\n}\n</code></pre> <p>2 - Second</p> <p>Repeat the step of 3.1, you'll found different response from zero, it's different from test case of 3.1.</p> <pre><code>{\n\"data\": \"lang.yu-vertx\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10014-zero-jsr311-sessionparamparameters/#4-summary","title":"4. Summary","text":"<p>This tutorial describes the session usage in zero system, with JSR311 zero system defined new annotation to process session variable in zero system. Here are additional annotation such as:</p> <ul> <li><code>io.vertx.up.annotations.SessionData</code></li> </ul> <p>This annotation provide session key as attribute to store session data, it will capture the method return value and stored into session, then we could use @SessionParam annotation to pick up the value that you stored in previous request.</p>"},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/","title":"By Typed Parameters","text":"<p>Except all JSR311 related annotations ( Include extend by Zero such as @BodyParam, @StreamParam etc ), zero also support some default typed parameters, these kind of parameters do not require any annotations in your code, but with Java Type instead directly. Zero will scan the method and pick up the parameters by type instead of annotation. All support types are as following:</p> <ul> <li>[x] <code>io.vertx.core.Vertx</code></li> <li>[x] <code>io.vertx.core.buffer.Buffer</code></li> <li>[x] <code>io.vertx.core.eventbus.EventBus</code></li> <li>[x] <code>io.vertx.core.http.HttpServerRequest</code></li> <li>[x] <code>io.vertx.core.http.HttpServerResponse</code></li> <li>[x] <code>io.vertx.core.json.JsonArray</code></li> <li>[x] <code>io.vertx.core.json.JsonObject</code></li> <li>[x] <code>io.vertx.ext.auth.User</code></li> <li>[x] <code>io.vertx.ext.web.FileUpload</code></li> <li>[x] <code>io.vertx.ext.web.RoutingContext</code></li> <li>[x] <code>io.vertx.ext.web.Session</code></li> </ul> <p>All above list types are default supported by zero.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.params;\nimport io.vertx.core.http.HttpServerRequest;\nimport io.vertx.core.http.HttpServerResponse;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class TypedExecutor {\n@POST\n@Path(\"param/typed/json\")\npublic JsonObject sendJson(\nfinal JsonObject json) {\nSystem.out.println(json);\nreturn json;\n}\n@POST\n@Path(\"param/typed/jarray\")\npublic JsonArray sendArray(\nfinal JsonArray json) {\nSystem.out.println(json);\nreturn json;\n}\n@POST\n@Path(\"param/typed/request\")\npublic String sendObj(\nfinal HttpServerRequest request,\nfinal HttpServerResponse response\n) {\nSystem.out.println(request);\nSystem.out.println(response);\nreturn \"Hello, request/response.\";\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 3 Event ) The endpoint up.god.micro.params.TypedExecutor scanned 3 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/param/typed/jarray\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/param/typed/json\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/param/typed/request\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/#31-json-request","title":"3.1. Json Request","text":"<p>URL : http://localhost:6083/api/param/typed/json</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"Lang.Yu\",\n\"password\":\"11111111\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"username\": \"Lang.Yu\",\n\"password\": \"11111111\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/#32-json-array-request","title":"3.2. Json Array Request","text":"<p>URL: http://localhost:6083/api/param/typed/jarray</p> <p>Method: POST</p> <p>Request :</p> <pre><code>[{\n\"username\":\"Lang.Yu\",\n\"password\":\"111111111\"\n},{\n\"username\":\"Lang.Yu1\",\n\"email\":\"lang.yu@hpe.com\"\n}]\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": [\n{\n\"username\": \"Lang.Yu\",\n\"password\": \"111111111\"\n},\n{\n\"username\": \"Lang.Yu1\",\n\"email\": \"lang.yu@hpe.com\"\n}\n]\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/#33-requestresponse","title":"3.3. Request/Response","text":"<p>URL: http://localhost:6083/api/param/typed/jarray</p> <p>Method: POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"request\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": \"Hello, request/response.\"\n}\n</code></pre> <p>Here you could see the object output in console and they are not null as following:</p> <pre><code>io.vertx.ext.web.impl.HttpServerRequestWrapper@7fce20b3\nio.vertx.core.http.impl.HttpServerResponseImpl@117977a3\n</code></pre>"},{"location":"vertx-zero-tutorial/d10015-by-typed-parameters/#4-summary","title":"4. Summary","text":"<p>This tutorial describe the typed parameters by zero system default supported, in this situation you should know how to use typed parameters in your project.</p>"},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/","title":"JSR311, @Consumes...Media Type","text":"<p>Zero system support content negotiation in restful web service application as web framework, here we used <code>javax.ws.rs.Consumes</code> annotation to focus on http header <code>Content-Type</code>, it means that you must provide this header value in your request.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.media;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport io.vertx.up.eon.legacy.VValue;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.core.MediaType;\n@EndPoint\n@Path(\"/api\")\npublic class ContentActor {\n@POST\n@Path(\"media/json\")\n@Consumes(MediaType.APPLICATION_JSON)\npublic String sayJson(final JsonObject data) {\nreturn data.encode();\n}\n@POST\n@Path(\"media/xml\")\n@Consumes(MediaType.APPLICATION_XML)\npublic String sayXml(final byte[] data) {\nfinal String xml = new String(data, Values.CHARSET);\nSystem.out.println(xml);\nreturn xml;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.media.ContentActor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/media/json\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/media/xml\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/#31-error-request","title":"3.1. Error Request","text":"<p>URL: http://localhost:6083/api/media/json</p> <p>Method : POST</p> <p>Headers :</p> <pre><code>Content-Type: application/xml\n</code></pre> <p>Response : ( Status Code = 415 )</p> <pre><code>{\n\"code\": -60006,\n\"message\": \"[ERR-60006] (MediaAtom) Web Exception occus: (415) - Server could not accept the mime \\\"application/xml\\\", expected should be one of application/json.\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/#32-json-request","title":"3.2. Json Request","text":"<p>URL: http://localhost:6083/api/media/json</p> <p>Method : POST</p> <p>Headers :</p> <pre><code>Content-Type: application/json\n</code></pre> <p>Request:</p> <pre><code>{\n\"username\":\"request\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": \"{\\\"username\\\":\\\"request\\\"}\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/#33-xml-request","title":"3.3. Xml Request","text":"<p>Xml resolver of media type is still in development, in current situation there is no business requirement that related to application/xml media type, so this kind of resolution will be put in future plan.</p>"},{"location":"vertx-zero-tutorial/d10016-jsr311-consumesmedia-type/#4-summary","title":"4. Summary","text":"<p>Although in current version zero system does not support some complex media type, but for future plan following media type will be put into zero and it depend on some business requirements, please check following supported list in current version of zero to know.</p> <ul> <li>[ ] application/xml</li> <li>[ ] application/atom+xml</li> <li>[ ] application/xhtml+xml</li> <li>[ ] application/svg+xml</li> <li>[x] application/json</li> <li>[x] application/x-www-form-urlencoded</li> <li>[x] multipart/form-data</li> <li>[ ] application/octet-stream</li> <li>[x] text/plain</li> <li>[ ] text/xml</li> <li>[ ] text/html</li> <li>[ ] text/event-stream</li> <li>[ ] application/json-patch+json</li> </ul>"},{"location":"vertx-zero-tutorial/d10017-jsr311-producesmedia-type/","title":"JSR311, @Produces...Media Type","text":"<p>Zero system could parse header <code>Content-Type</code> and produce error of 415 Unsupported Media Type. And also it could provide client media type parsing, but it's not the code 406, but 404 instead. It means that when user provide <code>Accept</code> header, once zero server could not provide the matching type endpoint, the server will tell user that the resource could not be found. We'll use <code>javax.ws.rs.Produces</code> annotation to do the client media type matching.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10017-jsr311-producesmedia-type/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.media;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n@EndPoint\n@Path(\"/api\")\npublic class AcceptActor {\n@POST\n@Path(\"media/accept\")\n@Produces(MediaType.APPLICATION_JSON)\npublic JsonObject sayJson(final JsonObject data) {\nreturn data;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10017-jsr311-producesmedia-type/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.media.AcceptActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/media/accept\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10017-jsr311-producesmedia-type/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10017-jsr311-producesmedia-type/#31-not-found","title":"3.1. Not Found","text":"<p>URL : http://localhost:6083/api/media/accept</p> <p>Method : POST</p> <p>Headers :</p> <pre><code>Accept: application/xml\nContent-Type: application/json\n</code></pre> <p>Response : ( Status Code = 404 )</p> <pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;Resource not found&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"vertx-zero-tutorial/d10017-jsr311-producesmedia-type/#32-correct-request","title":"3.2. Correct Request","text":"<p>URL : http://localhost:6083/api/media/accept</p> <p>Method : POST</p> <p>Headers :</p> <pre><code>Accept: application/json\nContent-Type: application/json\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"username\": \"request\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10017-jsr311-producesmedia-type/#4-summary","title":"4. Summary","text":"<p>Here leave a problem for headers, you also need to setup <code>Content-Type</code> header in your request, then you can set <code>Accept</code> for media type parsing.</p>"},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/","title":"Non-Blocking, Enable EventBus","text":"<p>As we known, all the request operations in vert.x should be async style and the concept of request in vert.x we also call it \"Event\", here we'll introduce the core zero Event Driven Model. The event-request workflow in zero will be as following sequence:</p> <ol> <li><code>@EndPoint</code> class listened the http port, we often call the role of this class \"Agent\", it will receive http restful    request.</li> <li>This class's threads will work in Event Loop of vert.x, then zero system will put the return value of the method    in <code>@EndPoint</code> to wrapper to <code>Envelop</code> object ( Uniform Resource Model ), and this operation is invisible for    developers.</li> <li>Then the <code>Envelop</code> object will be sent by <code>@Address</code> to event bus.</li> <li>Then the worker threads will consume the <code>Envelop</code> message from event bus by the same <code>@Address</code> .</li> <li>Finally the worker threads ( That are working in worker pool ) will reply the results to client.</li> </ol> <p>In total the request work flow should be:</p> <pre><code>Request -&gt; Agent -&gt; @Address ( Sender ) -&gt; \n    EventBus -&gt; \n        @Address ( Consumer ) -&gt; Worker -&gt; Response\n</code></pre> <p>But for above request workflow, the developers could focus on Sender and Consumer threads development only, it's enough to finish business requirement.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/#11-sender-in-agent","title":"1.1. Sender ( In Agent )","text":"<pre><code>package up.god.micro.request;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@Path(\"/api\")\n@EndPoint\npublic class AsyncActor {\n@Path(\"/async/event\")\n@POST\n@Address(\"ZERO://EVENT\")    // Event bus address communication\npublic JsonObject sendEvent(final JsonObject data) {\nreturn data;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/#12-consumer-in-worker","title":"1.2. Consumer ( In Worker )","text":"<pre><code>package up.god.micro.request;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class AsyncWorker {\n@Address(\"ZERO://EVENT\")    // Event but address communication\npublic Envelop reply(final Envelop envelop) {\nfinal JsonObject resource = envelop.data();\nSystem.out.println(resource);\nresource.put(\"result\", \"SUCCESS\");\nreturn Envelop.success(resource);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/#2-console","title":"2. Console","text":"<p>There are some differences in async mode in console:</p> <pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.request.AsyncActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 1 Queue ) The Zero system has found 1 components of @Queue.\n[ ZERO ] Vert.x zero has found 1 incoming address from the system. Incoming address list as below: [ ZERO ]        Addr : ZERO://EVENT\n[ ZERO ] ( 1 Receipt ) The queue up.god.micro.request.AsyncWorker scanned 1 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( Uri Register ) \"/api/async/event\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/#31-async-request","title":"3.1. Async Request","text":"<p>URL : http://localhost:6083/api/async/event</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"username\": \"lang.yu\",\n\"email\": \"lang.yu@hpe.com\",\n\"result\": \"SUCCESS\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10018-async-enable-eventbus/#4-summary","title":"4. Summary","text":"<p>In this tutorial you could know the async request workflow in zero system, it's not created or designed by zero system but vert.x provided. This mode is high performance mode to process requests, and we recommend to use Event Bus to do some long term works such as database accessing, network processing etc. From this chapter we'll start to move on async request workflow in zero system.</p>"},{"location":"vertx-zero-tutorial/d10019-non-blocking-mode-1-sync-mode/","title":"Non-Blocking, Mode 1 Sync Mode","text":"<p>Zero system support many request modes as smart flow, this tutorial describe the first mode that often appeared in previous tutorials.</p>"},{"location":"vertx-zero-tutorial/d10019-non-blocking-mode-1-sync-mode/#1-introduction","title":"1. Introduction","text":"<p>This mode is standard non-event bus mode, it won't enable event bus, but agent ( <code>@EndPoint</code> ) only. The workflow should be as following:</p> <p></p> <p>Agent threads are running in event loop thread pool of vert.x, in this mode the workflow should be:</p> <ol> <li>The client send web request to zero system.</li> <li>The routing sub-system of zero will match the web request uri to look up correct routing handler.</li> <li>Routing handler will execute the mounted java function ( Defined by developer ).</li> <li>After java function executed, zero system will convert return value of the function to web response and send to    client.</li> </ol> <p>There is no consumer role in this workflow, but sender instead:</p> <pre><code>Request -&gt; Agent -&gt; @EndPoint ( Sender ) -&gt; Response\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10019-non-blocking-mode-1-sync-mode/#2-source-code","title":"2. Source Code","text":"<pre><code>package up.god.micro.request;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class SyncModeActor {\n@Path(\"request/sync\")\n@GET\npublic String sayHello() {\nreturn \"Hello Sync Mode.\";\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10019-non-blocking-mode-1-sync-mode/#programming-rules","title":"Programming Rules","text":"<ol> <li>The sender class should be annotated with <code>io.vertx.up.annotations.EndPoint</code>.</li> <li>Other annotations all belong to JSR311, you should set one http method annotation to java method.</li> <li>The java method return type must not be <code>void</code>.</li> <li>Do not use <code>@Address</code> annotation, this mode should disable event bus.</li> </ol>"},{"location":"vertx-zero-tutorial/d10019-non-blocking-mode-1-sync-mode/#3-console","title":"3. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.request.SyncModeActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/request/sync\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10019-non-blocking-mode-1-sync-mode/#4-testing","title":"4. Testing","text":"<p>URL : http://localhost:6083/api/request/sync</p> <p>Method : GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hello Sync Mode.\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10019-non-blocking-mode-1-sync-mode/#5-summary","title":"5. Summary","text":"<p>In zero programming specification, we often named this class suffix with <code>Actor</code>, it means that this actor is working in agent thread, as an actor it will dispatch the request or process request. In the mode of current tutorial, this actor process the web request directly.</p>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/","title":"Non-Blocking, Mode 2 Ping Mode","text":"<p>This mode is simpler than Mode 1 Sync Mode, but we could use this mode to check some remote status such as following requirement:</p> <ul> <li>Check whether the record existing or missing.</li> <li>Get remote status of some components such as schedulers, timers.</li> </ul> <p>The response of this mode will be true or false only.</p>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#1-introduction","title":"1. Introduction","text":"<p>This mode is also another non-event bus mode, it could be finished by agent ( <code>@EndPoint</code> ) only, the workflow should be as following:</p> <p></p> <p>This mode workflow is the same as Sync Mode except the response data, It could be used in some special requirement only. In this mode zero system tell the client whether the working is correct or wrong and won't provide any data in web response.</p> <p>There is no consumer role in this workflow, but sender instead:</p> <pre><code>Request -&gt; Agent -&gt; @EndPoint ( Sender ) -&gt; Response ( true/false )\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#2-source-code","title":"2. Source Code","text":"<pre><code>package up.god.micro.request;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class PingModeActor {\n@Path(\"request/ping\")\n@GET\npublic void check() {\nSystem.out.println(\"Hello, I'm working well.\");\n}\n@Path(\"request/ping-false\")\n@GET\npublic boolean checkStatus() {\nSystem.out.println(\"Hello, I'm working well and return false.\");\nreturn false;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#programming-rules","title":"Programming Rules","text":"<ol> <li>The sender class should be annotated with <code>io.vertx.up.annotations.EndPoint</code>.</li> <li>Other annotations all belong to JSR311, you should set one http method annotation to java method.</li> <li>The java method return type must be <code>void</code>or <code>boolean</code> , it's the only difference from Sync Mode.</li> <li>Do not use <code>@Address</code> annotation, this mode should disable event bus.</li> </ol>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#3-console","title":"3. Console","text":"<pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.request.PingModeActor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( Uri Register ) \"/api/request/ping\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/request/ping-false\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#4-testing","title":"4. Testing","text":""},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#41-ping-request","title":"4.1. Ping Request","text":"<p>URL : http://localhost:6083/api/request/ping</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": true\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#42-ping-false-request","title":"4.2. Ping false Request","text":"<p>URL : http://localhost:6083/api/request/ping-false</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": false\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10020-non-blocking-mode-2-block-mode/#5-summary","title":"5. Summary","text":"<p>In current version of zero, this mode only support two response value: true/false, if you want to get more information from remote zero system, you should use Sync Mode instead.</p>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/","title":"Non-Blocking, Mode 3 One Way Mode","text":"<p>From this chapter of the tutorials, we started to introduce <code>EventBus</code> enabled mode, the one way mode just like Ping Mode, but enable the event bus instead of agent only. The data will be send to event bus and it's better to use this mode to do some async jobs or long time jobs.</p>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#1-introduction","title":"1. Introduction","text":"<p>There are both sender and consumer in current mode:</p> <pre><code>Request -&gt; Agent -&gt; @Address ( Sender ) -&gt; \n    EventBus -&gt; \n        @Address ( Consumer ) -&gt; Worker -&gt; Response ( true / false )\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#21-sender","title":"2.1. Sender","text":"<pre><code>package up.god.micro.request;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class OneWayActor {\n@POST\n@Path(\"request/one-way\")\n@Address(\"ZERO://ONE-WAY\")\npublic String process(\nfinal JsonObject data\n) {\nreturn data.encode();\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#22-consumer","title":"2.2. Consumer","text":"<pre><code>package up.god.micro.request;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class OneWayWorker {\n@Address(\"ZERO://ONE-WAY\")\npublic void process(final Envelop envelop) {\nfinal String item = envelop.data();\nSystem.out.println(item);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#programming-rules","title":"Programming Rules","text":"<ol> <li>The worker class must be annotated with <code>io.vertx.up.annotations.Queue</code>.</li> <li>The worker method signature must be <code>void xxx(Envelop)</code>, in this mode this method signature is fixed.</li> <li>You must use <code>io.vertx.up.annotations.Address</code> annotation to set address of string type in Sender/Consumer both.</li> <li>Address value should be the same shared in Sender/Consumer.</li> </ol>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#3-console","title":"3. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.request.OneWayActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 2 Queue ) The Zero system has found 2 components of @Queue.\n[ ZERO ] Vert.x zero has found 2 incoming address from the system. Incoming address list as below: ......\n[ ZERO ]        Addr : ZERO://ONE-WAY\n......\n[ ZERO ] ( 1 Receipt ) The queue up.god.micro.request.OneWayWorker scanned 1 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( Uri Register ) \"/api/request/one-way\" has been deployed by ZeroHttpAgent, Options = Route...\n</code></pre>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#4-testing","title":"4. Testing","text":"<p>URL : http://localhost:6083/api/request/one-way</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": true\n}\n</code></pre> <p>You could see output in console as following:</p> <pre><code>{\"username\":\"lang.yu\",\"email\":\"lang.yu@hpe.com\"}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10021-non-blocking-mode-3-one-way-mode/#5summary","title":"5.Summary","text":"<p>This mode just like Ping mode, the data in response is true/false only, the little difference between Ping Mode and current mode is that current mode enabled event bus and the task has been finished by agent/worker threads both and they are asynchronous, but Ping mode's works have been finished by single thread of agent.</p>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/","title":"Non-Blocking, Mode 4 Async Mode ( Java Style )","text":"<p>The most useful mode in zero system will be from current chapter, we call it asynchronous mode, it will be used in many business scenarios. We have defined different programming style for this mode and this tutorial will introduce this mode in java style.</p>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#1-introduction","title":"1. Introduction","text":"<p>There are both sender and consumer in current mode, and the response will reply the processed result.</p> <pre><code>Request -&gt; Agent -&gt; @Address ( Sender ) -&gt; \n    EventBus -&gt; \n        @Address ( Consumer ) -&gt; Worker -&gt; Response\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#21-sender","title":"2.1. Sender","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class JavaStyleActor {\n@POST\n@Path(\"request/java\")\n@Address(\"ZERO://ASYNC/JAVA\")\npublic String sayHell(final JsonObject data) {\nreturn data.encode();\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#22-consumer","title":"2.2. Consumer","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class JavaStyleWorker {\n@Address(\"ZERO://ASYNC/JAVA\")\npublic Envelop async(final Envelop input) {\nfinal String literal = input.data();\nfinal JsonObject data = new JsonObject()\n.put(\"result\", \"SUCCESS\")\n.put(\"input\", literal);\nreturn Envelop.success(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#programming-style","title":"Programming Style","text":"<ol> <li>The worker class must be annotated with <code>io.vertx.up.annotations.Queue</code>.</li> <li>The worker method signature must be <code>Envelop xxx(Envelop)</code>, in this mode this method signature is fixed.</li> <li>You must use <code>io.vertx.up.annotations.Address</code> annotation to set address of string type in Sender/Consumer both.</li> <li>Address value should be the same shared in Sender/Consumer.</li> </ol> <p>The difference between One Way Mode and Async Mode ( Java Style ) is the method signature of consumer. In One Way Mode, the client does not care the response data, zero will tell client the response true or false, but in current mode, zero system will reply the executed returned data.</p>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#3-console","title":"3. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.async.JavaStyleActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] Vert.x zero has found 3 incoming address from the system. Incoming address list as below: [ ZERO ]        Addr : ZERO://ASYNC/JAVA\n......\n[ ZERO ] ( 1 Receipt ) The queue up.god.micro.async.JavaStyleWorker scanned 1 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( Uri Register ) \"/api/request/java\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#4-testing","title":"4. Testing","text":"<p>URL : http://localhost:6083/api/request/java</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"result\": \"SUCCESS\",\n\"input\": \"{\\\"username\\\":\\\"lang.yu\\\",\\\"email\\\":\\\"lang.yu@hpe.com\\\"}\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10022-recommend-non-blocking-mode-4-async-mode/#5-summary","title":"5. Summary","text":"<p>This mode is widely used mode in zero system, except programming style, we recommend to use this mode in your real environment. The following requirements should be done by worker threads instead of agent only:</p> <ul> <li>[x] The task that will take a long time to be finished.</li> <li>[x] Database accessing.</li> <li>[x] Network IO connection/requesting.</li> <li>[x] File system accessing.</li> <li>[x] Complex business calculating.</li> <li>[x] Data size is huge and it may take many resources ( CPU, Memory ).</li> </ul>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/","title":"Non-Blocking, Mode 4 Experimental extension","text":"<p>In zero system programming, we recommend to use uniform resource model instead of the type user defined, but for some special business requirements, many developers also want to use their own java class type. Zero system also provide extension to developer for this kind of situations. Because it's not standard mode, in current version of zero system, we still consider it as experimental because it may contain long progress in future to finish and may contain unexpected bugs.</p> <p>Rules</p> <ul> <li>The consumer class should only accept one argument, because of that the argument came from sender class.</li> <li>The consumer class argument data type must be matching or compatible with sender class return type.</li> </ul> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#11-pojo-class","title":"1.1 Pojo Class","text":"<pre><code>package up.god.micro.async;\nimport lombok.Data;\n@Data\npublic class JavaJson {\nprivate String name;\nprivate String email;\nprivate Integer age;\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#12-sender","title":"1.2 Sender","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api\")\npublic class JavaDirectActor {\n// String out\n@POST\n@Path(\"request/java-direct\")\n@Address(\"ZERO://ASYNC/JAVA/DIRECT\")\npublic String sayHello(\n@QueryParam(\"age\") final int age) {\nreturn String.valueOf(age);\n}\n// Pojo out\n@POST\n@Path(\"request/java-pojo\")\n@Address(\"ZERO://ASYNC/JAVA/POJO\")\npublic JavaJson sayPojo(\n@QueryParam(\"age\") final int age) {\nfinal JavaJson json = new JavaJson();\njson.setAge(age);\njson.setName(\"Lang\");\njson.setEmail(\"lang.yu@hpe.com\");\nreturn json;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#13-consumer","title":"1.3 Consumer","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\n@Queue\npublic class JavaDirectWorker {\n@Address(\"ZERO://ASYNC/JAVA/DIRECT\")\npublic String sayHello(final String age) {\nreturn \"Hello: \" + age;\n}\n@Address(\"ZERO://ASYNC/JAVA/POJO\")\npublic String sayPojo(final JavaJson pojo) {\nreturn pojo.toString();\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#2-console","title":"2. Console","text":"<pre><code>......\n( 2 Event ) The endpoint up.god.micro.async.JavaDirectActor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 4 Queue ) The Zero system has found 4 components of @Queue.\n[ ZERO ] Vert.x zero has found 5 incoming address from the system. Incoming address list as below:\n......\n[ ZERO ]        Addr : ZERO://ASYNC/JAVA/DIRECT\n[ ZERO ]        Addr : ZERO://ASYNC/JAVA/POJO\n[ ZERO ] ( 2 Receipt ) The queue up.god.micro.async.JavaDirectWorker scanned 2 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( Uri Register ) \"/api/request/java-direct\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/request/java-pojo\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#3-testing","title":"3. Testing","text":""},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#31-direct-request","title":"3.1. Direct Request","text":"<p>URL : http://localhost:6083/api/request/java-direct?age=22</p> <p>Method : POST</p> <p>Response :</p> <pre><code>{\n\"data\": \"Hello: 22\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#32-pojo-request","title":"3.2. Pojo Request","text":"<p>URL: http://localhost:6083/api/request/java-pojo?age=22</p> <p>Method : POST</p> <p>Response :</p> <pre><code>{\n\"data\": \"JavaJson(name=Lang, email=lang.yu@hpe.com, age=33)\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10023-non-blocking-mode-4-experimental-extension/#4-summary","title":"4. Summary","text":"<p>Here we provide this mode for some special requirements, but we still recommend to use the mode of vert.x style that will be described in next tutorials. Current mode is experimental version, there may be some bugs for this kind of requirements, once you met bugs you can submit to https://github.com/silentbalanceyh/vertx-zero/issues </p>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/","title":"Non-Blocking, Mode 5 Async Mode ( vert.x style )","text":"<p>This mode is very important in zero system, because we prefer to recommend use this mode in your development. Because vert.x is non-blocking and async, this mode is based on vert.x async multi threads, if you use this mode to do development works, you can be very smart to finish all the business requirements.</p> <p>From architecture of zero system, this mode contains following advantages:</p> <ul> <li>[x] You can use all the native async clients that vert.x provided directly such   as <code>MongoClient, MySqlClient, RedisClient</code>etc.</li> <li>[x] All the request works should be async mode and the performance is better.</li> <li>[x] You can do some reactive programming with <code>Rxjava2</code> instead of others.</li> <li>[x] You can use <code>UtilityX</code> package that zero system provided to do complex business requirements or frequently   requirements.</li> </ul>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#1-introduction","title":"1. Introduction","text":"<p>The workflow of this mode is the same as Mode 4, but there are some difference in programming. There are both sender and consumer in current mode, and the response will reply the processed result.</p> <pre><code>Request -&gt; Agent -&gt; @Address ( Sender ) -&gt; \n    EventBus -&gt; \n        @Address ( Consumer with MessageHandler ) -&gt; Worker -&gt; Response\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#21-sender","title":"2.1. Sender","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class VertxStyleActor {\n@POST\n@Path(\"request/vertx/handler\")\n@Address(\"ZERO://ASYNC/VERTX/HANDLER\")\npublic JsonObject sayHandler(final JsonObject data) {\ndata.put(\"agent\", \"HANDLER\");\nreturn data;\n}\n@POST\n@Path(\"request/vertx/future\")\n@Address(\"ZERO://ASYNC/VERTX/FUTURE\")\npublic JsonObject sayFuture(final JsonObject data) {\ndata.put(\"agent\", \"FUTURE\");\nreturn data;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#22-consumer","title":"2.2. Consumer","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.core.Future;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class VertxStyleWorker {\n@Address(\"ZERO://ASYNC/VERTX/HANDLER\")\npublic void sayMessage(final Message&lt;Envelop&gt; message) {\nfinal JsonObject data = Ux.getBody(message);\nmessage.reply(Envelop.success(data));\n}\n@Address(\"ZERO://ASYNC/VERTX/FUTURE\")\npublic Future&lt;JsonObject&gt; sayFuture(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nreturn Future.succeededFuture(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#programming-rules","title":"Programming Rules","text":"<ol> <li>The worker class must be annotated with <code>io.vertx.up.annotations.Queue</code>.</li> <li>You must use <code>io.vertx.up.annotations.Address</code> annotation to set address of string type in Sender/Consumer both.</li> <li>Address value should be the same shared in Sender/Consumer.</li> <li>The worker method signature should be as following:<ol> <li><code>void method(Message&lt;Envelop&gt;)</code></li> <li><code>Future&lt;T&gt; method(Envelop)</code></li> <li><code>Future&lt;Envelop&gt; method(Envelop)</code></li> </ol> </li> </ol>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#3-console","title":"3. Console","text":"<pre><code>......\n[ ZERO ] ( 2 Event ) The endpoint up.god.micro.async.VertxStyleActor scanned 2 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 6 Queue ) The Zero system has found 6 components of @Queue.\n......\n[ ZERO ]        Addr : ZERO://ASYNC/VERTX/FUTURE\n[ ZERO ]        Addr : ZERO://ASYNC/VERTX/HANDLER\n......\n[ ZERO ] ( 2 Receipt ) The queue up.god.micro.async.VertxStyleWorker scanned 2 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( Uri Register ) \"/api/request/vertx/future\" has been deployed by ZeroHttpAgent, Options = Route...\n[ ZERO ] ( Uri Register ) \"/api/request/vertx/handler\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#4-testing","title":"4. Testing","text":""},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#41-message-request","title":"4.1. Message Request","text":"<p>URL : http://localhost:6083/api/request/vertx/handler</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"username\": \"lang.yu\",\n\"email\": \"lang.yu@hpe.com\",\n\"agent\": \"HANDLER\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#42-future-request","title":"4.2. Future Request","text":"<p>URL : http://localhost:6083/api/request/vertx/future</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"username\": \"lang.yu\",\n\"email\": \"lang.yu@hpe.com\",\n\"agent\": \"FUTURE\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10024-non-blocking-mode-5-async-mode-vertx-style/#5-summary","title":"5. Summary","text":"<p>Current mode is standard vert.x mode and we recommend to use this mode in your project. Here are a java class named <code>Envelop</code> and it's Uniform Resource Model that defined by zero system, it could take many information to go through from agent to worker threads on event bus. The Uniform Resource Model will be introduced in future tutorials, it could help developers to simply the programming in web container, service specification and restful web request, then the developers could focus on business requirements only.</p>"},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/","title":"Non-Blocking, Mode 5 Experimental extension","text":"<p>In zero system programming, the mode 5 is recommend because it could release the power of vert.x. For some special business requirements the developers want to return to Java style to do programming, based on this situation we also developed the advanced mode 5, call it experimental version. This version could let the developer more freedom to do programming in zero system, although we provide this mode, zero system still recommend the developers to use Uniform Resource Model that defined by zero system because it contains more standard data here.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/#11-sender","title":"1.1. Sender","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class VertxAsyncActor {\n@POST\n@Path(\"request/vertx/futureT\")\n@Address(\"ZERO://ASYNC/VERTX/FUTURE_T\")\npublic JsonObject sayFutureT(final JsonObject data) {\ndata.put(\"agent\", \"T\");\nreturn data;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.async;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\n@Queue\npublic class VertxAsyncWorker {\n@Address(\"ZERO://ASYNC/VERTX/FUTURE_T\")\npublic Future&lt;JsonObject&gt; sayFutureT(final JsonObject data) {\nfinal String string = data.encode();\nSystem.out.println(string);\ndata.put(\"result\", \"Perfect\");\nreturn Future.succeededFuture(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/#programming-rules","title":"Programming Rules","text":"<ol> <li>The worker class must be annotated with <code>io.vertx.up.annotations.Queue</code>.</li> <li>You must use <code>io.vertx.up.annotations.Address</code> annotation to set address of string type in Sender/Consumer both.</li> <li>Address value should be the same shared in Sender/Consumer.</li> <li>The biggest difference between standard mode 5 and current mode is that there is no limitation in current mode, we    could be sure the method signature should be: <code>Future&lt;T&gt; method( I )</code>, except the return type should    be: <code>io.vertx.core.Future</code>, other programming parts are almost the same as java programming.</li> </ol>"},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.async.VertxAsyncActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 6 Queue ) The Zero system has found 6 components of @Queue.\n[ ZERO ] Vert.x zero has found 8 incoming address from the system. Incoming address list as below: ......\n[ ZERO ]        Addr : ZERO://ASYNC/VERTX/FUTURE_T\n......\n[ ZERO ] ( 1 Receipt ) The queue up.god.micro.async.VertxAsyncWorker scanned 1 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( Uri Register ) \"/api/request/vertx/futureT\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/#3-testing","title":"3. Testing","text":"<p>URL : http://localhost:6083/api/request/vertx/futureT</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"username\": \"lang.yu\",\n\"email\": \"lang.yu@hpe.com\",\n\"agent\": \"T\",\n\"result\": \"Perfect\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10025-non-blocking-mode-5-experimental-extension/#4-summary","title":"4. Summary","text":"<p>This mode is in experimental phase because it may contain some bugs here, but in our projects we have put it into production environment to verify this features. Also this mode is recommend by our team because it's more the same as java programming.</p>"},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/","title":"JSR330, @Inject Simple Java Object","text":"<p>Until now, the tutorials have introduced the usage of JSR311, Non-Blocking parts, then the tutorials will describe another Java Specification JSR330 - Dependency Injection. In current version of zero system, it support some parts of JSR330, here are the features that zero system supported:</p> <ul> <li>[x] <code>javax.inject.Inject</code> annotation</li> <li>[x] <code>javax.inject.Named</code> annotation</li> <li>[x] <code>io.vertx.up.annotations.Qualifier</code> extend annotation</li> </ul> <p>For above three annotations, zero system support following features</p> <ul> <li>[x] Simple Java Object Injection</li> <li>[x] One interface and one java implementation object Injection</li> <li>[x] One interface and multi java implementation objects Injection</li> </ul> <p>Based on above three points, zero system contains some limitation to implement this JSR.</p> <ol> <li>The data object such as POJO could not be used with injection in zero system. Do not use!</li> <li>All the injected java object in zero system is singleton, it's not needed to use <code>javax.inject.Singleton</code> annotation    to mark.</li> </ol> <p>Current chapter will introduce simple java object injection firstly.</p> <pre><code>Request -&gt; Agent -&gt; @Address ( Sender ) -&gt; \n    EventBus -&gt; \n        @Address ( Consumer ) -&gt; Worker \n                                    -&gt; Simple Object -&gt; Response\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/#11-sender","title":"1.1. Sender","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api\")\npublic class SimpleActor {\n@Path(\"inject/simple\")\n@GET\n@Address(\"ZERO://INJECT/SIMPLE\")\npublic JsonObject sayInject(\n@QueryParam(\"username\") final String username\n) {\nreturn new JsonObject()\n.put(\"age\", 33)\n.put(\"username\", username);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport javax.inject.Inject;\n@Queue\npublic class SimpleWorker {\n@Inject\nprivate transient SimpleObject simple;\n@Address(\"ZERO://INJECT/SIMPLE\")\npublic Future&lt;String&gt; process(final JsonObject user) {\nfinal JsonObject processed = this.simple.getData(user);\nreturn Future.succeededFuture(processed)\n.compose(item -&gt;\nFuture.succeededFuture(item.encode()));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/#13-injected-java-object","title":"1.3. Injected Java Object","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\npublic class SimpleObject {\npublic JsonObject getData(final JsonObject data) {\ndata.put(\"className\", getClass().getName());\nreturn data;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.inject.SimpleActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 7 Queue ) The Zero system has found 7 components of @Queue.\n[ ZERO ] Vert.x zero has found 9 incoming address from the system. Incoming address list as below: ......\n[ ZERO ]        Addr : ZERO://INJECT/SIMPLE\n......\n[ ZERO ] ( 1 Receipt ) The queue up.god.micro.inject.SimpleWorker scanned 1 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( 1 Inject ) The Zero system has found \"up.god.micro.inject.SimpleWorker\" object contains \\\n1 components of @Inject or ( javax.inject.infix.* ).\n......\n[ ZERO ] ( Uri Register ) \"/api/inject/simple\" has been deployed by ZeroHttpAgent, Options = Route...\n</code></pre>"},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/#3-testing","title":"3. Testing","text":"<p>URL : http://localhost:6083/api/inject/simple?username=Lang</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": \"{\\\"age\\\":33,\\\"username\\\":\\\"Lang\\\",\\\"className\\\":\\\"up.god.micro.inject.SimpleObject\\\"}\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10026-jsr330-inject-simple-java-object/#4-summary","title":"4. Summary","text":"<p>The response body data is json format but string literal, because in our consumer class, the return type is <code>Future&lt;String&gt;</code>, if you want to get response of standard json object, you can modify the method code to following:</p> <pre><code>    @Address(\"ZERO://INJECT/SIMPLE\")\npublic Future&lt;JsonObject&gt; process(final JsonObject user) {\nfinal JsonObject processed = this.simple.getData(user);\nreturn Future.succeededFuture(processed);\n}\n</code></pre> <p>Then the response data should be as following:</p> <pre><code>{\n\"data\": {\n\"age\": 33,\n\"username\": \"Lang\",\n\"className\": \"up.god.micro.inject.SimpleObject\"\n}\n}\n</code></pre> <p>Then the response data could be parsed easily.</p>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/","title":"JSR330, @Inject One Implementation","text":"<p>From previous tutorials, zero system support following three injection codes.</p> <ul> <li>[x] Simple Java Object Injection</li> <li>[x] One interface and one java implementation object Injection</li> <li>[x] One interface and multi java implementation objects Injection</li> </ul> <p>This chapter will describe the second mode that the structure should be one interface and one implementation object. The workflow of this example should be:</p> <pre><code>Request -&gt; Agent -&gt; @Address ( Sender ) -&gt; EventBus -&gt; @Address ( Consumer ) -&gt; Worker -&gt; Stub -&gt; Service -&gt; Response\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#11-sender","title":"1.1. Sender","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class OneActor {\n@Path(\"inject/one\")\n@PUT\n@Address(\"ZERO://INJECT/ONE\")\npublic JsonObject sayInject(final JsonObject data\n) {\nreturn new JsonObject()\n.put(\"age\", 33)\n.mergeIn(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport javax.inject.Inject;\n@Queue\npublic class OneWorker {\n@Inject\nprivate transient OneStub stub;\n@Address(\"ZERO://INJECT/ONE\")\npublic Future&lt;JsonObject&gt; process(final JsonObject user) {\nfinal JsonObject processed = this.stub.getData(user);\nreturn Future.succeededFuture(processed);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#13-stub-service-layer-interface","title":"1.3. Stub ( Service Layer Interface )","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\npublic interface OneStub {\nJsonObject getData(JsonObject input);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#14-stub-service-implementation","title":"1.4. Stub ( Service Implementation )","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\npublic class OneService implements OneStub {\n@Override\npublic JsonObject getData(final JsonObject input) {\ninput.put(\"className\", getClass().getName());\nreturn input;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.inject.OneActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 8 Queue ) The Zero system has found 8 components of @Queue.\n[ ZERO ] Vert.x zero has found 10 incoming address from the system. Incoming address list as below: ......\n[ ZERO ]        Addr : ZERO://INJECT/ONE\n......\n[ ZERO ] ( 1 Receipt ) The queue up.god.micro.request.OneWayWorker scanned 1 records of Receipt, \\\nwill be mounted to event bus.\n[ ZERO ] ( Field ) Class \"class up.god.micro.inject.OneWorker\" scanned field = \"stub\" of \\\nup.god.micro.inject.OneService annotated with interface javax.inject.Inject. \\\nwill be initialized with DI container.\n......\n[ ZERO ] ( Uri Register ) \"/api/inject/one\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#3-testing","title":"3. Testing","text":"<p>URL : http://localhost:6083/api/inject/one</p> <p>Method : PUT</p> <p>Request :</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"age\": 33,\n\"username\": \"lang.yu\",\n\"email\": \"lang.yu@hpe.com\",\n\"className\": \"up.god.micro.inject.OneService\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10027-jsr330-inject-one-implementation/#4-summary","title":"4. Summary","text":"<p>This feature is only used when the implementation class is unique, it means that there is only one implementation class reflect to the interface. If you have multi implementation classes in zero system, how to do it and how to resolve this kind of situation ? We'll move to the next chapter to see another situations.</p>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/","title":"Zero JSR330, @Inject Multi Implementation","text":"<p>From previous tutorials, zero system support following three injection codes.</p> <ul> <li>[x] Simple Java Object Injection</li> <li>[x] One interface and one java implementation object Injection</li> <li>[x] One interface and multi java implementation objects Injection</li> </ul> <p>This chapter will describe the last mode that the structure should be one interface with multi implementation objects. The workflow of this example should be:</p> <pre><code>Request -&gt; Agent -&gt; @Address ( Sender ) -&gt; EventBus -&gt; @Address ( Consumer ) -&gt; Worker -&gt; Stub -&gt; ServiceA ( Service B ) -&gt; Response\n</code></pre> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#11-sender","title":"1.1. Sender","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic class MultiActor {\n@Path(\"inject/multi\")\n@PUT\n@Address(\"ZERO://INJECT/MULTI\")\npublic JsonObject sayInject(final JsonObject data\n) {\nreturn new JsonObject()\n.put(\"age\", 33)\n.mergeIn(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Qualifier;\nimport io.vertx.up.annotations.Queue;\nimport javax.inject.Inject;\n@Queue\npublic class MultiWorker {\n@Inject\n@Qualifier(\"ServiceB\")\nprivate transient MultiStub stub;\n@Address(\"ZERO://INJECT/MULTI\")\npublic Future&lt;JsonObject&gt; process(final JsonObject user) {\nfinal JsonObject processed = this.stub.getData(user);\nreturn Future.succeededFuture(processed);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#13-stub-service-interface","title":"1.3. Stub ( Service Interface )","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\npublic interface MultiStub {\nJsonObject getData(JsonObject input);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#14-service-service-a-implementation","title":"1.4. Service ( Service A Implementation )","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\nimport javax.inject.Named;\n@Named(\"ServiceA\")\npublic class MultiServiceA implements MultiStub {\n@Override\npublic JsonObject getData(final JsonObject input) {\ninput.put(\"className\", getClass().getName());\nreturn input;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#15-service-service-b-implementation","title":"1.5. Service ( Service B Implementation )","text":"<pre><code>package up.god.micro.inject;\nimport io.vertx.core.json.JsonObject;\nimport javax.inject.Named;\n@Named(\"ServiceB\")\npublic class MultiServiceB implements MultiStub {\n@Override\npublic JsonObject getData(final JsonObject input) {\ninput.put(\"className\", getClass().getName());\nreturn input;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#2-console","title":"2. Console","text":"<pre><code>......\n[ ZERO ] ( 1 Event ) The endpoint up.god.micro.inject.MultiActor scanned 1 events of Event, \\\nwill be mounted to routing system.\n......\n[ ZERO ] ( 9 Queue ) The Zero system has found 9 components of @Queue.\n[ ZERO ] Vert.x zero has found 11 incoming address from the system. Incoming address list as below: ......\n[ ZERO ]        Addr : ZERO://INJECT/MULTI\n......\n[ ZERO ] ( 1 Receipt ) The queue up.god.micro.inject.MultiWorker scanned 1 records of Receipt, \\\nwill be mounted to event bus.\n......\n[ ZERO ] ( 1 Inject ) The Zero system has found \"up.god.micro.inject.MultiWorker\" object \\\ncontains 1 components of @Inject or ( javax.inject.infix.* ).\n......\n[ ZERO ] ( Uri Register ) \"/api/inject/multi\" has been deployed by ZeroHttpAgent, Options = Route...\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#3-testing","title":"3. Testing","text":"<p>URL: http://localhost:6083/api/inject/multi</p> <p>Method: PUT</p> <p>Request:</p> <pre><code>{\n\"username\":\"lang.yu\",\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n\"data\": {\n\"age\": 33,\n\"username\": \"lang.yu\",\n\"email\": \"lang.yu@hpe.com\",\n\"className\": \"up.god.micro.inject.MultiServiceB\"\n}\n}\n</code></pre> <p>From the testing result we could see the inject object is \"ServiceB\".</p>"},{"location":"vertx-zero-tutorial/d10028-zero-jsr330-inject-multi-implementation/#4-summary","title":"4. Summary","text":"<p>This chapter described the usage of another two JSR330 ( Include extended ) annotations:</p> <ul> <li><code>javax.inject.Named</code></li> <li><code>io.vertx.up.annotation.Qualifier</code></li> </ul> <p>Above two annotations could resolve the situation that one interface contains more than one implementation class injection based on JSR330. But one thing you should know that it's not for switching between different implementations but for some special design in the system.</p>"},{"location":"vertx-zero-tutorial/d10029-jsr303-notnull/","title":"JSR303, @NotNull","text":"<p>From this chapter, we'll ignore the console output because in previous tutorials, you have known most of zero output logs. In many business scenarios, you need following features in your system:</p> <ul> <li>Validator: When the data you got from client is invalid, you must provide rejection response.</li> <li>Filter: You could do some conversion in your request.</li> <li>Listener: You need some background schedulers to monitor the system status.</li> </ul> <p>From this chapter we'll focus on JSR303, Bean Validation part, zero has used Hibernate Validator to support JSR303 validation, except this specification, zero system created another advanced validation feature to verify your json data format, it's common used in different Body Request here.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10029-jsr303-notnull/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.NotNull;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api/jsr303/\")\npublic class NotNullActor {\n@GET\n@Path(\"/notnull/query\")\npublic String testValid(\n@NotNull\n@PathParam(\"name\") final String name) {\nreturn \"Hello, \" + name;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10029-jsr303-notnull/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/notnull/query</p> <p>Method : GET</p> <p>Response : ( Status = 400 )</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NotNullActor, method = public java.lang.String up.god.micro.validation.NotNullActor.testValid(java.lang.String), message = must not be null.\",\n\"info\": \"must not be null\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10029-jsr303-notnull/#3-summary","title":"3. Summary","text":"<p>From above response information, you should see the validation failure in zero system, please read following comments for each json node meanings:</p> <ul> <li>code: The error code that defined by zero system, you could lookup Error Codes of zero system to know what kind of   issues that you met.</li> <li>message: The system error message that you'll meet, it describes that the error details, but it could not be   provided to client because it's unreadable.</li> <li>info : The information for client to describe the error messages. In forward tutorials we'll introduce how to   define this info and provide the information to client.</li> </ul>"},{"location":"vertx-zero-tutorial/d10030-jsr303-notnull-message/","title":"D10030, JSR303, @NotNull message","text":"<p>This chapter is a little same as D10029, but we could define the <code>info</code> node of JSON message instead of the default message as following:</p> <pre><code>must not be null\n</code></pre> <p>It's useful in many business scenarios. For example you want to write a method to verify the username and password when logging, here are two parameters:</p> <ul> <li>username: ( Path Parameter )</li> <li>password: ( Query Parameter )</li> </ul> <p>And in your requirement, you want to define some validation rules such as following:</p> <ul> <li>When the username is null, the message should be <code>Sorry, the system require you input the 'username'</code>.</li> <li>When the password is null, the system should say <code>Hi, you have not provide your password, did you forget ?</code>.</li> </ul> <p>For above requirement you can do as following in zero.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10030-jsr303-notnull-message/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.NotNull;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class NotNullMessageActor {\n@Path(\"notnull/message\")\n@GET\npublic String verify(\n@NotNull(message = \"Sorry, the system require you input the 'username'\")\n@QueryParam(\"username\") final String username,\n@NotNull(message = \"Hi, you have not provide your password, did you forget ?\")\n@QueryParam(\"password\") final String password\n) {\nreturn \"Hi, \" + username + \", Your password is: \" + password;\n}\n}\n</code></pre> <p>Here we could see:</p> <p>The message attribute 'message' also belong to JSR303, Bean Validation, you can set any response error message that you wanted here.</p>"},{"location":"vertx-zero-tutorial/d10030-jsr303-notnull-message/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/notnull/message</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NotNullMessageActor, method = public java.lang.String up.god.micro.validation.NotNullMessageActor.verify(java.lang.String,java.lang.String), message = Hi, you have not provide your password, did you forget ?.\",\n\"info\": \"Hi, you have not provide your password, did you forget ?\"\n}\n</code></pre> <p> URL : http://localhost:6083/api/jsr303/notnull/message?password=111111</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NotNullMessageActor, method = public java.lang.String up.god.micro.validation.NotNullMessageActor.verify(java.lang.String,java.lang.String), message = Sorry, the system require you input the 'username'.\",\n\"info\": \"Sorry, the system require you input the 'username'\"\n}\n</code></pre> <p>The successful message should be as following, URL:</p> <p>http://localhost:6083/api/jsr303/notnull/message?password=111111&amp;username=Lang</p> <pre><code>{\n\"data\": \"Hi, Lang, Your password is: 111111\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10030-jsr303-notnull-message/#3-summary","title":"3. Summary","text":"<p>Please be careful that JSR303 for this validation do not focus on the validation sequence, it just like above examples that the password is validated first, then the username. Here we have defined our own message for JSR303 validation instead of default validation messages. In this situation you can work in your real business requirements for more extensions to do user-defined business validation information.</p>"},{"location":"vertx-zero-tutorial/d10031-jsr303-notnull-message-template/","title":"JSR303, @NotNull message template","text":"<p>For localization usage, because zero system uses Hibernate Validator for JSR303, it means that it could support message template for different locale usage. But we have renamed the default property filename. This chapter will tell you how to use message template in zero system.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10031-jsr303-notnull-message-template/#1-configuration","title":"1. Configuration","text":"<p>In your resource root folder, create a new up.god.file named <code>vertx-validation.properties</code>, in Maven project, this folder is often <code>src/main/resources</code>. In this up.god.file, you can put the property key, value pair for validation message, the content is as following:</p> <pre><code>notnull.username=Sorry, this api require you input \"username\".\nnotnull.password=Please provide your 'password'.\n</code></pre> <p>The record the message key, here are <code>notnull.username</code> and <code>notnull.password</code> as message key.</p>"},{"location":"vertx-zero-tutorial/d10031-jsr303-notnull-message-template/#2-source-code","title":"2. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.NotNull;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class NotNullTplActor {\n@GET\n@Path(\"notnull/tpl\")\npublic String tpl(\n@NotNull(message = \"{notnull.username}\")\n@QueryParam(\"username\") final String username,\n@NotNull(message = \"{notnull.password}\")\n@QueryParam(\"password\") final String password\n) {\nreturn \"Hi, \" + username + \", your password is \" + password;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10031-jsr303-notnull-message-template/#3-testing","title":"3. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/notnull/tpl</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NotNullTplActor, method = public java.lang.String up.god.micro.validation.NotNullTplActor.tpl(java.lang.String,java.lang.String), message = Please provide your 'password'..\",\n\"info\": \"Please provide your 'password'.\"\n}\n</code></pre> <p>URL : http://localhost:6083/api/jsr303/notnull/tpl?password=1111</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NotNullTplActor, method = public java.lang.String up.god.micro.validation.NotNullTplActor.tpl(java.lang.String,java.lang.String), message = Sorry, this api require you input \\\"username\\\"..\",\n\"info\": \"Sorry, this api require you input \\\"username\\\".\"\n}\n</code></pre> <p>The success message should be as following:</p> <p>URL : http://localhost:6083/api/jsr303/notnull/tpl?password=1111&amp;username=Lang</p> <pre><code>{\n\"data\": \"Hi, Lang, your password is 1111\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10031-jsr303-notnull-message-template/#4-summary","title":"4. Summary","text":"<p>Until now, we have introduced three ways to use JSR303 in zero system, in forward tutorials we'll introduce other annotations for different business rules. But for the ways to use, they are the same. In total, zero system support following features:</p> <ul> <li>Directly response with validation failure</li> <li>Defined message with validation failure</li> <li>Message template with validation failure.</li> </ul> <p>Another thing is that because zero system support restful completely, all the validation failure http status is 400, not 200, when you write some Ajax application, be careful that you have put callback codes in failure function instead of success function here. It's also the specification to implement standard HTTP Status.</p>"},{"location":"vertx-zero-tutorial/d10032-jsr303-defaultvalue-for-parameters/","title":"JSR303, @DefaultValue for parameters","text":"<p>There is another annotation that will be useful to be sure the default value for parameters. For example, you have defined a interface to get two parameters:</p> <ul> <li>page: The page index that you want to use in pagination</li> <li>size: The size of each page list.</li> </ul> <p>Sometimes, we must be sure these parameters have values to prevent broking the lower service code logical, in this kind of situation, if you haven't provide the values for both parameters, you can set the default values for these two parameters instead. This chapter will describe how to use default value for your application in zero system.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10032-jsr303-defaultvalue-for-parameters/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.DefaultValue;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class DefaultValueActor {\n@Path(\"notnull/default\")\n@GET\npublic String sayDefault(\n@DefaultValue(\"1\")\n@QueryParam(\"page\") final Integer page,\n@DefaultValue(\"20\")\n@QueryParam(\"size\") final Integer size\n) {\nreturn \"Hi, your default page = \" + page + \", size = \" + size;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10032-jsr303-defaultvalue-for-parameters/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/notnull/default</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": \"Hi, your default page = 1, size = 20\"\n}\n</code></pre> <p>URL : http://localhost:6083/api/jsr303/notnull/default?page=2</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": \"Hi, your default page = 2, size = 20\"\n}\n</code></pre> <p>URL : http://localhost:6083/api/jsr303/notnull/default?page=2&amp;size=15</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": \"Hi, your default page = 2, size = 15\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10032-jsr303-defaultvalue-for-parameters/#3-summary","title":"3. Summary","text":"<p>From above examples, you can set default value for different parameters, this default values will be used when the parameters are not provided by client request.</p>"},{"location":"vertx-zero-tutorial/d10033-jsr303-null-for-value/","title":"JSR303, @Null for value","text":"<p>From this chapter, zero system will introduce other annotations that belong to JSR303 for other validations, also we'll introduce Hibernate Validator specific annotation for some business requirements.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10033-jsr303-null-for-value/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Null;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class NullActor {\n@Path(\"null\")\n@GET\npublic String sayNull(\n@Null(message = \"Please do not provide value for username, it's system api\")\n@QueryParam(\"username\") final String username\n) {\nreturn \"Hi, this api is always running by \" + username;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10033-jsr303-null-for-value/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/null?username=Lang</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NullActor, method = public java.lang.String up.god.micro.validation.NullActor.sayNull(java.lang.String), message = Please do not provide value for username, it's system api.\",\n\"info\": \"Please do not provide value for username, it's system api\"\n}\n</code></pre> <p>URL : http://localhost:6083/api/jsr303/null</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": \"Hi, this api is always running by null\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10033-jsr303-null-for-value/#3-summary","title":"3. Summary","text":"<p>This annotation is not used often, but we still could discuss for <code>@Null</code> usage, because zero system implemented JSR303 with Hibernate Validator directly, here we only showed how to use JSR303 annotation to do business validation instead. The scenarios of <code>@Null</code> usage is exceed our tutorial topics.</p>"},{"location":"vertx-zero-tutorial/d10034-asserttrueassertfalse-for-boolean/","title":"JSR303, @AssertTrue/@AssertFalse for boolean","text":"<p>This chapter we will go though for boolean type, it must be <code>true/false</code> literal in your request, it could describe some useful request such as:</p> <ol> <li>Checkbox from UI</li> <li>Two status from UI, one for true and another for false.</li> </ol> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10034-asserttrueassertfalse-for-boolean/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.AssertFalse;\nimport javax.validation.constraints.AssertTrue;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class AssertActor {\n@Path(\"assert\")\n@GET\npublic String sayBoolean(\n@AssertTrue\n@QueryParam(\"male\") final Boolean isMale,\n@AssertFalse\n@QueryParam(\"female\") final Boolean isFemale) {\nreturn \"Hi, Lang, the parameters is 'male' = \" + isMale +\n\", 'female' = \" + isFemale;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10034-asserttrueassertfalse-for-boolean/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/assert</p> <p>Method : GET</p> <p>Response:</p> <pre><code>{\n\"data\": \"Hi, Lang, the parameters is 'male' = null, 'female' = null\"\n}\n</code></pre> <p>Because this example the query parameters 'male' and 'female' are not required, that's why here we could see two null values output. If we provide the parameters that could not be parsed to Boolean type, you'll get following response:</p> <pre><code>{\n\"code\": -60004,\n\"message\": \"[ERR-60004] (ZeroSerializer) Web Exception occus: (400) - Zero system detect conversation from \\\"test\\\" to type \\\"class java.lang.Boolean\\\", but its conflict.\"\n}\n</code></pre> <p>URL : http://localhost:6083/api/jsr303/assert?male=false</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.AssertActor, method = public java.lang.String up.god.micro.validation.AssertActor.sayAssert(java.lang.Boolean,java.lang.Boolean), message = must be true.\",\n\"info\": \"must be true\"\n}\n</code></pre> <p>Once we provide the parameter of male to 'false', it means that the validation rule will be triggered, in this kind of situation we could see the correct error messages.</p>"},{"location":"vertx-zero-tutorial/d10034-asserttrueassertfalse-for-boolean/#3-summary","title":"3. Summary","text":"<p>This chapter describe the usage of <code>@AssertTrue</code> and <code>@AssertFalse</code> in your code, it belong to JSR303 specification.</p>"},{"location":"vertx-zero-tutorial/d10035-jsr303-minmax-for-numeric/","title":"JSR303, @Min/@Max for numeric","text":"<p>This chapter we'll introduce the range of integer or long value for min/max limitation, it also belong to JSR303 specifications.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10035-jsr303-minmax-for-numeric/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Max;\nimport javax.validation.constraints.Min;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class NumericActor {\n@Path(\"numeric\")\n@GET\npublic String sayNum(\n@Min(10)\n@Max(100)\n@QueryParam(\"age\") final Integer age,\n@Min(1)\n@QueryParam(\"test\") final Integer test\n) {\nreturn \"Hello, please check your age. \" + age;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10035-jsr303-minmax-for-numeric/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/numeric?age=9</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NumericActor, method = public java.lang.String up.god.micro.validation.NumericActor.sayNum(java.lang.Integer,java.lang.Integer), message = must be greater than or equal to 10.\",\n\"info\": \"must be greater than or equal to 10\"\n}\n</code></pre> <p> URL : http://localhost:6083/api/jsr303/numeric?age=12&amp;test=-34</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.NumericActor, method = public java.lang.String up.god.micro.validation.NumericActor.sayNum(java.lang.Integer,java.lang.Integer), message = must be greater than or equal to 1.\",\n\"info\": \"must be greater than or equal to 1\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10035-jsr303-minmax-for-numeric/#3-summary","title":"3. Summary","text":"<p>Here we could see that the result is expected to limit number range.</p>"},{"location":"vertx-zero-tutorial/d10036-jsr303-decimalmindecimalmax-for-decimal/","title":"JSR303, @DecimalMin/@DecimalMax","text":"<p>Another range for decimal number, you should use <code>@DecimalMin/@DecimalMax</code> instead of <code>@Min/@Max</code>, these annotations could be used to parsing decimal, currency and float numbers.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10036-jsr303-decimalmindecimalmax-for-decimal/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.DecimalMax;\nimport javax.validation.constraints.DecimalMin;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class DecimalActor {\n@Path(\"decimal\")\n@GET\npublic String sayDecimal(\n@DecimalMin(\"0.3\")\n@QueryParam(\"min\") final Double min,\n@DecimalMax(\"0.7\")\n@QueryParam(\"max\") final Double max\n) {\nreturn \"Hi, min = \" + min + \", max = \" + max;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10036-jsr303-decimalmindecimalmax-for-decimal/#2-testing","title":"2. Testing","text":"<p> URL : http://localhost:6083/api/jsr303/decimal?min=0.1&amp;max=0.8</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.DecimalActor, method = public java.lang.String up.god.micro.validation.DecimalActor.sayDecimal(java.lang.Double,java.lang.Double), message = must be less than or equal to 0.7.\",\n\"info\": \"must be less than or equal to 0.7\"\n}\n</code></pre> <p>URL : http://localhost:6083/api/jsr303/decimal?min=0.1</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.DecimalActor, method = public java.lang.String up.god.micro.validation.DecimalActor.sayDecimal(java.lang.Double,java.lang.Double), message = must be greater than or equal to 0.3.\",\n\"info\": \"must be greater than or equal to 0.3\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10036-jsr303-decimalmindecimalmax-for-decimal/#3-summary","title":"3. Summary","text":"<p>For above examples, all the cases showed that the decimal validation have been triggered and you got the expected validation result as response described. If you provide correct parameters, you'll get following response:</p> <p>URL : http://localhost:6083/api/jsr303/decimal?min=0.5&amp;max=0.6</p> <pre><code>{\n\"data\": \"Hi, min = 0.5, max = 0.6\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10037-jsr303-size-usage/","title":"JSR303, @Size usage","text":"<p>This chapter we'll introduce another JSR303 annotations, it's for verifying the range by <code>@Size</code>.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10037-jsr303-size-usage/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Size;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class SizeActor {\n@Path(\"size\")\n@GET\npublic String saySize(\n@Size(min = 1, max = 20)\n@QueryParam(\"size\") final String size\n) {\nreturn \"Hi, Size = \" + size;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10037-jsr303-size-usage/#2-testing","title":"2. Testing","text":"<p> URL : http://localhost:6083/api/jsr303/size?size=silentbalanceyh@126.com</p> <p>Method :  GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.SizeActor, method = public java.lang.String up.god.micro.validation.SizeActor.saySize(java.lang.String), message = size must be between 1 and 20.\",\n\"info\": \"size must be between 1 and 20\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10037-jsr303-size-usage/#3-summary","title":"3. Summary","text":"<p>In this chapter we have seen the usage of <code>@Size</code> annotation, then we could move forward for next chapter for other annotations usage.</p>"},{"location":"vertx-zero-tutorial/d10038-jsr303-digits-for-decimal/","title":"JSR303, @Digits for decimal","text":"<p>This chapter focus on decimal again, except <code>@DecimalMin</code> and <code>@DecimalMax</code>, we also provide another validation for decimal details.</p> <ul> <li><code>@Digits</code>: this annotation contains two parts:<ul> <li>integer: it limit the integer part length;</li> <li>fraction: it limit the decimal part length after dot;</li> </ul> </li> </ul> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10038-jsr303-digits-for-decimal/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Digits;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class DigitActor {\n@Path(\"digit\")\n@GET\npublic String sayDigit(\n@Digits(integer = 2, fraction = 2)\n@QueryParam(\"digit\") final Double currency\n) {\nreturn \"Hi, Currency is \" + currency;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10038-jsr303-digits-for-decimal/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/digit?digit=140.22</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.DigitActor, method = public java.lang.String up.god.micro.validation.DigitActor.sayDigit(java.lang.Double), message = numeric value out of bounds (&lt;2 digits&gt;.&lt;2 digits&gt; expected).\",\n\"info\": \"numeric value out of bounds (&lt;2 digits&gt;.&lt;2 digits&gt; expected)\"\n}\n</code></pre> <p>If you provide correct parameter you should get following correct response:</p> <p>URL : http://localhost:6083/api/jsr303/digit?digit=40.22</p> <pre><code>{\n\"data\": \"Hi, Currency is 40.22\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10038-jsr303-digits-for-decimal/#3-summary","title":"3. Summary","text":"<p>This annotation is more correct to limit the decimal format include integer parts and decimal parts, then you could use this annotation to do some validation in your code.</p>"},{"location":"vertx-zero-tutorial/d10039-jsr303-future-past-for-date/","title":"JSR303, @Future/@Past for date","text":"<p>This chapter still belong to JSR303, we'll introduce the annotations to limit the date time range here.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10039-jsr303-future-past-for-date/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Future;\nimport javax.validation.constraints.Past;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\nimport java.util.Date;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class DateActor {\n@Path(\"date\")\n@GET\npublic String sayDate(\n@Future\n@QueryParam(\"to\") final Date future,\n@Past\n@QueryParam(\"from\") final Date past\n) {\nreturn \"Hi, Future = \" + future + \", Past = \" + past;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10039-jsr303-future-past-for-date/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/date?to=2017-09-11</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.DateActor, method = public java.lang.String up.god.micro.validation.DateActor.sayDate(java.util.Date,java.util.Date), message = must be a future date.\",\n\"info\": \"must be a future date\"\n}\n</code></pre> <p>URL : http://localhost:6083/api/jsr303/date?to=2018-09-11&amp;from=2018-04-01</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.DateActor, method = public java.lang.String up.god.micro.validation.DateActor.sayDate(java.util.Date,java.util.Date), message = must be a past date.\",\n\"info\": \"must be a past date\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10039-jsr303-future-past-for-date/#3-summary","title":"3. Summary","text":"<p>Then if you provide correct date values such as:</p> <p>http://localhost:6083/api/jsr303/date?to=2018-09-11&amp;from=2017-04-01</p> <p>You should get following correct response:</p> <pre><code>{\n\"data\": \"Hi, Future = Tue Sep 11 00:00:00 CST 2018, Past = Sat Apr 01 00:00:00 CST 2017\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10040-jsr303-pattern-for-regular-expression/","title":"JSR303, @Pattern for regular expression","text":"<p>This chapter will introduce the last annotation of JSR303.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10040-jsr303-pattern-for-regular-expression/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Pattern;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class PatternActor {\n@GET\n@Path(\"pattern\")\npublic String sayPattern(\n@Pattern(regexp = \"^lang[0-9]+$\")\n@QueryParam(\"pattern\") final String pattern\n) {\nreturn \"Hi, Pattern = \" + pattern;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10040-jsr303-pattern-for-regular-expression/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/pattern?pattern=lang.yu</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.PatternActor, method = public java.lang.String up.god.micro.validation.PatternActor.sayPattern(java.lang.String), message = must match \\\"^lang[0-9]+$\\\".\",\n\"info\": \"must match \\\"^lang[0-9]+$\\\"\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10040-jsr303-pattern-for-regular-expression/#3-summary","title":"3. Summary","text":"<p>If you provide valid value, you should get following correct response:</p> <p>URL : http://localhost:6083/api/jsr303/pattern?pattern=lang2</p> <pre><code>{\n\"data\": \"Hi, Pattern = lang2\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10041-jsr303-in-future-usage/","title":"JSR303, 2.x version","text":"<p>In current tutorial we have checked most of JSR303 annotation usage based on Hibernate Validator Framework. Here are some new annotations in JSR303.</p> <ul> <li>[x] <code>javax.validation.constraints.Email</code></li> <li>[x] <code>javax.validation.constraints.FutureOrPresent</code></li> <li>[x] <code>javax.validation.constraints.Negative</code></li> <li>[x] <code>javax.validation.constraints.NegativeOrZero</code></li> <li>[x] <code>javax.validation.constraints.NotBlank</code></li> <li>[x] <code>javax.validation.constraints.NotEmpty</code></li> <li>[x] <code>javax.validation.constraints.PastOrPresent</code></li> <li>[x] <code>javax.validation.constraints.Positive</code></li> <li>[x] <code>javax.validation.constraints.PositiveOrZero</code></li> </ul> <p>You can set above new annotations in 2.x version and validated by Hibernate Validator.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10041-jsr303-in-future-usage/#1-source-code","title":"1. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Email;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class EmailActor {\n@Path(\"email\")\n@GET\npublic String sayEmail(\n@Email\n@QueryParam(\"email\") final String email\n) {\nreturn \"Hi, email = \" + email;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10041-jsr303-in-future-usage/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/email?email=xxxx</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.EmailActor, method = public java.lang.String up.god.micro.validation.EmailActor.sayEmail(java.lang.String), message = must be a well-formed email address.\",\n\"info\": \"must be a well-formed email address\"\n}\n</code></pre> <p>If you changed the email parameter such as <code>lang.yu@hpe.com</code>, you can see following response:</p> <pre><code>{\n\"data\": \"Hi, email = lang.yu@hpe.com\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10041-jsr303-in-future-usage/#3-summary","title":"3. Summary","text":"<p>In total, zero system support most of JSR303 specification because it used Hibernate Validator to do it. Another feature that zero system provided is that it extend JSR303 and could verify the JsonObject/JsonArray format, you can move forward to study the next annotations.</p>"},{"location":"vertx-zero-tutorial/d10043-jsr303-pojo-first/","title":"JSR303, Pojo First","text":"<p>Because we go through the zero system advanced validation system for Json, let's see the Pojo validation first.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol>"},{"location":"vertx-zero-tutorial/d10043-jsr303-pojo-first/#1-source-code","title":"1. Source Code","text":"<p>Here we modified the pojo that we used in previous tutorials</p> <pre><code>package up.god.micro.async;\nimport lombok.Data;\nimport javax.validation.constraints.Email;\nimport javax.validation.constraints.Min;\nimport javax.validation.constraints.NotNull;\n@Data\npublic class JavaJson {\n@NotNull\nprivate String name;\n@Email\nprivate String email;\n@Min(1)\nprivate Integer age;\n}\n</code></pre> <p>And then we could set the validation for this object in your code</p> <pre><code>package up.god.micro.validation;\nimport com.google.gson.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport io.vertx.up.util.Jackson;\nimport up.god.micro.async.JavaJson;\nimport javax.validation.Valid;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class PojoActor {\n@Path(\"pojo\")\n@POST\npublic JsonObject sayPojo(\n@BodyParam @Valid final JavaJson json\n) {\nreturn Jackson.serializeJson(json);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10043-jsr303-pojo-first/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/pojo</p> <p>Method : POST</p> <p>Request:</p> <pre><code>{\n\"email\":\"lang.yu@hpe.com\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.PojoActor, method = public io.vertx.core.json.JsonObject up.god.micro.validation.PojoActor.sayPojo(up.god.micro.async.JavaJson), message = Not Null name.\",\n\"info\": \"must not be null\"\n}\n</code></pre> <p>Request :</p> <pre><code>{\n\"name\":\"Lang\",\n\"email\":\"lang.yu\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n\"code\": -60000,\n\"message\": \"[ERR-60000] (Validator) Web Exception occus: (400) - Request validation failure, class = class up.god.micro.validation.PojoActor, method = public io.vertx.core.json.JsonObject up.god.micro.validation.PojoActor.sayPojo(up.god.micro.async.JavaJson), message = must be a well-formed email address.\",\n\"info\": \"must be a well-formed email address\"\n}\n</code></pre> <p>Request :</p> <pre><code>{\n\"name\":\"Lang\",\n\"email\":\"lang.yu@126.com\",\n\"age\":33\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"Lang\",\n\"email\": \"lang.yu@126.com\",\n\"age\": 33\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10043-jsr303-pojo-first/#3-summary","title":"3. Summary","text":"<p>This tutorial described the usage of <code>@Valid</code> annotation for pojo validation, except this example pojo also support <code>message</code> attribute set and message template usage for properties files.</p>"},{"location":"vertx-zero-tutorial/d10043-zero-jsr303-body-validation/","title":"Zero JSR303, Body Validation","text":"<p>Zero system extend JSR303 specification and set another validation method for body validation especially for JSON format data validation. This tutorial describes how to use advanced validation for <code>JsonObject</code> in zero system.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul> <p>Rules:</p> <ol> <li>JSR303 is only supported in Agent component in zero system, it means that after you have send the message to event    bus, the JSR303 will be effectiveness.</li> <li>When you write the code with the Interface Style ( Will introduce in forward tutorials ), JSR303 will not support    this kind of situation.</li> <li>For @BodyParam, it also impact Agent component only, but could support Interface Style instead of JSR303 and could    provide more useful validations.</li> </ol> <p>Advanced Validation is supported by zero system in all styles ( JSR303 is not supported by interface style ). Here we'll use another new annotation that defined by zero system:</p> <ul> <li><code>io.vertx.up.annotations.Codex</code></li> </ul> <p>This annotation will tell zero system that there should be a codex up.god.file that bind to current request.</p>"},{"location":"vertx-zero-tutorial/d10043-zero-jsr303-body-validation/#1-configuration","title":"1. Configuration","text":"<p>Under your <code>src/main/resource</code> folder, there should be a folder named codex and all the codex files will be put here, then create a up.god.file named <code>api.jsr303.advanced.post.yml</code> , this up.god.file name should be <code>&lt;api&gt;.&lt;method&gt;</code> format, the content is as following:</p> <pre><code>username:\n- type: required\nmessage: \"Please input your username!\"\n- type: length\nmin: 6\nmessage: \"Your username length must be greater than 6\"\npassword:\n- type: required\nmessage: \"Please provide your password\"\n</code></pre>"},{"location":"vertx-zero-tutorial/d10043-zero-jsr303-body-validation/#2-source-code","title":"2. Source Code","text":"<pre><code>package up.god.micro.validation;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Codex;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api/jsr303\")\npublic class BodyActor {\n@POST\n@Path(\"/advanced\")\npublic JsonObject testCodex(\n@BodyParam @Codex final JsonObject user\n) {\nreturn user;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10043-zero-jsr303-body-validation/#3-testing","title":"3. Testing","text":"<p>URL : http://localhost:6083/api/jsr303/advanced</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"code\": -60005,\n\"message\": \"[ERR-60005] (RequiredRuler) Web Exception occus: (400) - Request body validation failure, field = username, value = null, message = Please input your username!.\",\n\"info\": \"Please input your username!\"\n}\n</code></pre> <p>Request :</p> <pre><code>{\n\"username\":\"Lang\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"code\": -60005,\n\"message\": \"[ERR-60005] (RequiredRuler) Web Exception occus: (400) - Request body validation failure, field = password, value = null, message = Please provide your password.\",\n\"info\": \"Please provide your password\"\n}\n</code></pre> <p>Request :</p> <pre><code>{\n\"username\":\"Lang\",\n\"password\":\"1111\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"code\": -60005,\n\"message\": \"[ERR-60005] (MinLengthRuler) Web Exception occus: (400) - Request body validation failure, field = username, value = Lang, message = Your username length must be greater than 6.\",\n\"info\": \"Your username length must be greater than 6\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10043-zero-jsr303-body-validation/#4-summary","title":"4. Summary","text":"<p>From above examples you have known how to use advanced codex validation for Json format data of <code>JsonObject</code> and now we provided following types of validation</p> <ul> <li>[x] required: ( message )</li> <li>[x] length: ( min, max, message )</li> <li>[x] minlength: ( min, message )</li> <li>[x] maxlength: ( max, message )</li> <li>[x] empty ( message ) ( For Collection checking )</li> <li>[x] singlefile ( message ) ( For Uploading checking, only one up.god.file valid )</li> </ul> <p>In future we'll provide more advanced codex for business requirements, it's defined by zero system for Json Data validation.</p>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/","title":"Zero Programming Styles","text":"<p>Until now we focus on code of zero system, this chapter will introduce some specifications that will be used in zero system include</p> <ul> <li>The roles in zero system.</li> <li>The code structure in zero system project.</li> <li>The name specifications in zero system.</li> </ul> <p>Demo projects:</p> <ul> <li>Standalone - 6083: <code>up-rhea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/#1-roles","title":"1. Roles","text":"<p>In zero system, we focus on three code areas:</p> <ul> <li>Agent Area ( Event Loop of vert.x ): You should develop the component Sender.</li> <li>Worker Area ( Worker Pool of vert.x ): You should develop the component Consumer.</li> <li>Service Layer: You should define service interface and implementation classes, actually this role should be ignored by   zero system because it's out of zero system managed scope.</li> </ul> <p>Http Request flow will go through zero system as following:</p> <pre><code>Api/IrApi -&gt; Sender ( Agent Area ) -&gt; ( Event Bus ) -&gt; Consumer ( Worker Area ) -&gt; Stub/Service ( Service Layer )\n</code></pre>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/#2-code-structure","title":"2. Code Structure","text":"<p>Here we introduce some code structures in zero real projects for developer/reader to do works.</p>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/#21-demo-structure","title":"2.1. Demo Structure","text":"<p>This style is not recommend in production environment because this style provide demo for you to study.</p> <ul> <li>XxxActor: The sender of zero system.</li> <li>XxxWorker: The consumer of zero system.</li> </ul>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/#22-standard-style","title":"2.2. Standard Style","text":"<p>This style is for you to do some common Crud works only, it should not contain complex query or search operations.</p> <ul> <li>XxxApi: The sender interface of zero system.</li> <li>XxxActor: The sender implementations of zero system.</li> <li>XxxWorker: The consumer of zero system.</li> <li>XxxStub/XxxService: The service interface &amp; implementation classes in service layer.</li> </ul>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/#23-splitting-style","title":"2.3. Splitting Style","text":"<p>This style is for you to do read/write splitting in your real projects, it should contain following role and operations:</p> <ul> <li>XxxIrApi: The sender interface of zero system that contain <code>query/search/read</code> operations;</li> <li>XxxIrActor: The sender implementations of zero system that inherit from XxxIrApi;</li> <li>XxxApi: The sender interface of zero system that contain <code>insert/update/delete/approval</code> operations;</li> <li>XxxActor : The sender implementations of zero system that inherit from XxxApi;</li> <li>XxxWorker : The consumer for two actors of zero system ( IrActor/Actor );</li> <li>XxxStub/XxxService : The service interface &amp; implementation classes in service layer.</li> </ul>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/#24-interface-style","title":"2.4. Interface Style","text":"<p>This style is often used and it's fast mode, this style ignored <code>Actor</code> in the codes and it's connected between Api and Worker only.</p> <ul> <li>XxxIrApi/XxxApi: The sender interface of zero system.</li> <li>XxxWorker: The consumer for two actors of zero system ( IrApi/Api ).</li> <li>XxxStub/XxxService : The service interface &amp; implementation classes in service layer.</li> </ul>"},{"location":"vertx-zero-tutorial/d10044-programming-styles/#3-name-specification","title":"3. Name Specification","text":"<p>This specification is provided to developers to do standard develop works in zero system, if you obey this rules that defined in current tutorial, you'll very luck to do this things more simpler.</p> <p>If your project name is <code>kys</code>, we could define the root package named <code>com.kys</code>, then you should provide following sub-packages for different usage:</p> <ul> <li>up.god.cv: Constant Value packages.</li> <li>exception: User-defined exception packages.</li> <li>micro: Your system modules for each micro business, all the subfolder should contains one style code files.</li> <li>domain : Domain model classes that defined in current business.</li> </ul> <p>The final package structure ( include codes ) should be as following examples:</p> <pre><code>com.kys.up.god.cv\n    - Addr.java\ncom.kys.exception\ncom.micro.a\n    - XxxApi\n    - XxxActor\n    - XxxWorker\n    - XxxStub\n    - XxxService\ncom.domain\n    - Xxx\n</code></pre> <p>The code name should be:</p> <ul> <li>Actor: The filename should end with Actor; the actor could inherit from api that end with Api or IrApi   , in interface style you can ignore Actor class component.</li> <li>Worker: The filename should end with Worker, this is standalone component.</li> <li>Stub/Service:  The Stub is interface and Service is implementation class.</li> </ul>"},{"location":"vertx-zero-tutorial/d10044-recommend-interface-mode-only/","title":"Interface Style","text":"<p>This chapter will introduce another coding style that zero system supported, we call it \"Interface Style\", be careful about this style for coding because it does not support JSR303, only Zero JSR303 could be supported by this style here. This chapter will introduce interface style for more details. In this chapter we focus on Api/Worker only.</p>"},{"location":"vertx-zero-tutorial/d10044-recommend-interface-mode-only/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10044-recommend-interface-mode-only/#11-api-code","title":"1.1. Api Code","text":"<pre><code>package up.god.micro.styles;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@EndPoint\n@Path(\"/api\")\npublic interface FacadeApi {\n@GET\n@Path(\"/facade\")\n@Address(\"ZERO://FACADE/STYLE\")\nString sayFacade(\n@QueryParam(\"style\") String style,\n@QueryParam(\"mode\") String mode\n);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10044-recommend-interface-mode-only/#12-worker-code","title":"1.2. Worker Code","text":"<pre><code>package up.god.micro.styles;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class FacadeWorker {\n@Address(\"ZERO://FACADE/STYLE\")\npublic Future&lt;JsonObject&gt; testFacade(final Envelop envelop) {\nfinal String arg0 = Ux.getString(envelop);\nfinal String arg1 = Ux.getString1(envelop);\nreturn Future.succeededFuture(new JsonObject()\n.put(\"style\", arg0)\n.put(\"mode\", arg1));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10044-recommend-interface-mode-only/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6083/api/facade?mode=Interface&amp;style=Lang</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"style\": \"Lang\",\n\"mode\": \"Interface\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10044-recommend-interface-mode-only/#3-summary","title":"3. Summary","text":"<p>Here we used Ux ( Belong to UtilityX package in zero system ), now you could ignore the Ux usage, we'll introduce in forward tutorials. In this demo there is no Actor to implement api interface, but we still could pass the data to worker thread to process it, that's why we call this style \"Interface Style\". It's useful in real projects because you' ll find that most situations, it's not needed to require Actor class to do some business logicals.</p>"},{"location":"vertx-zero-tutorial/d10046-utilityx-turn-on/","title":"Utility X Turn-On","text":"<p>From this chapter our tutorial will focus on the tool box that zero system provided, we call it Utility X, and in your code the class name is <code>io.vertx.up.unity.Ux</code>. The package name word <code>aiki</code> is Hausa language and it means \"Work\", this class will help the developers to process some duplicated works those are not related to business workflow. Here are three core parts in Utility X:</p> <ul> <li><code>io.vertx.up.unity.Ux</code>: The uniform tool class, it contains static method only. ( There is no object )</li> <li><code>io.vertx.up.atom.unity.Uson</code>: ( Data Structure ) The json container to store JsonObject and process it in \"   Stream Mode\", please refer <code>Rxjava</code> to know the \"Stream Mode\", it will process the JsonObject with multi Fluent   methods.</li> <li><code>io.vertx.up.atom.unity.Uarr</code>: ( Data Structure ) Another json container to store JsonArray and process it in \"   Stream Mode\".</li> </ul> <p>From this chapter we'll study Ux first because almost all the business codes will cover <code>Ux</code> style codes because it's more smartly and helpful. Now we'll move project to <code>vertx-up</code> and write some example codes in Unit Test Cases instead of major codes, but for some request flow codes we'll move to <code>up-thea</code>, it's under <code>vertx-zeus</code> project. You can know the rules for following tutorial:</p> <ol> <li>All the test cases should belong to <code>vertx-up</code>;</li> <li>Other testing codes of Utility X usage should belong to <code>up-thea</code>include some zero codes, this kind of codes    require Postman tool that you used in previous tutorials.</li> </ol>"},{"location":"vertx-zero-tutorial/d10046-utilityx-turn-on/#1-uson","title":"1. Uson","text":"<p>Hello world and hello utility x, this is code segments for some usage and you can ignore it first, we'll introduce all the utility x tool apis to be sure every developer could do less works in zero system.</p> <p>First create the input source up.god.file <code>d10046.json</code> in your testing resource folder <code>src/test/resources/test/io.vertx.up.unity</code>.</p> <pre><code>{\n\"username\": \"lang.yu\",\n\"password\": \"111111\",\n\"email\": \"silentbalanceyh@126.com\"\n}\n</code></pre> <p>Then create test case <code>D10046FirstTc</code>in your junit folders, in zero system all the test cases must contain valid suffix. Tc: means test case, Te: means test exception, you can configure your own name for testing cases but we still recommend to use <code>Tc/Te</code> as testing case name suffix.</p> <pre><code>package io.vertx.up.unity;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.quiz.TestBase;\nimport org.junit.Assert;\nimport org.junit.Test;\npublic class D10046FirstTc extends TestBase {\n@Test\npublic void testInput() {\nfinal JsonObject input = this.getJson(\"d10046.json\");\n// Uson usage\nfinal JsonObject ret = Uson.create(input)\n.convert(\"password\", \"updated\").to();\nSystem.err.println(ret.encodePrettily());\nAssert.assertEquals(\"111111\", ret.getString(\"updated\"));\n}\n}\n</code></pre> <p>This test case is very simple, here are some points that we need to refer:</p> <ol> <li>When you <code>extends</code> from <code>TestBase</code>, you can call the method <code>getJson/getArray</code> to read the resource files, this files    must be put in <code>src/test/resources/test/&lt;package-name&gt;</code> folder, these two methods are for <code>JsonObject/JsonArray</code>    reading, please check your data format first.</li> <li>We created a <code>Uson</code> object and then called <code>convert</code> api, finally we convert Uson back to JsonObject by <code>to()</code>    method.</li> </ol> <p>If you run this test case you should see following output, the field <code>password</code> has been converted to <code>updated</code>:</p> <pre><code>{\n\"username\" : \"lang.yu\",\n\"email\" : \"silentbalanceyh@126.com\",\n\"updated\" : \"111111\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10046-utilityx-turn-on/#2-uarr","title":"2. Uarr","text":"<p>Create new input up.god.file named <code>d10046-arr.json</code>, put into the same folder in chapter 1.</p> <pre><code>[\n{\n\"username\": \"lang.yu\",\n\"password\": \"111111\",\n\"email\": \"silentbalanceyh@126.com\"\n},\n{\n\"username\": \"lang.yu2\",\n\"password\": \"222222\",\n\"email\": \"silentbalanceyh@126.com\"\n}\n]\n</code></pre> <p>Then add new test method in <code>D10046FirstTc</code> class:</p> <pre><code>    @Test\npublic void testInputArr() {\nfinal JsonArray input = this.getArray(\"d10046-arr.json\");\n// Uson usage\nfinal JsonArray ret = Uarr.create(input)\n.convert(\"password\", \"updated\").to();\nSystem.err.println(ret.encodePrettily());\nAssert.assertEquals(\"111111\", ret.getJsonObject(0).getString(\"updated\"));\nAssert.assertEquals(\"222222\", ret.getJsonObject(1).getString(\"updated\"));\n}\n</code></pre> <p>Then you should see another message in your console as following:</p> <pre><code>[ {\n\"username\" : \"lang.yu\",\n\"email\" : \"silentbalanceyh@126.com\",\n\"updated\" : \"111111\"\n}, {\n\"username\" : \"lang.yu2\",\n\"email\" : \"silentbalanceyh@126.com\",\n\"updated\" : \"222222\"\n} ]\n</code></pre>"},{"location":"vertx-zero-tutorial/d10046-utilityx-turn-on/#3-ux","title":"3. Ux","text":"<p>The last examples should be Ux usage, it's not needed to create new files, we'll re-use <code>d10046.json</code> up.god.file:</p> <pre><code>    @Test\npublic void testUx() {\nfinal JsonObject input = this.getJson(\"d10046.json\");\nfinal Envelop envelop = Ux.to(input);\nAssert.assertNotNull(envelop.data());\nSystem.err.println(envelop.data(JsonObject.class));\n}\n</code></pre> <p>Here you could see the response in console:</p> <pre><code>{\"username\":\"lang.yu\",\"password\":\"111111\",\"mobile\":\"15922611447\",\"email\":\"silentbalanceyh@126.com\"}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10046-utilityx-turn-on/#4-summary","title":"4. Summary","text":"<p>The last example we'll convert the <code>JsonObject</code> to an Envelop object, why ? In zero system, envelop is uniform resource model and it could be used in many places such as:</p> <ul> <li>The communication between Agent ( Sender ) and Worker ( Consumer )</li> <li>Rpc communication between Service 1 and Service 2, this point will be introduces in Micro Part Tutorial.</li> <li>Third part tools communication</li> <li>The error response building and mount the normalized response data to your messages.</li> </ul>"},{"location":"vertx-zero-tutorial/d10047-utility-x-json-processinng/","title":"Utility X, JsonObject Processing","text":"<p>The first batch methods in Utility X is for Json Processing, these methods start with <code>to</code> .</p> <ul> <li><code>static &lt;T&gt; JsonObject toJson(T entity)</code></li> <li><code>static &lt;T&gt; JsonObject toJson(T entity, String pojo)</code></li> <li><code>static &lt;T&gt; JsonObject toJsonFun(T entity, Function&lt;JsonObject,JsonObject&gt; convert)</code></li> <li><code>static &lt;T&gt; T fromJson(JsonObject data, Class&lt;T&gt; clazz)</code></li> <li><code>static &lt;T&gt; T fromJson(JsonObject data, Class&lt;T&gt; clazz, String pojo)</code></li> <li><code>static JsonObject fromJson(JsonObjec data, String pojo)</code></li> </ul> <p>Above three methods could process the data type conversion of <code>io.vertx.core.json.JsonObject</code>. this chapter focus on these three methods usage. Before you do this testing, we'll create new Data Object for the type <code>T</code>.</p> <pre><code>package io.vertx.up.unity;\nimport java.io.Serializable;\npublic class D10047Obj implements Serializable {\nprivate String name;\nprivate String email;\nprivate Integer age;\nprivate boolean male;\npublic String getName() {\nreturn this.name;\n}\npublic void setName(final String name) {\nthis.name = name;\n}\npublic String getEmail() {\nreturn this.email;\n}\npublic void setEmail(final String email) {\nthis.email = email;\n}\npublic Integer getAge() {\nreturn this.age;\n}\npublic void setAge(final Integer age) {\nthis.age = age;\n}\npublic boolean isMale() {\nreturn this.male;\n}\npublic void setMale(final boolean male) {\nthis.male = male;\n}\n}\n</code></pre> <p>Then create the resource up.god.file <code>d10047.json</code>, the up.god.file content should be as following:</p> <pre><code>{\n\"name\": \"Lang\",\n\"email\": \"lang.yu@hpe.com\",\n\"age\": 32,\n\"male\": true\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10047-utility-x-json-processinng/#1-direct-to","title":"1. Direct To","text":"<p>This chapter focus on <code>toJson(T)</code> method for conversion between Data Object and Json Object. The testing code should be as following:</p> <pre><code>package io.vertx.up.unity;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.quiz.TestBase;\nimport io.vertx.up.util.Jackson;\nimport org.junit.Assert;\nimport org.junit.Test;\npublic class D10047Tc extends TestBase {\n@Test\npublic void testToJson() {\nfinal JsonObject data = this.getJson(\"d10047.json\");\nfinal D10047Obj obj = Jackson.deserialize(data, D10047Obj.class);\n// Convert\nfinal JsonObject result = Ux.toJson(obj);\nSystem.out.println(result.encodePrettily());\nAssert.assertEquals(4, result.fieldNames().size());\n}\n}\n</code></pre> <p>Here we could see that <code>Ux.toJson</code> method could convert a data object to JsonObject, it's useful when you want to do this conversion, because <code>JsonObject</code> is native data type that vert.x provided, zero system provide a way to do this conversion when you want to use your own data object. But we still recommend you use <code>JsonObject</code> instead of Data Object.</p>"},{"location":"vertx-zero-tutorial/d10047-utility-x-json-processinng/#2-mapping-to","title":"2. Mapping To","text":"<p>This chapter focus on <code>toJson(T,String)</code> method for conversion between Data Object and Json Object based on configuration files. Firstly you should create new configuration up.god.file:</p> <pre><code>type: \"io.vertx.up.unity.D10047Obj\"\nmapping:\nname: username\n</code></pre> <p>Above up.god.file should be  <code>src/test/resources/pojo/d10047.yml</code>, the filename is freedom. The configuration up.god.file contains two important attributes:</p> <ul> <li>type: This attribute should be full java class name, zero system will verify whether this class could be loaded.</li> <li>mapping: This attribute should be <code>key = value</code> for each line, it describes <code>from -&gt; to</code> conversion.</li> </ul> <p>Once you have finished the configuration, you could write following code:</p> <pre><code>    @Test\npublic void testToJsonMapping() {\nfinal JsonObject data = this.getJson(\"d10047.json\");\nfinal D10047Obj obj = Jackson.deserialize(data, D10047Obj.class);\n// Convert\nfinal JsonObject result = Ux.toJson(obj, \"d10047\");\nSystem.out.println(result.encodePrettily());\nAssert.assertEquals(4, result.fieldNames().size());\nAssert.assertEquals(\"Lang\", result.getString(\"username\"));\n}\n</code></pre> <p>Here you could see the console output:</p> <pre><code>{\n\"username\" : \"Lang\",\n\"email\" : \"lang.yu@hpe.com\",\n\"age\" : 32,\n\"male\" : true\n}\n</code></pre> <p>The field <code>name</code> has been converted to <code>username</code> instead of original and <code>name</code> field has been removed from generated JsonObject. Please be careful about this operation, it's single direction that you couldn't convert back to Data Object because some fields have been updated.</p>"},{"location":"vertx-zero-tutorial/d10047-utility-x-json-processinng/#3-mapping-dynamic","title":"3. Mapping Dynamic","text":"<p>This chapter focus on the last method <code>toJsonFun(T,Function)</code>, it's for conversion between Data Object and Json Object based on the function that you provided, it's for developer to provide an interface to do this conversion by user-defined.</p> <pre><code>    @Test\npublic void testToJsonFun() {\nfinal JsonObject data = this.getJson(\"d10047.json\");\nfinal D10047Obj obj = Jackson.deserialize(data, D10047Obj.class);\nfinal JsonObject result = Ux.toJsonFun(obj,\n(from) -&gt; from.put(\"username\", from.getString(\"email\")));\nAssert.assertEquals(result.getString(\"username\"),\nresult.getString(\"email\"));\n}\n</code></pre> <p>Here you could provide a function <code>Function&lt;JsonObject,JsonObject&gt;</code>, this function could help you to convert the original JsonObject to new one, you can define your own rules.</p>"},{"location":"vertx-zero-tutorial/d10047-utility-x-json-processinng/#4-direct-from","title":"4. Direct From","text":"<p>This chapter focus on <code>fromJson(JsonObject,Class&lt;T&gt;)</code>  method for conversion between Data Object and Json Object. The testing code should be as following:</p> <pre><code>    @Test\npublic void testFromJson() {\nfinal JsonObject data = this.getJson(\"d10047.json\");\nfinal D10047Obj obj = Ux.fromJson(data, D10047Obj.class);\nSystem.out.println(obj);\nAssert.assertNotNull(obj);\n}\n</code></pre> <p>This method is related to <code>toJson(T)</code>, the conversion direction is different only, here you should see following output in console</p> <pre><code>D10047Obj{name='Lang', email='lang.yu@hpe.com', age=32, male=true}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10047-utility-x-json-processinng/#5-mapping-from","title":"5. Mapping From","text":"<p>This method will involve the same mapping up.god.file:</p> <pre><code>type: \"io.vertx.up.unity.D10047Obj\"\nmapping:\nname: username\n</code></pre> <p>It's related to <code>toJson(T,String)</code>, also will use pojo up.god.file to do this conversion</p> <pre><code>    @Test\npublic void testFromJsonMapping() {\nfinal JsonObject data = this.getJson(\"d10047-mapping.json\");\nfinal D10047Obj obj = Ux.fromJson(data, D10047Obj.class, \"d10047\");\nSystem.out.println(obj);\nAssert.assertNotNull(obj);\n}\n</code></pre> <p>The same output will be seen in console as following:</p> <pre><code>D10047Obj{name='Lang', email='lang.yu@hpe.com', age=32, male=true}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10047-utility-x-json-processinng/#6-summary","title":"6. Summary","text":"<p>These three Apis are provided for following scenarios:</p> <ul> <li>If you used some ORM framework or some lightweight Mapping framework such as Hibernate, Mybatis, Jooq etc, you'll get   response data object from data access layer such Dao, Jdbc, but you want to provide normalized response to your   client, you can do this conversion by these three Apis.</li> <li>If you have an old system and you want to migrate to current framework, you can write some Adapter codes here to let   the Data Object could work in zero system, so you can migrate from original system to Micro Architecture more smartly.</li> <li>You can write some connector codes to do data mapping by these Apis.</li> </ul> <p>These three Apis came from real project of Video App that has been hosted by zero system, because we found it's widely used and just like re-using functions, then we extract these three apis from the projects and put into standard zero system.</p>"},{"location":"vertx-zero-tutorial/d10048-utility-x-pager-processing/","title":"Utility X, Pager Processing","text":"<p>In zero system, it provide normalized object to store pager information, it's name is <code>io.horizon.uca.qr.Pager</code>, this object could help you to do pagination. this object contains following apis for extract different metadata:</p> <ul> <li><code>getStart()</code>: Get the start index of current pager. ( ( page - 1 ) * size )</li> <li><code>getPage()</code>: Get total pages of current pager.</li> <li><code>getEnd()</code>: Get the end index of current page ( page * size ).</li> <li><code>getSize()</code>: Get the size of each page.</li> </ul> <p>The pagination parameters may came from http request query string, body or other place, in this kind of situation, the sender could take this place to do parameter normalization.</p> <p>In \"Interface Style\", the sender code is ignored, but in current chapter we need this sender class to do useful things.</p>"},{"location":"vertx-zero-tutorial/d10048-utility-x-pager-processing/#1-source-code","title":"1. Source Code","text":"<p>The code segment came from real projects instead of demos</p> <pre><code>package com.tlk.micro.comment;\nimport com.tlk.infra.up.god.cv.Addr;\nimport com.tlk.infra.up.god.cv.InValid;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Min;\nimport javax.ws.rs.DefaultValue;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@Path(\"/comments\")\n@EndPoint\npublic interface IrCommentApi {\n@GET\n@Path(\"/list\")\n@Address(Addr.COMMENTS_LIST_VIDEO)\nJsonObject list(\n@QueryParam(\"videoId\") final String videoId,\n@QueryParam(\"page\") @Min(value = 1, message = InValid.PAGE)\n@DefaultValue(\"1\") final Integer page,\n@QueryParam(\"size\") @Min(value = 1, message = InValid.SIZE)\n@DefaultValue(\"10\") final Integer size\n);\n}\n</code></pre> <p>Here we defined an interface to be annotated as EndPoint, here the parameters <code>page</code> and <code>size</code> came from query string and contains the default values. Then let's see how to use Utility X to process the pager parameters:</p> <pre><code>package com.tlk.micro.comment;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.fn.Fn;\npublic class IrCommentActor implements IrCommentApi {\n@Override\npublic JsonObject list(final String videoId,\nfinal Integer page,\nfinal Integer size) {\nfinal JsonObject params = new JsonObject();\nFn.safeNull(() -&gt; params.put(\"videoId\", videoId), videoId);\nparams.put(\"pager\", Ux.toPagerJson(page, size));\nreturn params;\n}\n}\n</code></pre> <p>In above examples we used the method <code>toPagerJson</code>, this method return value is not pager, but JsonObject instead, in this method, the Actor ( Sender ) has done following things:</p> <pre><code># request url -&gt; xxxxx?videoId=a&amp;page=1&amp;size=20\n# The converted data should be as following:\n{\n\"videoId\":a,\n    \"pager\":{\n\"size\":20,\n        \"page\":1\n    }\n}\n</code></pre> <p>Then the consumer could consume normalized Json data before it called service interfaces.</p> <p>In your worker you can do as following:</p> <pre><code>package com.tlk.micro.comment;\nimport com.tlk.eon.TargetType;\nimport com.tlk.infra.up.god.cv.Addr;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport io.vertx.tp.plugin.mongo.MongoReadOpts;\nimport javax.inject.Inject;\n@Queue\npublic class IrCommentWorker {\n@Inject\nprivate transient CommentStub stub;\n@Address(Addr.COMMENTS_LIST_VIDEO)\npublic void list(final Message&lt;Envelop&gt; message) {\nfinal JsonObject params = Ux.getBody(message);\nfinal String targetId = params.getString(\"videoId\");\nfinal JsonObject filter = new JsonObject()\n.put(\"targetId\", targetId)\n.put(\"targetType\", TargetType.VIDEO);\nthis.stub.query(filter, MongoReadOpts.toFull(\nUx.toPager(params.getJsonObject(\"pager\")),\nUx.toSorter(\"commentTime\", false))\n).setHandler(Ux.toHandler(message));\n}\n}\n</code></pre> <p>You can ignored the code logical details of this example, but here you could see we called: <code>toPager(JsonObject)</code> api to convert the params's pager node to valid Pager object.</p>"},{"location":"vertx-zero-tutorial/d10048-utility-x-pager-processing/#2-pager-apis","title":"2. Pager Apis","text":"<p>Actually zero system provide three standard pager related apis:</p> <ul> <li><code>static JsonObject toPagerJson(int page, int size)</code></li> <li><code>static Pager toPager(int page, int size)</code></li> <li><code>static Pager toPager(JsonObject json)</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10048-utility-x-pager-processing/#3-summary","title":"3. Summary","text":"<p>The pager object of <code>io.horizon.uca.qr.Pager</code> is defined by zero system and provide small interfaces to developer to do normalized Pager building, in this situation you can finish any kind of pagination in zero system instead of implement for each projects.</p>"},{"location":"vertx-zero-tutorial/d10049-utility-x-sorter-processing/","title":"Utility X, Sorter Processing","text":"<p>Another feature in zero system is that it provide the object <code>io.horizon.uca.qr.Sorter</code> to store sorting message in querying or searching operations. This class contains following useful apis:</p> <ul> <li><code>&lt;T&gt; JsonObject toJson(Function&lt;Boolean,T&gt; function)</code></li> <li><code>Sorter add(String field, Boolean asc)</code></li> <li><code>Sorter clear()</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10049-utility-x-sorter-processing/#1-introduction","title":"1. Introduction","text":"<p>For example, in some situations you'll write the code logical in SQL such as:</p> <pre><code>SELECT S_NAME, S_CODE FROM SEC_USER WHERE I_AGE &gt; 33 ORDER BY S_NAME DESC, S_EMAIL ASC\n</code></pre> <p>Here the segment from <code>S_NAME</code> means the sorting operations. Sorting operations contain two elements that you should know:</p> <ul> <li>mode: <code>ASC/DESC</code>, the sorting mode that for each field.</li> <li>priority: In the segment the priority of sorting fields should be in sequence, above SQL statement, <code>S_NAME</code> has   high priority.</li> </ul> <p>Zero system utility provide normalized method to process sorter as folllowing:</p> <ul> <li><code>static Sorter toSorter(String field, boolean asc)</code></li> <li><code>static Sorter toSorter(String field, int mode)</code></li> </ul> <p>There are some flags that you should know, for boolean parameter <code>asc</code>, it's very clear that no comments also make you understand this api, but for the int parameter <code>mode</code>, you should know:</p> <ul> <li>ASC mode: asc = true or mode &gt; 0 ( exclude 0 )</li> <li>DESC mode: asc = false or mode &lt;= 0 ( include 0 )</li> </ul>"},{"location":"vertx-zero-tutorial/d10049-utility-x-sorter-processing/#2-source-code","title":"2. Source Code","text":"<p>This chapter codes also came from real projects.</p> <pre><code>    @Address(Addr.TOPICS_SUBSCRIBE)\npublic void subscribe(final Message&lt;Envelop&gt; message) {\nfinal JsonObject pager = Ux.getBody(message);\nfinal JsonObject filter = new JsonObject().put(\"userId\", Extractor.getUserId(message));\nthis.subscribe.query(TargetType.TOPIC, filter, MongoReadOpts.toFull(\nUx.toPager(pager), Ux.toSorter(\"subscribeTime\", false) // Here order by subscribeTime DESC mode.\n)).setHandler(Ux.toHandler(message));\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10049-utility-x-sorter-processing/#3-summary","title":"3. Summary","text":"<p>From above demo you'll see <code>MongoReadOpts</code> class appeared, it's mongo db only, we'll introduce the <code>Mongo</code> usage in zero system in forward tutorials. Here you should know that following code impact the sorting operations:</p> <pre><code>Ux.toSorter(\"subscribeTime\", false)\n</code></pre>"},{"location":"vertx-zero-tutorial/d10050-utility-x-errors/","title":"Errors","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:e335ce354bd5e07b5fe7b3f68dc26ea31c9e5e454d41c4f551282cba52803e83 size 3771</p>"},{"location":"vertx-zero-tutorial/d10051-utility-x-jsonarrayunique-extract/","title":"Utility X, JsonArray/Unique Extract","text":"<p>This chapter we'll focus on JsonArray processing with Utility X. There are 6 major apis in <code>Ux</code> focus on list/collection/array processing.</p> <ul> <li><code>static &lt;T&gt; JsonArray toArray(List&lt;T&gt; list)</code></li> <li><code>static &lt;T&gt; JsonArray toArray(List&lt;T&gt; list, String pojo)</code></li> <li><code>static &lt;T&gt; JsonArray toArrayFun(List&lt;T&gt; list, Function&lt;JsonObject,JsonObject&gt; convert)</code></li> <li><code>static &lt;T&gt; JsonObject toUnique(List&lt;T&gt; list)</code></li> <li><code>static &lt;T&gt; JsonObject toUnique(List&lt;T&gt; list, String pojo)</code></li> <li><code>static &lt;T&gt; JsonObject toUnique(JsonArray array)</code></li> </ul> <p>Here we won't introduce the details for each one, but pick up some core points.</p> <ol> <li>For the 1st - 3rd methods, it's the same as JsonObject processing, the difference is that for JsonObject processing    the method callee is JsonObject, but current tutorial callee is JsonArray instead.</li> <li>For the <code>unique</code> extracting methods, it refer to some specific scenarios, we'll introduce in current tutorials.</li> </ol>"},{"location":"vertx-zero-tutorial/d10051-utility-x-jsonarrayunique-extract/#1-jsonarray","title":"1. JsonArray","text":"<p>Here are the test cases for <code>Ux.toArray</code> method:</p> <pre><code>package io.vertx.up.unity;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.quiz.TestBase;\nimport io.vertx.up.util.Jackson;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport java.util.List;\npublic class D10051Tc extends TestBase {\n@Test\npublic void testToJarray() {\nfinal JsonArray data = this.getArray(\"d10051.json\");\nfinal List&lt;D10051Obj&gt; obj = Jackson.deserialize(data, new TypeReference&lt;List&lt;D10051Obj&gt;&gt;() {\n});\n// Convert\nfinal JsonArray ret = Ux.toArray(obj, \"d10051\");\nSystem.err.println(ret.encode());\nAssert.assertEquals(2, ret.size());\n}\n}\n</code></pre> <p>Also in this test case you could see following output in console:</p> <pre><code>[{\"username\":\"Lang\",\"workEmail\":\"lang.yu@hpe.com\",\"age\":32,\"male\":true},\\\n{\"username\":\"Lang1\",\"workEmail\":\"lang.yu1@hpe.com\",\"age\":36,\"male\":false}]\n</code></pre>"},{"location":"vertx-zero-tutorial/d10051-utility-x-jsonarrayunique-extract/#2-tounique","title":"2. ToUnique","text":"<p>This method is very useful when you met following situations:</p> <p>Sometimes you got the data from database or other services, the return value is collection such as <code>List, Set, Collection or JsonArray</code> etc, but you have known that there is only one element in these collections, to resolve this kind of situation, we often write following code:</p> <pre><code>    .... final List&lt;T&gt; list = ...;\nreturn null != list &amp;&amp; !list.isEmpty() ? list.get(0): new ArrayList&lt;&gt;();\n</code></pre> <p>Then you can feel that above code is messing and to resolve this kind of issue ( We call it issue ), zero system provide the tools to extract the first element of the collection as the return value and did the pre-condition checking for you. You can add following code segment to your test case:</p> <pre><code>    @Test\npublic void testToUnique() {\nfinal JsonArray data = this.getArray(\"d10051.json\");\nfinal List&lt;D10051Obj&gt; obj = Jackson.deserialize(data, new TypeReference&lt;List&lt;D10051Obj&gt;&gt;() {\n});\n// Convert\nfinal JsonObject ret = Ux.toUnique(obj, \"d10051\");\nAssert.assertNotNull(ret);\nSystem.err.println(ret.encode());\n// Null returned\nfinal List&lt;D10051Obj&gt; nullfirst = new ArrayList&lt;&gt;();\nfinal JsonObject set = Ux.toUnique(nullfirst);\nAssert.assertNotNull(set);\nSystem.err.println(ret.encode());\n}\n</code></pre> <p>Then you'll found that there is no <code>NullPointerException</code> as well. For code defense you could put the code anywhere to do things.</p>"},{"location":"vertx-zero-tutorial/d10051-utility-x-jsonarrayunique-extract/#3-summary","title":"3. Summary","text":"<p>In real projects above three scenarios are very frequently and the small change could help developer be sure focus on business requirement only. It's the Utility X existing reason here.</p> <ul> <li>To be sure your code is strong.</li> <li>To be sure your code could execute in any exception situations with logs.</li> <li>To be sure your code has the testes of defense style.</li> </ul> <p>Zero system only focus on how to improve the code and fixed style, our style is not the best but it could help you save time.</p>"},{"location":"vertx-zero-tutorial/d10052-utility-x-user-data/","title":"Utility X, User Data","text":"<p>This chapter we'll discuss the user data in zero system, it used <code>vertx-auth-common</code> framework and the user data are stored into <code>User</code> object, our Utility X help you to extract data from <code>User</code> object instead you typed some duplicated code to get the data especially extract user id/config etc.</p> <p>Utility X provide following methods for you to get data from <code>User</code> object:</p> <ul> <li><code>static String getUserID(Message&lt;Envelop&gt; message, String field)</code></li> <li><code>static UUID getUserUUID(Message&lt;Envelop&gt; message, String field)</code></li> <li><code>static Object getSession(Message&lt;Envelop&gt; message, String field)</code></li> <li><code>static String getUserID(Envelop envelop, String field)</code></li> <li><code>static UUID getUserUUID(Envelop envelop, String field)</code></li> <li><code>static Object getSession(Envelop envelop, String field)</code></li> </ul> <p>Above methods could help you to extract data from the object of <code>User</code>. Here should be some comments to explain the method <code>getUserID</code>, this method is messing because the method name is not matching the feature that this method provided, but because of some reasons on existing system, we'll rename in future plans.</p> <p>Another thing is that about the first argument type: <code>Envelop</code> and <code>Message&lt;Envelop</code>, it's for different style that you used, the core points is that the pure type worker class could not use Utility X to get the data here, such as following:</p> <pre><code>@Address(\"ZERO://ASYNC/VERTX/FUTURE_T\")\npublic Future&lt;JsonObject&gt; sayFutureT(final JsonObject data) {\nfinal String string = data.encode();\nSystem.out.println(string);\ndata.put(\"result\", \"Perfect\");\nreturn Future.succeededFuture(data);\n}\n</code></pre> <p>Because above code could not get the uniform resource model <code>Envelop</code>, in this kind of situation you could not get the user information with above style, it's also why we recommend you to use uniform resource model instead of some user-defined types. There is one resolution for this situation:</p> <ol> <li>Write the code with <code>non-interface</code>  style and put the user information in your Sender.</li> <li>Then let Sender put the user data into the <code>Envelop</code> 's data part instead of extract information from <code>User</code>    directly.</li> </ol>"},{"location":"vertx-zero-tutorial/d10052-utility-x-user-data/#1-source-code","title":"1. Source Code","text":"<p>Because the Video App is before zero system, most of this app service used <code>void xxx(Message&lt;Envelop&gt;)</code> style instead of the latest Future style, but if you read current tutorials, it's very simple for you to convert to Future style.</p> <pre><code>public class Extractor{\n// .....\npublic static String getUserId(\nfinal Message&lt;Envelop&gt; message\n) {\nString userId = Ux.getUserID(message, ID.DB_KEY);\nif (StringUtil.isNil(userId)) {\nfinal Object uid = Ux.getSession(message, \"user\");\nuserId = (null == uid) ? null : uid.toString();\n}\nreturn userId;\n}\n// .....\n}\n</code></pre> <p>Above code is the method in Video app to extract user id from web request, here are the workflow:</p> <ol> <li>Try to get data from <code>Envelop</code>, if you enabled Authorization the user data came from http headers, because it's    running in mongo db, here <code>ID.DB_KEY</code> constant value is the mongo common id:    <pre><code>String DB_KEY = \"_id\";\n</code></pre></li> <li>Then if you could not get the user id, try to extract user id from session for secondary extracting.</li> </ol> <p>All the video app used above code to get user code as following:</p> <pre><code>    private void execute(final Message&lt;Envelop&gt; message,\nfinal TargetType type) {\nfinal JsonObject request = Ux.getJson(message);\n// Call the method to extract user id.\nfinal String userId = Extractor.getUserId(message);\nfinal JsonObject filter = new JsonObject();\n{\nfilter.put(\"targetId\", request.getValue(\"targetId\"));\nfilter.put(\"userId\", userId);\nfilter.put(\"targetType\", type);\n}\nfinal JsonObject data = applyData(message, type);\nfinal Future&lt;JsonObject&gt; future = this.revertStub.comment(filter, data, true);\nfuture.setHandler(Ux.toHandler(message));\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10052-utility-x-user-data/#2-uuid-for-specific","title":"2. UUID for specific","text":"<p>Another fast method provided by zero system Utility X tool is that the UUID converted from String such as following:</p> <pre><code>    @Address(Addr.TOPIC_ADD)\npublic void add(final Message&lt;Envelop&gt; message) {\nfinal Topic topic = Ux.getT(message, Topic.class);\ntopic.setOwnerId(Ux.getUserUUID(message, ID.DB_KEY));\ntopic.setId(UUID.randomUUID());\ntopic.setTitle(topic.getBrief());\ntopic.setAuditTime(new Date());\n// May contains exception.\nthis.stub.create(topic).setHandler(Ux.toHandler(message));\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10052-utility-x-user-data/#3-summary","title":"3. Summary","text":"<p>This chapter describes the user id extracting operations, it's very useful in many app, platform or application, it could identity the web request user's information from background instead of pass the user data in query string, body or other parts. It also could store user's status in restful application, that's why zero system designed this component. The user's information in <code>User</code> is JsonObject, it means that you could store many information into this object and it contains good extension.</p>"},{"location":"vertx-zero-tutorial/d10053-utility-x-normalized-response/","title":"Utility X, Normalized Response","text":"<p>This chapter we'll go through frequently used methods:</p> <ul> <li><code>static &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; toHandler(Message&lt;Envelop&gt; message)</code></li> <li><code>static &lt;T&gt; Handler&lt;AsyncResult&lt;T&gt;&gt; toHandler(Message&lt;Envelop&gt; message, JsonObject data)</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10053-utility-x-normalized-response/#1-design-principle","title":"1. Design Principle","text":"<p>Why we designed above two method in zero system, because we often met following situation:</p> <pre><code>public void worker(Message&lt;Envelop&gt; message){\n// MongoClient used\nclient.findOne(\"DB_TEST\",filters,null, res -&gt; {\n// Check result\nif(res.success()){\n// Null checking\nfinal JsonObject one = res.result();\nif(null != one){\nmessage.reply(Envelop.success(one));\n}else{\n// Exceptions\n}\n}else{\n// Exceptions\n}\n});\n}\n</code></pre> <p>If you used future mode, you still will met this kind of situations:</p> <pre><code>    @Address(Addr.TOPIC_ADD)\npublic void add(final Message&lt;Envelop&gt; message) {\nfinal Topic topic = Ux.getT(message, Topic.class);\ntopic.setOwnerId(Ux.getUserUUID(message, ID.DB_KEY));\ntopic.setId(UUID.randomUUID());\ntopic.setTitle(topic.getBrief());\ntopic.setAuditTime(new Date());\nthis.stub.create(topic).setHandler(handler -&gt; {\nif(handler.success()){\n// Correct  \n}else{\n// Exception \n}\n});\n}\n</code></pre> <p>Above two segments are not difficult, but we could know that the business logical only take one line, other lines are checking and validation response.</p>"},{"location":"vertx-zero-tutorial/d10053-utility-x-normalized-response/#2-luck-of-envelop","title":"2. Luck of Envelop","text":"<p>We consider how to resolve this issue for many times, especially for developers, one thing is that may be our design will brake your freedom, but it's not conflicts. Utility X is the tool box provided by zero system and it's optional, not require you use it in your project.</p> <p>If you used the api methods in current chapter, you can modified your code as following:</p> <pre><code>    @Address(Addr.TOPIC_ADD)\npublic void add(final Message&lt;Envelop&gt; message) {\nfinal Topic topic = Ux.getT(message, Topic.class);\ntopic.setOwnerId(Ux.getUserUUID(message, ID.DB_KEY));\ntopic.setId(UUID.randomUUID());\ntopic.setTitle(topic.getBrief());\ntopic.setAuditTime(new Date());\nthis.stub.create(topic).setHandler(Ux.toHandler(message));\n}\n</code></pre> <p>Here the method <code>Ux.toHandler</code> will process as following:</p> <ol> <li>Check whether success, if failed zero system will convert your Throwable object into <code>WebException</code> and replied to    client with normalized response format.</li> <li>Check the result of business, prevent the <code>NullPointerException</code> with the method.</li> </ol>"},{"location":"vertx-zero-tutorial/d10053-utility-x-normalized-response/#3-summary","title":"3. Summary","text":"<p>Above two apis are provided to developer to build normalized rest response instead of complex data structure, it may limit the developer to do some user-defined works, but it could let your system developed more faster and smartly to process errors. Base on our experience in Video App and Hotel Micro System, it saved much time to let us to code some <code>if-else</code> to be sure business correction.</p>"},{"location":"vertx-zero-tutorial/d10054-utility-x-input-agent-mode/","title":"Utility X Input, Agent Mode","text":"<p>Zero system support two different styles: Agent Mode / Interface Style, if we enable event bus we could see our web request will go through following workflow:</p> <p>Agent Mode</p> <pre><code>Api -&gt; Sender ( Agent Area ) -&gt; ( Event Bus ) -&gt; Consumer ( Worker Area )\n</code></pre> <p>Interface Style</p> <pre><code>Api -&gt; ( Event Bus ) -&gt; Consumer ( Worker Area )\n</code></pre>"},{"location":"vertx-zero-tutorial/d10054-utility-x-input-agent-mode/#1-zero-recommend","title":"1. Zero Recommend","text":"<p>Here are the problems: we have explained how to get data from client, but when you send the data to event bus, we could extract data from <code>Message&lt;Envelop&gt;</code> , <code>Envelop</code>, or use the Mode 5 Experimental extension to get data directly. But we still recommend to use <code>Envelop</code> instead, in this situation we need to read data to our expected, this chapter will tell you how to get input request data based on agent mode from EventBus. Based on this situation, we suggest developers obey following rules:</p> <ul> <li>Use uniform resource model instead of user defined types.</li> <li>Use Utility X tool package to get the input data.</li> </ul> <p>Zero system design is that to provide a framework to developer to do fast development, not only on the feature for business requirement, but also to provide some small tips. Then we focus on Agent Mode only.</p>"},{"location":"vertx-zero-tutorial/d10054-utility-x-input-agent-mode/#2-source-code","title":"2. Source Code","text":"<p>All the code segments came from real project of Video App</p>"},{"location":"vertx-zero-tutorial/d10054-utility-x-input-agent-mode/#21-api-definition","title":"2.1. Api definition","text":"<pre><code>package com.tlk.micro.comment;\nimport com.tlk.infra.up.god.cv.Addr;\nimport com.tlk.infra.up.god.cv.InValid;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.validation.constraints.Min;\nimport javax.ws.rs.DefaultValue;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.QueryParam;\n@Path(\"/comments\")\n@EndPoint\npublic interface IrCommentApi {\n@GET\n@Path(\"/list\")\n@Address(Addr.COMMENTS_LIST_VIDEO)\nJsonObject list(\n@QueryParam(\"videoId\") final String videoId,\n@QueryParam(\"page\") @Min(value = 1, message = InValid.PAGE)\n@DefaultValue(\"1\") final Integer page,\n@QueryParam(\"size\") @Min(value = 1, message = InValid.SIZE)\n@DefaultValue(\"10\") final Integer size\n);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10054-utility-x-input-agent-mode/#22-sender-code-actor","title":"2.2. Sender Code ( Actor )","text":"<pre><code>package com.tlk.micro.comment;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.fn.Fn;\npublic class IrCommentActor implements IrCommentApi {\n@Override\npublic JsonObject list(final String videoId,\nfinal Integer page,\nfinal Integer size) {\nfinal JsonObject params = new JsonObject();\nFn.safeNull(() -&gt; params.put(\"videoId\", videoId), videoId);\nparams.put(\"pager\", Ux.toPagerJson(page, size));\nreturn params;\n}\n}\n</code></pre> <p>Until now we could see that the Agent component contains <code>Api, Actor</code> codes and this component will get the request data to merge into <code>JsonObject</code>, it means that we'll send this JsonObject to event bus in <code>Envelop</code> object, in our code we only need to extract data from <code>Envelop</code>.</p>"},{"location":"vertx-zero-tutorial/d10054-utility-x-input-agent-mode/#23-consumer-code-worker","title":"2.3. Consumer Code ( Worker )","text":"<pre><code>package com.tlk.micro.comment;\nimport com.tlk.eon.TargetType;\nimport com.tlk.infra.up.god.cv.Addr;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport io.vertx.tp.plugin.mongo.MongoReadOpts;\nimport javax.inject.Inject;\n@Queue\npublic class IrCommentWorker {\n@Inject\nprivate transient CommentStub stub;\n@Address(Addr.COMMENTS_LIST_VIDEO)\npublic void list(final Message&lt;Envelop&gt; message) {\nfinal JsonObject params = Ux.getBody(message);\nfinal String targetId = params.getString(\"videoId\");\nfinal JsonObject filter = new JsonObject()\n.put(\"targetId\", targetId)\n.put(\"targetType\", TargetType.VIDEO);\nthis.stub.query(filter, MongoReadOpts.toFull(\nUx.toPager(params.getJsonObject(\"pager\")),\nUx.toSorter(\"commentTime\", false))\n).setHandler(Ux.toHandler(message));\n}\n}\n</code></pre> <p>From above code we could see that here we called <code>Ux.getBody</code> to extract the data from <code>Envelop</code> object, this method is fixed return type method, you could extract the data with type, please refer following chapters.</p>"},{"location":"vertx-zero-tutorial/d10054-utility-x-input-agent-mode/#3-summary","title":"3. Summary","text":"<p>Utility X provide the api to do this things as following:</p> <ul> <li><code>JsonObject getBody(Message&lt;Envelop&gt; message)</code></li> <li><code>&lt;T&gt; T getBodyT(Message&lt;envelop&gt; message, Class&lt;T&gt; clazz)</code></li> </ul> <p>There are two apis that could extract data from <code>Message&lt;Envelop&gt;</code> , one for JsonObject and it's also recommended by vert.x, another one for generic type and it's freedom usage.</p>"},{"location":"vertx-zero-tutorial/d10055-utility-x-interface-style/","title":"Input, Interface Style","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:20528c2d0607d5cd4333f6577f67e97d7bffcb54823524b1806acdc26d1df0d5 size 6366</p>"},{"location":"vertx-zero-tutorial/d10056-utility-x-rest/","title":"Basic Future","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:0601def2aa381674073a321d48850245adf9130a7b4329d8e2f819e7492b0fb8 size 5108</p>"},{"location":"vertx-zero-tutorial/d10057-utility-x-advanced-futures/","title":"Utility X, thenParallel","text":"<p>This chapter we'll start to focus on advanced future usage, here we'll list some real project problems and consider how to resolve this problem with Utility X tool in zero system.</p>"},{"location":"vertx-zero-tutorial/d10057-utility-x-advanced-futures/#1-parallel-futures","title":"1. Parallel Futures","text":"<p>We often meet some situations such as following:</p> <ol> <li>We have some videos in our project, you want to search all the videos, either it's uploaded by you or other users;</li> <li>When you get the video list, you want to know some additional status of each video.</li> <li>Then in the video list, we need a field named \"subscribed\" to record whether you have subscribed this video.</li> </ol> <p>In this situation, we have two tables: Video &amp; Subscription, and we want to get the video list, but each record should do the secondary query to check whether this video has been subscribed. Here are the Future for this kind of situation:</p> <p>This example is because in the project we used Mongo instead of SQL, there is no join statement and we need to mention that the api is not the best solution, but only introduce the api usage to tell you how to build the Future in zero.</p> <pre><code>static &lt;F, S, T&gt; Future&lt;List&lt;T&gt;&gt; thenParallel(\nfinal Future&lt;List&lt;F&gt;&gt; source, final Function&lt;F, Future&lt;S&gt;&gt; generateFun, final BiFunction&lt;F, S, T&gt; mergeFun\n)\n</code></pre> <p>The workflow for this api is as following:</p> <ol> <li>Query database and returned <code>Future&lt;List&lt;F&gt;&gt;</code>, in our situation, the F means Video.</li> <li>Provide function to generate another <code>Future&lt;S&gt;</code>, the function argument is the result of step 1, then this function    will impact each element of List&lt;F&gt;.</li> <li>When the secondary futures executed, it means that each F will generate <code>Future&lt;S&gt;</code> and get <code>S</code>, the last <code>mergeFun</code>    will let you process <code>F, S</code> to <code>T</code> and returned <code>Future&lt;List&lt;T&gt;&gt;</code></li> </ol>"},{"location":"vertx-zero-tutorial/d10057-utility-x-advanced-futures/#2-explain-workflow","title":"2. Explain Workflow","text":"<p>The workflow of this api is as following:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10057-utility-x-advanced-futures/#3-summary","title":"3. Summary","text":"<p>This api is a little complex because it provide parallel operations on <code>List</code> and generate new <code>List</code>, in above workflow the F is the video, we could use video to generate each subscription record that belong to yourself, then each element will be executed to build the result <code>T</code>, The last result <code>List&lt;T&gt;</code> contains the video list with additional field \" subscribed\" that tell you that whether you have subscribed the video. </p>"},{"location":"vertx-zero-tutorial/d10058-utility-x-thenparallelarrayjson/","title":"Utility X, thenParallelArray/Json","text":"<p>We have known that Utility X provide the api <code>thenParallel</code> for parallel usage, this chapter we'll introduce some fixed data type such as JsonArray and JsonObject, both data types are frequently used in vert.x</p> <p>The api definition is as following:</p> <pre><code>static Future&lt;JsonArray&gt; thenParallelArray(\nfinal Future&lt;JsonArray&gt; source, final Function&lt;JsonObject, Future&lt;JsonObject&gt;&gt; generateFun, final BinaryOperator&lt;JsonObject&gt; operatorFun)\nstatic Future&lt;JsonObject&gt; thenParallelArray(\nfinal Future&lt;JsonArray&gt;... sources)\nstatic Future&lt;JsonObject&gt; thenParallelJson(\nfinal Future&lt;JsonObject&gt; source, final Function&lt;JsonObject, List&lt;Future&gt;&gt; generateFun, final BiConsumer&lt;JsonObject, JsonObject&gt;... operatorFun)\nstatic Future&lt;JsonObject&gt; thenParallelJson(\nfinal JsonObject source, final Function&lt;JsonObject, List&lt;Future&gt;&gt; generateFun, final BiConsumer&lt;JsonObject, JsonObject&gt;... operatorFun)\n</code></pre> <p>There are four new apis for parallel Future building, now we'll explain the usage with real codes</p>"},{"location":"vertx-zero-tutorial/d10058-utility-x-thenparallelarrayjson/#1-source-code","title":"1. Source Code","text":"<p>The codes came from real project of Micro Hotel Platform</p>"},{"location":"vertx-zero-tutorial/d10058-utility-x-thenparallelarrayjson/#11-thenparallelarray","title":"1.1. thenParallelArray","text":"<p>This function is the same as <code>thenParallel</code> that we met in previous tutorial, but it's not generic java type, but JsonObject and JsonArray instead:</p> <pre><code>    public Future&lt;JsonArray&gt; payterms(final String sigma) {\nreturn Ux.thenParallelArray(\nthis.findPayterms(sigma),\nthis.findCats(sigma)\n).compose(item -&gt; {\n// Two table data.\nfinal JsonArray payterms = item.getJsonArray(\"0\");\nfinal JsonArray categories = item.getJsonArray(\"1\");\n// Zip two json array\nfinal JsonArray result = Uarr.create(payterms)\n.zip(categories, \"category\", \"key\")\n.to();\nreturn Future.succeededFuture(result);\n});\n}\n</code></pre> <p>Here you should know one thing is that the result of <code>Future&lt;JsonObject&gt;</code> should contains different <code>JsonArray</code>, you can refer each JsonArray by index such as the code <code>item.getJsonArray(\"0\")</code>.</p>"},{"location":"vertx-zero-tutorial/d10058-utility-x-thenparallelarrayjson/#12-thenparalleljson","title":"1.2. thenParallelJson","text":"<p>The secondary function is <code>thenParallelJson</code>, you can refer following code segments to check the usage:</p> <pre><code>    public Future&lt;JsonObject&gt; findById(final Long id) {\nreturn Ux.Jooq.on(HtlHotelDao.class)\n.&lt;HtlHotel&gt;fetchOneAsync(\"PK_ID\", id)\n.compose(hotel -&gt; Ux.thenJsonOne(hotel, \"hotel\"))\n.compose(item -&gt; Ux.thenParallelJson(item,\n(hotel) -&gt; Arrays.asList(this.findLocation(hotel)),\n// Calculation Function\n(target, source) -&gt; target.put(\"locationId\", source)\n));\n}\n</code></pre> <p>Here we get the object of <code>Hotel</code> as item and then use the item to find the related records <code>Location</code>, finally we put the Location data into <code>hotel</code> and set to <code>locationId</code>. The whole logical should be as following:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10058-utility-x-thenparallelarrayjson/#2-summary","title":"2. Summary","text":"<p>From above workflow explain, you should know that this function is very helpful when you need more additional database access here. In our project, we removed foreign key and used Jooq, to avoid complex duplicated codes, zero system provide the api for you to resolve this kind situation.</p>"},{"location":"vertx-zero-tutorial/d10059-utility-x-thenscatterjson/","title":"Utility X, thenScatterJson","text":"<p>This function is standalone and also very useful when you met some strong business requirements. This api is as following definition:</p> <pre><code>static Future&lt;JsonArray&gt; thenScatterJson(\nfinal Future&lt;JsonArray&gt; source, final Function&lt;JsonObject, Future&lt;JsonArray&gt;&gt; generateFun, final BiFunction&lt;JsonObject, JsonArray, JsonObject&gt; mergeFun)\n</code></pre>"},{"location":"vertx-zero-tutorial/d10059-utility-x-thenscatterjson/#1-source-code","title":"1. Source Code","text":"<p>This function is used in Video App, the source code is as following:</p> <pre><code>    @Override\npublic Future&lt;JsonArray&gt; query(\nfinal String userId,\nfinal JsonObject filter,\nfinal FindOptions options,\nfinal boolean video) {\nfinal Future&lt;JsonArray&gt; topicFuture = Ux.Mongo.findWithOptions(Topic.TABLE, filter, options,\n// Join another table to visit subscription table\nSubscription.TABLE, \"targetId\", Extractor.getAdditional(userId, TargetType.TOPIC),\n// Return merged.\nExtractor.setSubscribed(userId));\nreturn (video) ? Ux.thenScatterJson(topicFuture,\nthis::findVideos, (source, result) -&gt; source.put(\"videoItems\", result))\n.compose(item -&gt; Future.succeededFuture(\nUarr.create(item)\n.convert(ID.DB_KEY, ID.UI_KEY)\n.to()\n)) : topicFuture\n.compose(item -&gt; Future.succeededFuture(\nUarr.create(item)\n.convert(ID.DB_KEY, ID.UI_KEY)\n.to()));\n}\n</code></pre> <p>In above code, we used scatter method to do secondary query from mongo db.</p>"},{"location":"vertx-zero-tutorial/d10059-utility-x-thenscatterjson/#2-workflow","title":"2. Workflow","text":"<p>The code logical is as following:</p>"},{"location":"vertx-zero-tutorial/d10059-utility-x-thenscatterjson/#3-summary","title":"3. Summary","text":"<p>Actually this code flow is the same as thenParallel, but the operated object is fixed type. JO means JsonObject, JA means JsonArray. There are some histories of this function because it's born earlier than <code>thenParallel</code>, this function is more useful because in vert.x the JsonArray and JsonObject is frequently used. That's why we still keep this function in Utility X tool. Based on our experience, this function is more frequently used than <code>thenParallel</code>, so we recommend the developer use this function first as parallel in priority.</p>"},{"location":"vertx-zero-tutorial/d10060-utility-x-thenerror/","title":"Utility X, thenError","text":"<p>Zero system provide normalized way to build <code>WebException</code> Future, you can use the apis in current tutorial to process the response. The apis definition should be as following:</p> <pre><code>static &lt;T, R&gt; Future&lt;R&gt; thenError(\nfinal Future&lt;Boolean&gt; condition, final Supplier&lt;Future&lt;T&gt;&gt; trueFuture, final Function&lt;T, R&gt; trueFun, final Class&lt;? extends WebException&gt; clazz, final Object... args)\nstatic Future&lt;JsonObject&gt; thenError(\nfinal Future&lt;Boolean&gt; condition, final Supplier&lt;Future&lt;JsonObject&gt;&gt; trueFuture, final Class&lt;? extends WebException&gt; clazz, final Object... args)\nstatic &lt;T&gt; Future&lt;T&gt; thenError(\nfinal Class&lt;? extends WebException&gt; clazz, final Object... args)\n</code></pre>"},{"location":"vertx-zero-tutorial/d10060-utility-x-thenerror/#1-source-code","title":"1. Source Code","text":"<p>Source Code came from Video App</p> <pre><code>    public Function&lt;SecUser, Future&lt;JsonObject&gt;&gt; response(\nfinal String username,\nfinal String password,\nfinal Function&lt;SecUser, Future&lt;JsonObject&gt;&gt; future) {\nreturn pojo -&gt; {\nif (null == pojo) {\n// User does not exist\nthis.logger.info(\"[ Auth ] username/id = {0} does not exist.\", username);\nreturn Ux.thenError(UserNotFoundException.class, this.clazz, username);\n} else if (!password.equals(pojo.getSPassword())) {\n// Password wrong\nthis.logger.info(\"[ Auth ] username/id = {0}, password is wrong {1}.\", username, password);\nreturn Ux.thenError(PasswordWrongException.class, this.clazz, username);\n} else {\n// Continue because of success\nthis.logger.info(\"[ Auth ] User ( username/id = {0} ) login successfully.\", username);\nreturn future.apply(pojo);\n}\n};\n}\n</code></pre> <p>Above function finished the task as:</p> <ul> <li>If returned <code>SecUser</code> pojo is null, reply to client <code>UserNotFoundException</code> Future.</li> <li>If the password is not match, reply to client <code>PasswordWrongException</code> Future.</li> </ul>"},{"location":"vertx-zero-tutorial/d10060-utility-x-thenerror/#2-summary","title":"2. Summary","text":"<p>Except direct to build standard <code>WebException</code> Future as example showed, there left two other apis to build conditional error Future, based on the arguments, you should know following workflow:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10061-jooqmysql-configuration/","title":"Jooq/Mysql, Configuration","text":"<p>From this chapter we started to introduce Jooq in zero system, move to <code>up-thea</code> demo project for Mysql, because you start this tutorial, you should prepare the environment:</p> <ul> <li>Be sure you have installed local database MySQL 5.7</li> <li>Modify the mysql database user <code>root</code> password to <code>root</code></li> </ul> <p>Then you can pull the source codes from zero github, when you enter to <code>up-thea</code> project, you should see the folder structure under <code>tool</code> as following:</p> <p></p> <p>This folder contains two parts:</p> <ol> <li>jooq: This folder contains jooq generation tool include xml configuration, jar dependency and generation shell</li> <li>sql: This folder contains database sql script and database building shell.</li> </ol>"},{"location":"vertx-zero-tutorial/d10061-jooqmysql-configuration/#1-environment-preparing","title":"1. Environment Preparing","text":"<p>You can see the content of <code>sql/build-db.sh</code> as following:</p> <pre><code>#!/usr/bin/env bash\nmysql -uroot -proot &lt; generator-table.sql\nmysql -uroot -proot &lt; generator-data.sql\necho '[ZERO] Database has been initialized successfully.'\n</code></pre> <p>Here are two sql scripts and you can execute them with <code>root/root</code>. Here we'll ignore the <code>generator-data.sql</code> and focus on <code>generator-table.sql</code> only, the script could help us to create demo table structure, this table will be used in all the demos in current tutorials. The script content is as following:</p> <pre><code>CREATE DATABASE IF NOT EXISTS DB_ZERO\nDEFAULT CHARSET utf8mb4\nCOLLATE utf8mb4_bin;\nUSE DB_ZERO;\nSET NAMES 'UTF8';\n-- ----------------------------\n-- Table Purging\n-- ----------------------------\nDROP TABLE IF EXISTS `SYS_TABULAR`;\nCREATE TABLE `SYS_TABULAR` (\n`PK_ID`         BIGINT(20)                      NOT NULL AUTO_INCREMENT\nCOMMENT 'uniqueId,PK_ID',\n`T_COMMENT`     TEXT COLLATE utf8mb4_bin COMMENT 'comment,T_COMMENT',\n`S_NAME`        VARCHAR(64) COLLATE utf8mb4_bin NOT NULL\nCOMMENT 'name,S_NAME',\n`S_CODE`        VARCHAR(36) COLLATE utf8mb4_bin          DEFAULT NULL\nCOMMENT 'code,S_CODE',\n`S_SERIAL`      VARCHAR(64) COLLATE utf8mb4_bin          DEFAULT NULL\nCOMMENT 'serial,S_SERIAL',\n`S_TYPE`        VARCHAR(32) COLLATE utf8mb4_bin NOT NULL\nCOMMENT 'The tabular comments,type,S_TYPE',\n`J_CONFIG`      TEXT COLLATE utf8mb4_bin COMMENT 'config,J_CONFIG',\n`I_ORDER`       INT(11)                         NOT NULL\nCOMMENT 'order,I_ORDER',\n`IS_ACTIVE`     TINYINT(1)                               DEFAULT NULL\nCOMMENT 'active,IS_ACTIVE',\n`Z_SIGMA`       VARCHAR(32) COLLATE utf8mb4_bin          DEFAULT NULL\nCOMMENT 'sigma,Z_SIGMA',\n`Z_LANGUAGE`    VARCHAR(8) COLLATE utf8mb4_bin           DEFAULT NULL\nCOMMENT 'language,Z_LANGUAGE',\n`Z_CREATE_BY`   VARCHAR(36) COLLATE utf8mb4_bin          DEFAULT NULL\nCOMMENT 'createBy,Z_CREATE_BY',\n`Z_CREATE_TIME` DATETIME                                 DEFAULT NULL\nCOMMENT 'createTime,Z_CREATE_TIME',\n`Z_UPDATE_BY`   VARCHAR(36) COLLATE utf8mb4_bin          DEFAULT NULL\nCOMMENT 'updateBy,Z_UPDATE_BY',\n`Z_UPDATE_TIME` DATETIME                                 DEFAULT NULL\nCOMMENT 'updateTime,Z_UPDATE_TIME',\nPRIMARY KEY (`PK_ID`),\nUNIQUE KEY `UK_SYS_TABULAR_S_CODE_S_TYPE_Z_SIGMA_Z_LANGUAGE` (`S_CODE`, `S_TYPE`, `Z_SIGMA`, `Z_LANGUAGE`)\n)\nENGINE = InnoDB\nAUTO_INCREMENT = 169\nDEFAULT CHARSET = utf8mb4\nCOLLATE = utf8mb4_bin;\n</code></pre>"},{"location":"vertx-zero-tutorial/d10061-jooqmysql-configuration/#2-jooq-configuration","title":"2. Jooq Configuration","text":"<p>Once you have prepared the sql database environment, you can move to jooq configuration part, first you can check xml configuration:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;\n&lt;configuration&gt;\n&lt;!-- Configure the database connection here --&gt;\n&lt;jdbc&gt;\n&lt;driver&gt;com.mysql.cj.jdbc.Driver&lt;/driver&gt;\n&lt;url&gt;\n&lt;![CDATA[ jdbc:mysql://127.0.0.1:3306/DB_ZERO?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;useSSL=false&amp;allowPublicKeyRetrieval=true ]]&gt;\n&lt;/url&gt;\n&lt;username&gt;htl&lt;/username&gt;\n&lt;password&gt;pl,okmijn123&lt;/password&gt;\n&lt;/jdbc&gt;\n&lt;generator&gt;\n&lt;name&gt;io.github.jklingsporn.vertx.jooq.generate.future.FutureVertxGenerator&lt;/name&gt;\n&lt;database&gt;\n&lt;!--force generating id'sfor everything in public schema, that has an 'id' field--&gt;\n&lt;syntheticPrimaryKeys&gt;public\\..*\\.id&lt;/syntheticPrimaryKeys&gt;\n&lt;!--name for fake primary key--&gt;\n&lt;overridePrimaryKeys&gt;override_primmary_key&lt;/overridePrimaryKeys&gt;\n&lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;\n&lt;includes&gt;(^SYS.*)&lt;/includes&gt;\n&lt;inputSchema&gt;DB_ZERO&lt;/inputSchema&gt;\n&lt;unsignedTypes&gt;false&lt;/unsignedTypes&gt;\n&lt;forcedTypes&gt;\n&lt;!-- Convert tinyint to boolean --&gt;\n&lt;forcedType&gt;\n&lt;name&gt;BOOLEAN&lt;/name&gt;\n&lt;types&gt;(?i:TINYINT)&lt;/types&gt;\n&lt;/forcedType&gt;\n&lt;!-- Convert varchar column with name 'someJsonObject' to a io.vertx.core.json.JsonObject--&gt;\n&lt;forcedType&gt;\n&lt;userType&gt;io.vertx.core.json.JsonObject&lt;/userType&gt;\n&lt;converter&gt;io.github.jklingsporn.vertx.jooq.shared.JsonObjectConverter\n                    &lt;/converter&gt;\n&lt;expression&gt;ZeroJsonObject&lt;/expression&gt;\n&lt;types&gt;.*&lt;/types&gt;\n&lt;/forcedType&gt;\n&lt;!-- Convert varchar column with name 'someJsonArray' to a io.vertx.core.json.JsonArray--&gt;\n&lt;forcedType&gt;\n&lt;userType&gt;io.vertx.core.json.JsonArray&lt;/userType&gt;\n&lt;converter&gt;io.github.jklingsporn.vertx.jooq.shared.JsonArrayConverter\n                    &lt;/converter&gt;\n&lt;expression&gt;ZeroJsonArray&lt;/expression&gt;\n&lt;types&gt;.*&lt;/types&gt;\n&lt;/forcedType&gt;\n&lt;/forcedTypes&gt;\n&lt;/database&gt;\n&lt;generate&gt;\n&lt;daos&gt;true&lt;/daos&gt;\n&lt;pojos&gt;true&lt;/pojos&gt;\n&lt;javaTimeTypes&gt;true&lt;/javaTimeTypes&gt;\n&lt;interfaces&gt;true&lt;/interfaces&gt;\n&lt;fluentSetters&gt;true&lt;/fluentSetters&gt;\n&lt;/generate&gt;\n&lt;target&gt;\n&lt;packageName&gt;up.god.domain&lt;/packageName&gt;\n&lt;directory&gt;../../src/main/java&lt;/directory&gt;\n&lt;/target&gt;\n&lt;strategy&gt;\n&lt;name&gt;io.github.jklingsporn.vertx.jooq.generate.future.FutureGeneratorStrategy\n            &lt;/name&gt;\n&lt;/strategy&gt;\n&lt;/generator&gt;\n&lt;/configuration&gt;\n</code></pre> <p>All above content is jooq configuration, here you should focus on some points of this up.god.file:</p> <p>1 - The driver of mysql that will be used in your application, because we used the mysql driver version more than 8.x, it means that you should use <code>com.mysql.cj.jdbc.Drvier</code>:</p> <pre><code>&lt;driver&gt;com.mysql.cj.jdbc.Driver&lt;/driver&gt;\n</code></pre> <p>2 - The url of mysql should be put into <code>&lt;url&gt;</code> xml node as following, because you may use some parameters of mysql in url, you should use <code>&lt;![CDATA[ ]]&gt;</code> to wrapper your content.</p> <pre><code>&lt;url&gt;\n&lt;![CDATA[ ...... ]]&gt;\n&lt;/url&gt;\n</code></pre> <p>3 - Then you can set your <code>username</code>  and <code>password</code> in your configuration up.god.file:</p> <pre><code>        &lt;username&gt;htl&lt;/username&gt;\n&lt;password&gt;pl,okmijn123&lt;/password&gt;\n</code></pre> <p>4 - You can set your table scanning policy as following:</p> <pre><code>            &lt;includes&gt;(^SYS.*)&lt;/includes&gt;\n&lt;inputSchema&gt;DB_ZERO&lt;/inputSchema&gt;\n</code></pre> <ul> <li>inputSchema: the database name that you used in the demo, here are <code>DB_ZERO</code>.</li> <li>includes: The pattern for scanning the database tables, here the pattern means The table name start with SYS, our   table name is <code>SYS_TABULR</code>_. _</li> </ul> <p>5 - The last part is pojo configuration as following:</p> <pre><code>&lt;packageName&gt;up.god.domain&lt;/packageName&gt;\n&lt;directory&gt;../../src/main/java&lt;/directory&gt;\n</code></pre> <p>The configuration for java class package name <code>up.god.domain</code> and the java up.god.file output folder <code>../../src/main/java</code>, in zero system you can keep other xml configuration part because it's normalized by our real projects. Once you have configured the jooq xml configuration, you can run shell as following:</p> <pre><code>#!/usr/bin/env bash\njava -classpath jooq-3.10.3.jar:jooq-meta-3.10.3.jar:jooq-codegen-3.10.3.jar:\\\n    mysql-connector-java-8.0.8-dmr.jar:vertx-jooq-shared-2.4.1.jar:\\\n    vertx-jooq-generate-2.4.1.jar:vertx-jooq-future-2.4.1.jar \\\n    org.jooq.util.GenerationTool ./config/generator.xml\n</code></pre> <p>After the shell executed, you can see the generated java source up.god.file under <code>src/main/java/</code> .</p>"},{"location":"vertx-zero-tutorial/d10061-jooqmysql-configuration/#3-jooq-application-configuration","title":"3. Jooq Application Configuration","text":"<p>The last part of current tutorial is application configuration in zero system, the configuration files all listed here are as following:</p> <pre><code>src/main/resources/vertx.yml\nsrc/main/resources/vertx-inject.yml\nsrc/main/resources/vertx-jooq.yml\nsrc/main/resources/vertx-server.yml\n</code></pre> <p>1 - In the major configuration up.god.file <code>vertx.yml</code> you should configure following part, focus on lime node:</p> <pre><code>zero:\nlime: jooq  # The core configuration of jooq, it connect vertx-jooq.yml up.god.file\nvertx:\ninstance:\n- name: vertx-zeus\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre> <p>2 - In the inject configuration up.god.file <code>vertx-inject.yml</code>, you should apply the plugin of jooq <code>Infix</code> as following:</p> <pre><code>jooq: io.vertx.tp.plugin.jooq.JooqInfix\n</code></pre> <p>3 - The last part is <code>vertx-jooq.yml</code>, in the major configuration you could see lime extension, and zero system will connect <code>vertx-jooq.yml</code> to pick the configuration data. The content is as following:</p> <pre><code>jooq:\nprovider:\ndriverClassName: \"com.mysql.cj.jdbc.Driver\"\nusername: htl\npassword: \"pl,okmijn123\"\ncatalog: DB_ZERO\njdbcUrl: \"jdbc:mysql://127.0.0.1:3306/DB_ZERO?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;useSSL=false&amp;allowPublicKeyRetrieval=true\"\n</code></pre> <p>Be sure the configuration of your jooq is the same as jooq xml configuration up.god.file.</p>"},{"location":"vertx-zero-tutorial/d10061-jooqmysql-configuration/#4-summary","title":"4. Summary","text":"<p>If you finished above three part of configuration, you can use Jooq in zero system now. We'll focus on following part:</p> <ul> <li>How to use Jooq with Utility X tool in zero system ?</li> <li>How to do CRUD operations ?</li> <li>How to do some advanced database operations ?</li> <li>How to do advanced searching ?</li> </ul> <p>Please finish this tutorial preparing part for further tutorial of Jooq, the reason that we use Jooq is that it's more smartly and could integrated with vert.x, you can ignore SQL statement and do the database operations with lightweight ORM instead of some heavy or complex ORM such as Hibernate.</p>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/","title":"Jooq/GRUD, Read Operation","text":"<p>The first example of jooq should be <code>CRUD</code> - Read Operation, we could process read data by primary key ( id ) first, the demo of current tutorial we'll use interface style to prepare.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6093 : <code>up-thea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10062-jooq-get/#11-api","title":"1.1. Api","text":"<pre><code>package up.god.micro.tabular;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface TabularIrApi {\n@Path(\"tabular/{id}\")\n@GET\n@Address(\"ZERO://QUEUE/TABULAR/ID\")\nLong get(@PathParam(\"id\") Long id);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.tabular;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport javax.inject.Inject;\n@Queue\npublic class TabularWorker {\n@Inject\nprivate transient TabularStub stub;\n@Address(\"ZERO://QUEUE/TABULAR/ID\")\nFuture&lt;JsonObject&gt; get(final Envelop envelop) {\nfinal Long id = Ux.getLong(envelop);\nreturn this.stub.fetchOne(id);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/#13-stub-interface","title":"1.3. Stub ( Interface )","text":"<pre><code>package up.god.micro.tabular;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\npublic interface TabularStub {\nFuture&lt;JsonObject&gt; fetchOne(Long id);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/#14-service-implementation-class","title":"1.4. Service ( Implementation Class )","text":"<pre><code>package up.god.micro.tabular;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport up.god.domain.tables.daos.SysTabularDao;\npublic class TabularService implements TabularStub {\n@Override\npublic Future&lt;JsonObject&gt; fetchOne(final Long id) {\nreturn Ux.Jooq.on(SysTabularDao.class).fetchOneByID(id);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/#2-utility-x-of-jooq","title":"2. Utility X of Jooq","text":"<p>In this example we used an api of <code>Ux.Jooq</code> class, this class is provided by zero system, once you have finished the configuration of Jooq, you can use <code>Ux.Jooq</code> tool in any place of zero system code. When you used <code>Ux.Jooq</code> class, you must call <code>on(Class&lt;?&gt;)</code> first and returned <code>io.vertx.up.uca.jooq.UxJooq</code> reference, once you get this reference you can call some common api now.</p> <p>Current example, we used <code>fetchOnneByID</code> method, you can check this method signature:</p> <pre><code>public &lt;T&gt; Future&lt;T&gt; findByIdAsync(final Object id)\n</code></pre> <p>Be sure you have generated the required <code>Dao</code> class and then you can pass the <code>Dao</code> class into <code>Ux.Jooq.on</code> api to initialize the database accessor first.</p> <p>When you test the request with following, you can see the response data ( Please ignore the data content ):</p> <p>URL : http://localhost:6093/api/tabular/2</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"pkId\": 2,\n\"isActive\": true,\n\"zsigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"zlanguage\": \"cn\",\n\"zcreateTime\": \"2018-02-07T12:09:32\",\n\"scode\": \"Single\",\n\"stype\": \"code.pricecat\",\n\"iorder\": 2,\n\"sname\": \"\u6563\u5ba2\u6267\u884c\u4ef7\"\n}\n}\n</code></pre> <p>Here we could see that the data object has been returned, but for some real business scenario, we need to normalize response data and here you can refer chapter 3 to do it.</p>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/#3-normalized","title":"3. Normalized","text":"<p>Firstly, create new up.god.file named <code>tabular.yml</code> under pojo folder <code>src/main/resources/pojo</code>, the up.god.file content could be as following:</p> <pre><code>type: \"up.god.domain.tables.pojos.SysTabular\"\nmapping:\npkId: key\nisActive: active\nzsigma: sigma\nzlanguage: language\nzcreateTime: createTime\nscode: code\nstype: type\niorder: order\nsname: name\n</code></pre> <p>If you configured the mapping of pojo as above, you can modify the service code as following:</p> <pre><code>package up.god.micro.tabular;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport up.god.domain.tables.daos.SysTabularDao;\nimport up.god.domain.tables.pojos.SysTabular;\npublic class TabularService implements TabularStub {\n@Override\npublic Future&lt;JsonObject&gt; fetchOne(final Long id) {\nreturn Ux.Jooq.on(SysTabularDao.class)\n.&lt;SysTabular&gt;findByIdAsync(id)\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"));\n}\n}\n</code></pre> <p>Here <code>tabular</code> is the configuration up.god.file name that you created, then if you re-send the request you should get following response:</p> <pre><code>{\n\"data\": {\n\"key\": 2,\n\"active\": true,\n\"name\": \"\u6563\u5ba2\u6267\u884c\u4ef7\",\n\"code\": \"Single\",\n\"type\": \"code.pricecat\",\n\"order\": 2,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\",\n\"createTime\": \"2018-02-07T12:09:32\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10062-jooq-get/#4-summary","title":"4. Summary","text":"<p>Because our system came from old hotel system migration, that's why we need the mapping up.god.file to normalize response. If you focus on new system you can do this normalize in the pojo definition. But you still may met the situation that need you to set the mapping rule, at that time it's helpful for you to continue the works.</p>"},{"location":"vertx-zero-tutorial/d10062-jooqcreate-operation/","title":"Jooq/Create Operation","text":"<p>From this chapter we'll focus on CRUD operations on database, the first operation is <code>Create</code>, it's mapped to <code>INSERT</code> sql statement.</p>"},{"location":"vertx-zero-tutorial/d10062-jooqcreate-operation/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/","title":"Jooq/CRUD, Write Operations","text":"<p>Then we move to <code>CRUD</code> - Create/Update/Delete Operation, these operations is common when you process business.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6093 : <code>up-thea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#11-api","title":"1.1. Api","text":"<pre><code>package up.god.micro.tabular;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Codex;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.*;\n@EndPoint\n@Path(\"/api\")\npublic interface TabularApi {\n@Path(\"tabular\")\n@POST\n@Address(\"ZERO://QUEUE/TABULAR/CREATE\")\nJsonObject create(@BodyParam @Codex JsonObject data);\n@Path(\"tabular/{id}\")\n@PUT\n@Address(\"ZERO://QUEUE/TABULAR/UPDATE\")\nJsonObject update(@PathParam(\"id\") Long id, @BodyParam @Codex JsonObject data);\n@Path(\"tabular/{id}\")\n@DELETE\n@Address(\"ZERO://QUEUE/TABULAR/DELETE\")\nJsonObject delete(@PathParam(\"id\") Long id);\n}\n</code></pre> <p>Above three apis are mapping to <code>insert, update, delete</code> operations.</p>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#12-consumer","title":"1.2. Consumer","text":"<p>Here we add methods to original consumer code as following:</p> <pre><code>package up.god.micro.tabular;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport javax.inject.Inject;\n@Queue\npublic class TabularWorker {\n@Inject\nprivate transient TabularStub stub;\n@Address(\"ZERO://QUEUE/TABULAR/ID\")\nFuture&lt;JsonObject&gt; get(final Envelop envelop) {\nfinal Long id = Ux.getLong(envelop);\n// First version\nreturn this.stub.fetchOne(id);\n}\n// New added three methods for writing operations.\n@Address(\"ZERO://QUEUE/TABULAR/CREATE\")\nFuture&lt;JsonObject&gt; create(final Envelop envelop) {\nfinal JsonObject data = Ux.getJson(envelop);\nreturn this.stub.create(data);\n}\n@Address(\"ZERO://QUEUE/TABULAR/UPDATE\")\nFuture&lt;JsonObject&gt; update(final Envelop envelop) {\nfinal Long id = Ux.getLong(envelop);\nfinal JsonObject data = Ux.getJson1(envelop);\nreturn this.stub.update(id, data);\n}\n@Address(\"ZERO://QUEUE/TABULAR/DELETE\")\nFuture&lt;JsonObject&gt; delete(final Envelop envelop) {\nfinal Long id = Ux.getLong(envelop);\nreturn this.stub.delete(id);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#13-stub-service-interface","title":"1.3. Stub ( Service Interface )","text":"<p>The definition of service interface as following:</p> <pre><code>package up.god.micro.tabular;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\npublic interface TabularStub {\nFuture&lt;JsonObject&gt; fetchOne(Long id);\n// New added three apis for writing operations.\nFuture&lt;JsonObject&gt; create(JsonObject data);\nFuture&lt;JsonObject&gt; update(Long id, JsonObject data);\nFuture&lt;JsonObject&gt; delete(Long id);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#2-service-implementation","title":"2. Service Implementation","text":"<p>Here we need to mention is that we'll split different code logical for <code>insert, update, delete</code> to explain the usage of <code>Ux.Jooq</code> class.</p>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#21-create","title":"2.1. create","text":"<pre><code>    @Override\npublic Future&lt;JsonObject&gt; create(final JsonObject data) {\nfinal SysTabular tabular = Ux.fromJson(data, SysTabular.class, \"tabular\");\ntabular.setZCreateTime(LocalDateTime.now());\ntabular.setZUpdateTime(LocalDateTime.now());\nreturn Ux.Jooq.on(SysTabularDao.class)\n.insertReturningPrimaryAsync(tabular, tabular::setPkId)\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"));\n}\n</code></pre> <p>Here the first part is the same that we called <code>Ux.Jooq.on</code> api to mount our client to <code>SysTabularDao</code> dao class, then we called <code>insertReturningPrimaryAsync</code> method for object tabular, this method will help you to set auto generated primary key, here we need to mention:</p> <ul> <li>All the generated key is <code>Long</code> type instead of <code>Integer</code>.</li> <li>The generated key will be passed into <code>tabular::setPkId</code> method to consume instead you use it.</li> </ul> <p>There is another method <code>insertAsync</code> that you could use is that you do not care the returned generated key, it just like following:</p> <pre><code>        return Ux.Jooq.on(SysTabularDao.class).insertAsync(tabular)\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"));\n</code></pre> <p>In zero system here provide three apis for Jooq creating:</p> <ul> <li><code>insertAsync(T)</code></li> <li><code>insertAsync(List&lt;T&gt;)</code></li> <li><code>insertReturningPrimaryAsync(T, Consumer&lt;Long&gt;)</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#22-update","title":"2.2. update","text":"<p>The second method that we'll introduce is update operation</p> <pre><code>    @Override\npublic Future&lt;JsonObject&gt; update(final Long id, final JsonObject data) {\nreturn Ux.Jooq.on(SysTabularDao.class).findByIdAsync(id)\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"))\n.compose(item -&gt; Future.succeededFuture(item.mergeIn(data)))\n.compose(item -&gt; Future.succeededFuture(Ux.fromJson(item, SysTabular.class, \"tabular\")))\n.compose(item -&gt; Ux.Jooq.on(SysTabularDao.class).updateAsync(item))\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"));\n}\n</code></pre> <p>Above code described how to update the data in database, please be careful about the code logical:</p> <ol> <li>Get the entity <code>SysTabular</code> from database by id first;</li> <li>Convert the data object into JsonObject;</li> <li>Merged JsonObject with updated json data;</li> <li>Convert the updated JsonObject data back to <code>SysTabular</code>;</li> <li>Update the <code>SysTabular</code> data object and returned the updated data object.</li> </ol> <p>It's a little complex and not very well, in this situation we recommend to use another method of <code>Ux.Jooq</code> as following:</p> <pre><code>    @Override\npublic Future&lt;JsonObject&gt; update(final Long id, final JsonObject data) {\nfinal SysTabular updated = Ux.fromJson(data, SysTabular.class, \"tabular\");\nreturn Ux.Jooq.on(SysTabularDao.class).saveAsync(id, updated)\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"));\n}\n</code></pre> <p>Here we called <code>saveAsync</code> with <code>id</code> and <code>updated</code> data object, then you can update the data here. When you send request, you can see following results:</p> <p>URL : http://localhost:6093/api/tabular/172</p> <p>Method : PUT</p> <p>Request :</p> <pre><code>{\n\"key\":172,\n\"name\":\"Lang3\",\n\"active\": true,\n\"sigma\": \"test\",\n\"language\": \"cn\",\n\"code\":\"LANG.CODEEX\",\n\"type\":\"testx.type\",\n\"order\":3\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"key\": 172,\n\"active\": true,\n\"createTime\": \"2018-02-10T13:50:44\",\n\"zupdateTime\": \"2018-02-10T13:50:44\",\n\"type\": \"testx.type\",\n\"code\": \"LANG.CODEX\",\n\"name\": \"Lang3\",\n\"order\": 3,\n\"sigma\": \"test\",\n\"language\": \"cn\"\n}\n}\n</code></pre> <p>Although we provide update apis here, but the <code>save</code> apis are more useful, here are all the apis of <code>Ux.Jooq</code>:</p> <ul> <li><code>&lt;T&gt; Future&lt;T&gt; updateAsync(T entity)</code></li> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; updateAsync(List&lt;T&gt; entities)</code></li> <li><code>&lt;T&gt; Future&lt;T&gt; saveAsync(Object id, T updated)</code></li> <li><code>&lt;T&gt; Future&lt;T&gt; saveAsync(Object id, Function&lt;T,T&gt; copyFun)</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#23-delete","title":"2.3. delete","text":"<p>The last write operation api of Jooq is <code>delete</code>, you can do as following:</p> <pre><code>    @Override\npublic Future&lt;JsonObject&gt; delete(final Long id) {\nreturn Ux.Jooq.on(SysTabularDao.class).deleteByIdAsync(id)\n.compose(result -&gt; (result) ?\nFuture.succeededFuture(new JsonObject().put(\"result\", Boolean.TRUE)) :\nFuture.succeededFuture(new JsonObject().put(\"result\", Boolean.FALSE))\n);\n}\n</code></pre> <p>Here you can delete record from database.</p> <p>URL : http://localhost:6093/api/tabular/172</p> <p>Method : DELETE</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"result\": true\n}\n}\n</code></pre> <p>Here we listed all the delete api that <code>Ux.Jooq</code> provided:</p> <ul> <li><code>&lt;T&gt; Future&lt;T&gt; deleteAsync(T entity)</code></li> <li><code>&lt;T&gt; Future&lt;Boolean&gt; deleteByIdAsync(Object id)</code></li> <li><code>&lt;T&gt; Future&lt;Boolean&gt; deleteByIdAsync(Collection&lt;Object&gt; ids)</code></li> <li><code>&lt;T&gt; Future&lt;Boolean&gt; deleteByIdAsync(Object... ids)</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10063-jooqcreate-operations/#3-summary","title":"3. Summary","text":"<p>Until now you have known how to <code>insert, update, delete</code> data by Jooq, here we have finished all the CRUD operation tutorials, from next chapter we'll discuss some advanced Jooq features for real business project usage such as pagination, sorting, searching etc.</p>"},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/","title":"Jooq/CRUD, Fetch One Operation","text":"<p>This chapter we'll focus on some frequently situations: query unique data record by one field.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6093 : <code>up-thea</code></li> </ul> <p>For example sometimes you may query the user record by name instead of primary key, in this kind of situation the <code>Read Operations</code> that we introduced may be useless.</p>"},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/#11-api","title":"1.1. Api","text":"<pre><code>package up.god.micro.fetch;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface FetchApi {\n@Path(\"tabular/by/{name}\")\n@GET\n@Address(\"ZERO://QUEUE/BY/NAME\")\nString fetchByName(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.fetch;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport javax.inject.Inject;\n@Queue\npublic class FetchWorker {\n@Inject\nprivate transient FetchStub stub;\n@Address(\"ZERO://QUEUE/BY/NAME\")\npublic Future&lt;JsonObject&gt; byName(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nreturn this.stub.fetchByName(name);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/#13-stub-interface","title":"1.3. Stub ( Interface )","text":"<pre><code>package up.god.micro.fetch;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\npublic interface FetchStub {\nFuture&lt;JsonObject&gt; fetchByName(String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/#14-service-implementation","title":"1.4. Service ( Implementation )","text":"<pre><code>package up.god.micro.fetch;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport up.god.domain.tables.daos.SysTabularDao;\nimport up.god.domain.tables.pojos.SysTabular;\npublic class FetchService implements FetchStub {\n@Override\npublic Future&lt;JsonObject&gt; fetchByName(final String name) {\nreturn Ux.Jooq.on(SysTabularDao.class)\n.&lt;SysTabular&gt;fetchOneAsync(\"S_NAME\", name)\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/#2-testing","title":"2. Testing","text":"<p>Here we used <code>fetchOneAsync</code> method to query the data by <code>S_NAME</code> column, and you can test with following:</p> <p> URL : http://localhost:6093/api/tabular/by/%e6%8c%82%e7%89%8c%e4%bb%b7</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"key\": 1,\n\"active\": true,\n\"createTime\": \"2018-02-07T12:09:32\",\n\"name\": \"\u6302\u724c\u4ef7\",\n\"code\": \"Standard\",\n\"type\": \"code.pricecat\",\n\"order\": 1,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\"\n}\n}\n</code></pre> <p>Except above fetchOneAsync api, <code>Ux.Jooq</code> class provide all the <code>fetchOne</code> apis as following:</p> <ul> <li><code>&lt;T&gt; Future&lt;T&gt; fetchOneAsync(String column, Object value)</code></li> <li><code>&lt;T&gt; Future&lt;T&gt; fetchOneAndAsync(JsonObject andFilters)</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10064-jooqcrud-fetch-one-operation/#3-summary","title":"3. Summary","text":"<p>This chapter described how to use <code>fetchOne</code> method as well and we'll continue to introduce fetching operations and tell the developers how to use <code>andFilters</code> in forward tutorials.</p>"},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/","title":"Jooq/CRUD, Fetch List Operation","text":"<p>This chapter we'll move to list fetching operations, here are four apis listed in <code>Ux.Jooq</code> class that could be used to fetch list.</p> <ul> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; fetchAsync(String column, Object value)</code></li> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; fetchInAsync(String column, Object... values)</code></li> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; fetchAndAsync(JsonObject andFilters)</code></li> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; fetchOrAsync(JsonObject orFilters)</code></li> </ul> <p>Above four apis could be used to fetch the list by different conditions and all the conditions are frequently used in your real projects. This chapter we'll ignore the <code>filter</code> explain, focus on basic usage and then we'll go forward to.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6093 : <code>up-thea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/#11-api","title":"1.1. Api","text":"<pre><code>package up.god.micro.fetch;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.*;\n@EndPoint\n@Path(\"/api\")\npublic interface FetchListApi {\n@Path(\"tabular/list/by/{type}\")\n@GET\n@Address(\"ZERO://QUEUE/LIST/BY\")\nString fetchByType(@PathParam(\"type\") String type);\n@Path(\"tabular/list/by\")\n@POST\n@Address(\"ZERO://QUEUE/LIST/BY/TYPES\")\nJsonArray fetchByTypes(@BodyParam JsonArray types);\n@Path(\"tabular/list/multi\")\n@GET\n@Address(\"ZERO://QUEUE/LIST/BY/MULTI\")\nString fetchByMulti(@QueryParam(\"type\") String type,\n@QueryParam(\"code\") String code);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.fetch;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport javax.inject.Inject;\n@Queue\npublic class FetchListWorker {\n@Inject\nprivate transient FetchStub stub;\n@Address(\"ZERO://QUEUE/LIST/BY\")\npublic Future&lt;JsonArray&gt; fetchByType(final Envelop envelop) {\nfinal String type = Ux.getString(envelop);\nreturn this.stub.fetchByTypes(type);\n}\n@Address(\"ZERO://QUEUE/LIST/BY/TYPES\")\npublic Future&lt;JsonArray&gt; fetchByTypes(final Envelop envelop) {\nfinal JsonArray types = Ux.getArray(envelop);\nreturn this.stub.fetchByTypes(types.getList().toArray());\n}\n@Address(\"ZERO://QUEUE/LIST/BY/MULTI\")\npublic Future&lt;JsonArray&gt; fetchByMulti(final Envelop envelop) {\nfinal String type = Ux.getString(envelop);\nfinal String code = Ux.getString1(envelop);\nfinal JsonObject filters = new JsonObject();\nfilters.put(\"S_TYPE\", type).put(\"S_CODE\", code);\nreturn this.stub.fetchByFilters(filters);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/#13-stub","title":"1.3. Stub","text":"<p>Here we added two more methods in to interface definition: <code>fetchByTypes</code> and <code>fetchByFilters</code> .</p> <pre><code>package up.god.micro.fetch;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\npublic interface FetchStub {\nFuture&lt;JsonObject&gt; fetchByName(String name);\nFuture&lt;JsonArray&gt; fetchByTypes(Object... types);\nFuture&lt;JsonArray&gt; fetchByFilters(JsonObject filters);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/#14-service","title":"1.4. Service","text":"<pre><code>package up.god.micro.fetch;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport up.god.domain.tables.daos.SysTabularDao;\nimport up.god.domain.tables.pojos.SysTabular;\npublic class FetchService implements FetchStub {\n@Override\npublic Future&lt;JsonObject&gt; fetchByName(final String name) {\nreturn Ux.Jooq.on(SysTabularDao.class)\n.&lt;SysTabular&gt;fetchOneAsync(\"S_NAME\", name)\n.compose(item -&gt; Ux.thenJsonOne(item, \"tabular\"));\n}\n@Override\npublic Future&lt;JsonArray&gt; fetchByTypes(final Object... types) {\nreturn Ux.Jooq.on(SysTabularDao.class)\n.&lt;SysTabular&gt;fetchInAsync(\"S_TYPE\", types)\n.compose(item -&gt; Ux.thenJsonMore(item, \"tabular\"));\n}\n@Override\npublic Future&lt;JsonArray&gt; fetchByFilters(final JsonObject filters) {\nreturn Ux.Jooq.on(SysTabularDao.class)\n.&lt;SysTabular&gt;fetchAndAsync(filters)\n.compose(item -&gt; Ux.thenJsonMore(item, \"tabular\"));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/#2-testing","title":"2. Testing","text":"<p>Above example showed how to fetch list by different filters with condition, you can test with following:</p> <p> URL : http://localhost:6093/api/tabular/list/by/preorder.category</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": [\n{\n\"key\": 44,\n\"active\": true,\n\"createTime\": \"2018-02-07T12:09:32\",\n\"type\": \"preorder.category\",\n\"code\": \"Personal\",\n\"name\": \"\u6563\u5ba2\u9884\u5b9a\",\n\"order\": 1,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\"\n},\n{\n\"key\": 45,\n\"active\": true,\n\"createTime\": \"2018-02-07T12:09:32\",\n\"type\": \"preorder.category\",\n\"code\": \"Company\",\n\"name\": \"\u56e2\u961f\u9884\u5b9a\",\n\"order\": 2,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\"\n}\n]\n}\n</code></pre> <p>URL : http://localhost:6093/api/tabular/list/by</p> <p>Method : POST</p> <p>Request :</p> <pre><code>[\n\"room.status\",\n\"room.op.status\"\n]\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": [\n{\n\"key\": 8,\n\"active\": true,\n\"createTime\": \"2018-02-07T12:09:32\",\n\"type\": \"room.status\",\n\"code\": \"Operation\",\n\"name\": \"\u53ef\u64cd\u4f5c\",\n\"jconfig\": \"{\\\"visible\\\":false}\",\n\"order\": 1,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\"\n},\n......\n]\n}\n</code></pre> <p> URL : http://localhost:6093/api/tabular/list/multi?code=Single&amp;type=code.pricecat</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": [\n{\n\"key\": 2,\n\"active\": true,\n\"createTime\": \"2018-02-07T12:09:32\",\n\"type\": \"code.pricecat\",\n\"code\": \"Single\",\n\"name\": \"\u6563\u5ba2\u6267\u884c\u4ef7\",\n\"order\": 2,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\"\n}\n]\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10065-jooqcrud-fetch-list-operation/#3-summary","title":"3. Summary","text":"<p>This chapter described that how to fetch list from database by different conditions, based on the examples you could know how to fetch list from database. Next chapter we'll introduce the filter details, actually <code>andFilters</code> and  <code>orFilters</code> are both JsonObject, but there are some specific syntax that zero defined for developers to build complex filters.</p>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/","title":"Jooq/CRUD, Filter Syntax","text":"<p>In previous tutorial, you could see that there are two apis in <code>Ux.Jooq</code> as following:</p> <ul> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; fetchAndAsync(JsonObject andFilters)</code></li> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; fetchOrAsync(JsonObject orFilters)</code></li> <li><code>&lt;T&gt; Future&lt;T&gt; fetchOneAndAsync(JsonObject andFilters)</code></li> </ul> <p>Above three apis used <code>andFilters</code> and <code>orFilters</code>, actually these filters support different condition that mapped to SQL database.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6093 : <code>up-thea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#1-basic-syntax","title":"1. Basic Syntax","text":"<p>When you write filter with following java code:</p> <pre><code>        final String type = Ux.getString(envelop);\nfinal String code = Ux.getString1(envelop);\nfinal JsonObject filters = new JsonObject();\nfilters.put(\"S_TYPE\", type).put(\"S_CODE\", code);\n</code></pre> <p>Here are the basic syntax, you can put <code>column</code> name and <code>value</code> into JsonObject and above filters will generate following SQL:</p> <pre><code>S_TYPE = ? AND S_CODE = ?\n</code></pre> <p>Here the connector is <code>AND</code>, because we called <code>fetchAndAsync</code> api, if you use the same filter to call <code>fetchOrAsync</code> api, the generated SQL will be:</p> <pre><code>S_TYPE = ? OR S_CODE = ?\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#2-advanced-syntax","title":"2. Advanced Syntax","text":"<p>Our filter <code>column</code> support suffix syntax to do different query, the basic column syntax is:</p> <pre><code>NAME,OP\n</code></pre> <p>It means that you can use following syntax:</p> <pre><code>JsonObject filter1 = new JsonObject().put(\"S_TYPE,=\", type);\nJsonObject filter2 = new JsonObject().put(\"S_TYPE\", type);\n</code></pre> <p>Above two statement is equal, here <code>S_TYPE,=</code> is the syntax of zero system filter.</p>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#21-equal-name","title":"2.1. equal, NAME,=","text":"<p>The first syntax is <code>=</code> operator in SQL, because it's frequently used and you can ignore <code>,=</code> in this statement.</p> <pre><code>JsonObject filter1 = new JsonObject().put(\"S_TYPE,=\", type);\nJsonObject filter2 = new JsonObject().put(\"S_TYPE\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE = ?\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#22-not-equal-name","title":"2.2. not equal, NAME,&lt;&gt;","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,&lt;&gt;\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE &lt;&gt; ?\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#23-less-than-name","title":"2.3. less than, NAME,&lt;","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,&lt;\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE &lt; ?\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#24-less-than-and-equal-name","title":"2.4. less than and equal, NAME, &lt;=","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,&lt;=\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE &lt;= ?\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#25-greater-than-name","title":"2.5. greater than, NAME, &gt;","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,&gt;\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE &gt; ?\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#26-greater-than-and-equal-name","title":"2.6. greater than and equal, NAME, &gt;=","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,&gt;=\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE &gt;= ?\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#27-not-null-namen","title":"2.7. not null, NAME,!n","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,!n\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE IS NOT NULL\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#28-null-namen","title":"2.8, null, NAME,n","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,n\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE IS NULL\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#29-true-namet","title":"2.9, true, NAME,t","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,t\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE = TRUE\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#210-false-namef","title":"2.10, false, NAME,f","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,f\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE = FALSE\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#211-in-namei","title":"2.11, in, NAME,i","text":"<pre><code>JsonArray type = new JsonArray().add(\"type1\");    // IN should use JsonArray as parameters\nJsonObject filter = new JsonObject().put(\"S_TYPE,i\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE IN (?,?)\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#212-not-in-namei","title":"2.12, not in, NAME,!i","text":"<pre><code>JsonArray type = new JsonArray().add(\"type1\");    // IN should use JsonArray as parameters\nJsonObject filter = new JsonObject().put(\"S_TYPE,!i\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE NOT IN (?,?)\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#213-start-with-names","title":"2.13, start with, NAME,s","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,s\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE LIKE 'type%'\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#214-end-with-name-e","title":"2.14, end with, NAME, e","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,e\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE LIKE '%type'\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#215-contain-namec","title":"2.15, contain, NAME,c","text":"<pre><code>JsonObject filter = new JsonObject().put(\"S_TYPE,c\", type);\n</code></pre> <p>To</p> <pre><code>S_TYPE LIKE '%type%'\n</code></pre>"},{"location":"vertx-zero-tutorial/d10066-jooqcrud-filter-syntax/#3-summary","title":"3. Summary","text":"<p>For above filters, now it's used into <code>andFilters</code> and <code>orFilters</code> only, in future plan we'll put into advanced usage. It's common usage and you may meet different situations in your real project, but if you use the filter syntax, you can consider the code logical only and do not think how to write the SQL statement. It's also why we recommend to use Jooq instead of other client here.</p>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/","title":"Jooq/CRUD, Paging/Sorting","text":"<p>This chapter will focus on Jooq advanced search operation, it could be used in different pagination list table, you can refer current tutorial to check more details about how to write advanced searching operation.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6093 : <code>up-thea</code></li> </ul> <p>Here are the all the apis that <code>Ux.Jooq</code> class provided for paging, sorting</p> <ul> <li><code>Future&lt;JsonObject&gt; searchAndAsync(Inquiry inquiry)</code></li> <li><code>Future&lt;JsonObject&gt; searchAndAsync(Inquiry inquiry, String pojo)</code></li> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; searchAndListAsync(Inquiry inquiry)</code></li> <li><code>Future&lt;JsonObject&gt; searchOrAsync(Inquiry inquiry)</code></li> <li><code>Future&lt;JsonObject&gt; searchOrAsync(Inquiry inquiry, String pojo)</code></li> <li><code>&lt;T&gt; Future&lt;List&lt;T&gt;&gt; searchOrOrListAsync(Inquiry inquiry)</code></li> </ul> <p>In current version, zero system provided above three apis only, if you want to use dto, you must provide the mapping up.god.file that has been introduced in previous tutorial:</p> <p>src/main/resources/pojo/tabular.yml</p> <pre><code>type: \"up.god.domain.tables.pojos.SysTabular\"\nmapping:\npkId: key\nisActive: active\nzsigma: sigma\nzlanguage: language\nzcreateTime: createTime\nscode: code\nstype: type\niorder: order\nsname: name\ncolumns:\nname: S_NAME\ncode: S_CODE\ntype: S_TYPE\norder: I_ORDER\nlanguage: Z_LANGUAGE\ncreateTime: Z_CREATE_TIME\nupdateTime: Z_UPDATE_TIME\nactive: IS_ACTIVE\nsigma: Z_SIGMA\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#11-api","title":"1.1. Api","text":"<pre><code>package up.god.micro.advanced;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic interface SearchApi {\n@Path(\"tabular/search\")\n@POST\n@Address(\"ZERO://QUEUE/SEARCH\")\nString search(@BodyParam String name);\n}\n</code></pre> <p>Because we'll serialize the body data into Inquiry directly, here we recommend to use POST instead of GET method do searching.</p>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.advanced;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport javax.inject.Inject;\n@Queue\npublic class SearchWorker {\n@Inject\nprivate transient SearchStub searchStub;\n@Address(\"ZERO://QUEUE/SEARCH\")\npublic Future&lt;JsonObject&gt; search(final Envelop envelop) {\nfinal JsonObject data = Ux.getJson(envelop);\n// The second parameter is the yml up.god.file name \"tabular.yml\"\nreturn this.searchStub.search(Ux.getInquiry(data, \"tabular\"));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#13-stub-interface","title":"1.3. Stub ( Interface )","text":"<pre><code>package up.god.micro.advanced;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.atom.query.Inquiry;\npublic interface SearchStub {\nFuture&lt;JsonObject&gt; search(final Inquiry inquiry);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#14-service-implementation","title":"1.4. Service ( Implementation )","text":"<pre><code>package up.god.micro.advanced;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.atom.query.Inquiry;\nimport up.god.domain.tables.daos.SysTabularDao;\npublic class SearchService implements SearchStub {\n@Override\npublic Future&lt;JsonObject&gt; search(final Inquiry inquiry) {\nreturn Ux.Jooq.on(SysTabularDao.class)\n.searchAndAsync(inquiry, \"tabular\");\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#2-points-for-searching","title":"2. Points for searching","text":"<ul> <li>Here we used <code>Ux.getInquiry</code> api to build valid <code>Inquiry</code> object, the type of this object   is <code>io.vertx.up.atom.query.Inquiry</code>.</li> <li>If you do not provide pojo mapping up.god.file ( The 2nd argument ), you should put SQL COLUMN instead instead of   field name in <code>sorter</code> and <code>criteria</code> request json node.</li> </ul>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#3-testing","title":"3. Testing","text":"<p>Here we prepared different cases to test this searching api.</p> <p>URL : http://localhost:6093/api/tabular/search</p> <p>Method : POST</p>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#31-empty-request","title":"3.1. Empty Request","text":"<p>Request :</p> <pre><code>{\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\":{\n\"list\":[\n{\n\"key\": 1,\n\"active\": true,\n\"name\": \"\u6302\u724c\u4ef7\",\n\"code\": \"Standard\",\n\"type\": \"code.pricecat\",\n\"order\": 1,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\",\n\"createTime\": \"2018-02-07T12:09:32\"\n},\n......\n],\n\"count\":168\n}\n}\n</code></pre> <p>Returned all the records in your database and the count.</p>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#32-paging","title":"3.2. Paging","text":"<p>Request :</p> <pre><code>{\n\"pager\":{\n\"page\":1,\n\"size\":10\n}\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\":{\n\"list\":[\n{\n\"key\": 1,\n\"active\": true,\n\"name\": \"\u6302\u724c\u4ef7\",\n\"code\": \"Standard\",\n\"type\": \"code.pricecat\",\n\"order\": 1,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\",\n\"createTime\": \"2018-02-07T12:09:32\"\n},\n......,\n{\n\"key\": 10,\n\"active\": true,\n\"name\": \"\u9884\u7559\u623f\",\n\"code\": \"Left\",\n\"type\": \"room.status\",\n\"jconfig\": \"{\\\"icon\\\":\\\"green heart\\\"}\",\n\"order\": 3,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\",\n\"createTime\": \"2018-02-07T12:09:32\"\n}\n],\n\"count\":168\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#33-sorting","title":"3.3. Sorting","text":"<p>Request :</p> <pre><code>{\n\"pager\":{\n\"page\":1,\n\"size\":10\n},\n\"sorter\":[\n\"type,DESC\",\n\"order,DESC\"\n]\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\":{\n\"list\":[\n{\n\"key\": 144,\n\"active\": true,\n\"name\": \"\u5386\u53f2\u5bbe\u5ba2\",\n\"code\": \"History\",\n\"type\": \"traveler.status\",\n\"order\": 2,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\",\n\"createTime\": \"2018-02-07T12:09:32\"\n},\n......,\n{\n\"key\": 159,\n\"active\": true,\n\"name\": \"\u5ba2\u623f\",\n\"code\": \"Room\",\n\"type\": \"shift.type\",\n\"order\": 1,\n\"sigma\": \"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"language\": \"cn\",\n\"createTime\": \"2018-02-07T12:09:32\"\n}\n],\n\"count\":168\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#34-projection","title":"3.4. Projection","text":"<p>In this request you can set some filters for returned columns.</p> <p>Request :</p> <pre><code>{\n\"pager\":{\n\"page\":1,\n\"size\":10\n},\n\"sorter\":[\n\"type,DESC\",\n\"order,DESC\"\n],\n\"projection\":[\n\"active\",\n\"sigma\",\n\"language\"\n]\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\":{\n\"list\":[\n{\n\"key\": 144,\n\"name\": \"\u5386\u53f2\u5bbe\u5ba2\",\n\"code\": \"History\",\n\"type\": \"traveler.status\",\n\"order\": 2,\n\"createTime\": \"2018-02-07T12:09:32\"\n},\n......,\n{\n\"key\": 159,\n\"name\": \"\u5ba2\u623f\",\n\"code\": \"Room\",\n\"type\": \"shift.type\",\n\"order\": 1,\n\"createTime\": \"2018-02-07T12:09:32\"\n}\n],\n\"count\":168\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#35-criteria","title":"3.5. Criteria","text":"<p>The last core parameters are <code>criteria</code> for condition setting.</p> <p>Request :</p> <pre><code>{\n\"pager\":{\n\"page\":1,\n\"size\":10\n},\n\"sorter\":[\n\"type,DESC\",\n\"order,DESC\"\n],\n\"projection\":[\n\"active\",\n\"sigma\",\n\"language\"\n],\n\"criteria\":{\n\"order,&lt;\":2\n}\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\":{\n\"list\":[\n{\n\"key\": 143,\n\"name\": \"\u5728\u4f4f\u5bbe\u5ba2\",\n\"code\": \"OnGoing\",\n\"type\": \"traveler.status\",\n\"order\": 1,\n\"createTime\": \"2018-02-07T12:09:32\"\n},\n......,\n{\n\"key\": 38,\n\"name\": \"\u73b0\u91d1\",\n\"code\": \"Cash\",\n\"type\": \"pay.type\",\n\"order\": 1,\n\"createTime\": \"2018-02-07T12:09:32\"\n}\n],\n\"count\":38\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10067-jooqcrud-advanced-search-operation/#4-summary","title":"4. Summary","text":"<p>From this chapter you should know how to do common searching with zero system Jooq.</p> <ul> <li><code>sorter, pager, projection, criteria</code> are specific parameters if you use body directly;</li> <li><code>sorter</code> and <code>criteria</code> support SQL column usage directly if you do not use <code>pojo</code> argument;</li> <li><code>projection</code> could remove some returned fields, if you use <code>pojo</code> up.god.file, projection field names should be   configured in <code>mapping</code> node.</li> <li><code>criteria</code> support zero filter syntax in previous tutorial introduced and all the connector is <code>AND</code> in SQL;</li> <li>The returned data format is fixed as you see in examples.</li> </ul>"},{"location":"vertx-zero-tutorial/d10068-fragment-yaml-configuration/","title":"Configuration, vertx.yml","text":"<p>Until now you have seen different configuration files appeared in zero system, this tutorial will introduce the configuration structure in zero system. In common maven project of zero system, the structure is often as following:</p> <pre><code>src/main/java\nsrc/main/resources     # This tutorial focus on this folder for yaml configuration\nsrc/test/java\nsrc/test/resources\nsrc/main/lombok        # If lombok enabled or used\n</code></pre> <p>All the yaml configuration files will be put into <code>src/main/resources</code> folder and different config up.god.file controls different feature.</p>"},{"location":"vertx-zero-tutorial/d10068-fragment-yaml-configuration/#1-content","title":"1. Content","text":"<p>The core configuration up.god.file is <code>vertx.yml</code>, this up.god.file is the kernel up.god.file of zero system, the demo of this up.god.file is as following:</p> <pre><code>zero:\nlime: error, inject, server\nvertx:\nclustered:\nenabled: false\nmanager:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 6000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10068-fragment-yaml-configuration/#2-extension-lime","title":"2. Extension: lime","text":"<p><code>lime</code> is the extension configuration, you can add any external yaml configuration up.god.file with <code>lime</code> here, for above demo, the extension up.god.file should be <code>vertx-error.yml</code>, <code>vertx-inject.yml</code>, <code>vertx-server.yml</code> . Another thing is that in our system the <code>lime</code> node impact filename only, it does not impact the config content. It means: _ _</p> <p>You can put mongo configuration information into <code>vertx-mysql.yml</code> , because zero system focus on content parsing instead of filename, but we do not want you to do like this.</p> <p>But we still recommend you to use meaningful filename for the content.</p> <p>The default extensions <code>lime</code> of zero system are as following:</p> <ul> <li><code>error</code>: The definition of error message in zero system.</li> <li><code>server</code>: The server configuration of zero system, default enabled <code>http</code> server.</li> <li><code>inject</code>: The default injection components in zero system, you can develop user-defined <code>Infix</code> and configured in zero   system. Zero system support plug-in components, we'll introduce the plug-in development in forward tutorials.</li> </ul> <p>All above <code>lime</code> nodes are default imported by zero system, though you haven't configured in <code>vertx.yml</code>, these extension were enabled by zero system. If you provide the extension files, the default configuration will be overwritten.</p>"},{"location":"vertx-zero-tutorial/d10068-fragment-yaml-configuration/#3-vertx-cluster-clustered","title":"3. Vert.x Cluster: clustered","text":"<p>Under the node <code>zero -&gt; vertx</code>, we could set vert.x cluster configuration part, the segment is as following:</p> <pre><code>clustered:\nenabled: false\nmanager: options:\n</code></pre> <p>If you want to enable vert.x cluster, you can add <code>clustered</code> configuration into <code>vertx.yml</code>:</p> <ul> <li><code>enabled</code>: Enable vert.x cluster mode;</li> <li><code>manager</code>: Provide vert.x cluster manager name, the name is full java class name, you can   refer http://vertx.io/docs/#clustering to check the cluster manager that vert.x   native supported.</li> <li><code>options</code>: If you enable clustered, you can provide options to cluster manager that you'll use, if you do not provide   this configuration, the cluster manager will use the default.</li> </ul> <p>Zero system disabled cluster mode in default.</p>"},{"location":"vertx-zero-tutorial/d10068-fragment-yaml-configuration/#4-vertx-instance-instance","title":"4. Vert.x Instance: instance","text":"<p>Here one zero instance could started more than one <code>vert.x</code> instance, but we still recommend you to set one vert.x instance in each zero node.</p> <pre><code>    instance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 6000000000\n</code></pre> <p>This configuration is simple, the <code>name</code> will be used in <code>micro</code> mode more than <code>standalone</code> mode, when you use service discovery/registry feature, all the configuration path in registry center ( zookeeper, etcd or consul ) will be put under the name, we'll introduce in forward tutorials.</p> <p>The <code>options</code> will be mapped to native vert.x configuration, it's JsonObject and will be converted to <code>io.vertx.core.VertxOptions</code> class instead, it's direct serialization.</p>"},{"location":"vertx-zero-tutorial/d10068-fragment-yaml-configuration/#5-summary","title":"5. Summary","text":"<p>This chapter focus on the core zero system configuration up.god.file <code>vertx.yml</code> , this up.god.file contains following configuration part:</p> <ul> <li>lime: The configuration extension.</li> <li>vertx -&gt; clustered: Vert.x cluster configuration.</li> <li>vertx -&gt; instance: ( Multi Support ) The vert.x options that will be converted to <code>io.vertx.core.VertxOptions</code>.</li> </ul> <p>Once more thing is that all the other configuration came from <code>lime</code> node, the lime means:</p> <p>Linear Injection Magical Extension</p>"},{"location":"vertx-zero-tutorial/d10069-configuration-vertx-serveryml/","title":"Configuration, vertx-server.yml","text":"<p><code>server</code> in <code>lime</code> node is extend by default, if your did not provide <code>vertx-server.yml</code>, zero system will use the default configuration as following:</p> <pre><code>server:\n- name: zero-ws\ntype: http\nconfig:\nport: 6083\nhost: 0.0.0.0\n</code></pre>"},{"location":"vertx-zero-tutorial/d10069-configuration-vertx-serveryml/#1-name","title":"1. name","text":"<p>The <code>name</code> node described the service name in current zero instance, this instance will be mapped to prefix of configuration path as following:</p> <p></p> <p>Here you could see the <code>key</code> column, the prefix <code>up-hecate, up-hyperion, up-lapetus</code> is the name of current configuration. In micro mode, we recommended you to set the name of each node, when the node use vert.x cluster, each name could contain different suffix of <code>host:port</code> configuration information.</p>"},{"location":"vertx-zero-tutorial/d10069-configuration-vertx-serveryml/#2-type","title":"2. type","text":"<p>Here the type described supported servers in zero system, current version it supports following values:</p> <ul> <li>http: Http Server</li> <li>sock: Websock Server</li> <li>rx: Rx Http Server ( In development Progress, design finished only )</li> <li>ipc: Rpc Server</li> <li>api: Api Gateway ( Micro mode only )</li> </ul> <p>Each zero instance support one instance of each type, if you defined new <code>http</code> server, your configuration will overwrite the default.</p>"},{"location":"vertx-zero-tutorial/d10069-configuration-vertx-serveryml/#3-config","title":"3. config","text":"<p>This config node contains the options of each server type, the option will be mapped to native vert.x class: <code>io.vertx.core.http.HttpServerOptions</code> , when you set each server type, the <code>port</code> and <code>host</code> keys are  required under config node.</p>"},{"location":"vertx-zero-tutorial/d10069-configuration-vertx-serveryml/#4-summary","title":"4. Summary","text":"<p>This chapter we focus on <code>vertx-server.yml</code> to set configuration of each zero instance, you should know how to configure the server in zero.</p>"},{"location":"vertx-zero-tutorial/d10070-configuration-vertx-injectyml/","title":"Configuration, vertx-inject.yml","text":"<p>This configuration up.god.file provide extension system especially for vert.x native components. The default content is as following:</p> <pre><code>logger: io.horizon.log.internal.Log4JAnnal\n</code></pre> <p>It's the only one component that enabled by default, you can replace this component by yourself when you want to use ELK or other logger. This chapter we'll focus on frequently used <code>injection</code> component so that you could know how to set the configuration in zero system.</p> <p>The data format of <code>vertx-inject.yml</code> is simple and it's <code>key: value</code> format.</p>"},{"location":"vertx-zero-tutorial/d10070-configuration-vertx-injectyml/#1-infixes","title":"1. Infixes","text":""},{"location":"vertx-zero-tutorial/d10070-configuration-vertx-injectyml/#11-jooq","title":"1.1. jooq","text":"<p>If you want to use Jooq extension, you can add following:</p> <pre><code>jooq: io.vertx.tp.plugin.jooq.JooqInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10070-configuration-vertx-injectyml/#12-mongo","title":"1.2. mongo","text":"<pre><code>mongo: io.vertx.tp.plugin.mongo.MongoInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10070-configuration-vertx-injectyml/#13-mysql","title":"1.3. mysql","text":"<pre><code>mysql: io.vertx.up.plugin.jdbc.MySqlInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10070-configuration-vertx-injectyml/#14-rpc","title":"1.4. rpc","text":"<p>When you set zero micro system, following rpc injection is required for service communication</p> <pre><code>rpc: io.vertx.tp.plugin.rpc.RpcInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10070-configuration-vertx-injectyml/#4-summary","title":"4. Summary","text":"<p>Current zero system support above four standard infixes only, all above infixed should be enabled by yourself when you want to use it, it's related to different business requirements, zero system does not enable these features automatically. For some detail usage we'll introduce in further tutorials.</p>"},{"location":"vertx-zero-tutorial/d10071-configuration-vertx-erroryml/","title":"Configuration, vertx-error.yml","text":"<p>In zero system, it provide standard error system and extended error configuration, the up.god.file <code>vertx-error.yml</code> could let you to set the errors that you want to defined.</p>"},{"location":"vertx-zero-tutorial/d10071-configuration-vertx-erroryml/#1-content-segment","title":"1. Content Segment","text":"<pre><code># Core configuration Error\nE30001: Vert.x zero server config is missing in current data \"{0}\"\n# Configuration validation Error\nE10001: (V) - This rule require all elements of array is JsonObject, Now the index = {0} does not match, it''s {1}\nE10002: (V) - The data object {0} missed required field \"{1}\"\nE10003: (V) - The field {0} value is \"{1}\", but expected type is \"{2}\"\nE10004: (V) - The cluster options is enabled, but the \"{0}\" vertx instance = \"{1}\"\nE10005: (V) - The dynamic key \"{0}\" missing in uniform extension configuration data {1}\nE10006: (V) - The data object {0} contains unsupported/forbidden field \"{1}\"\n# .........\n</code></pre> <p>All above error codes will be mapped to zero system internally, we'll introduce the error codes in forward tutorials.</p>"},{"location":"vertx-zero-tutorial/d10071-configuration-vertx-erroryml/#2-abstract-exception","title":"2. Abstract Exception","text":"<p>In zero system, the most used abstract abstract exception are following:</p> <ul> <li><code>io.horizon.exception.WebException</code></li> <li><code>io.horizon.exception.UpException</code></li> </ul> <p>The <code>WebException</code> controlled the web request flow exceptions, and the <code>UpException</code> controlled the zero start up exceptions, they are all runtime, zero system does not throw out these exceptions except some critical issue happened, all the error response came from <code>WebException</code> and could provide normalized response to client.</p>"},{"location":"vertx-zero-tutorial/d10071-configuration-vertx-erroryml/#3-error-codes","title":"3. Error Codes","text":"<p>Here are the error code area that we designed:</p> <ul> <li><code>-10001 ~ -19999</code>: The configuration data validation such as required config key, config key data type, data format   etc.</li> <li><code>-20001 ~ -29999</code>: The third part errors such as Qiy, QQ, Wechat etc.</li> <li><code>-30001 ~ -39999</code>: Critical system error, these exceptions may be <code>WebException</code> or <code>UpException</code>, they are all   internally.</li> <li><code>-40001 ~ -49999</code>: All the <code>UpException</code> sub exceptions that may impact zero system starting up.</li> <li><code>-50001 ~ -59999</code>: ( Reserved ) All the <code>Rx</code> mode exceptions, it's used in future plan.</li> <li><code>-60001 ~ -69999</code>: All the <code>WebException</code> that are provided by zero system internally, it's defined some standard web   request exceptions in zero system.</li> </ul> <p>If you want to define zero system exceptions that you wanted, you should set the error code start with <code>-100001</code>, if you overwrite the error code of system internally, it may be bad things for you do to debugging.</p>"},{"location":"vertx-zero-tutorial/d10071-configuration-vertx-erroryml/#4-summary","title":"4. Summary","text":"<p>This chapter described some specific error definition rules in zero system, in forward tutorials we'll introduce how to define error in zero system then you could reply to client the normalized error response with correct Http Status Code.</p>"},{"location":"vertx-zero-tutorial/d10072-configuration-vertx-mysqlyml/","title":"Configuration, vertx-mysql.yml","text":"<p>In zero system, if you do not use <code>Jooq</code> to access database, you can use native <code>SQLClient</code> here, all the official client contains standard annotations, but this chapter we introduce the mysql configuration only. Reference.</p>"},{"location":"vertx-zero-tutorial/d10072-configuration-vertx-mysqlyml/#1-configuration","title":"1. Configuration","text":""},{"location":"vertx-zero-tutorial/d10072-configuration-vertx-mysqlyml/#11-vertxyml","title":"1.1. vertx.yml","text":"<pre><code>zero:\nlime: mysql\nvertx:\ninstance:\n- name: vx-zero\noptions:\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10072-configuration-vertx-mysqlyml/#12-vertx-injectyml","title":"1.2. vertx-inject.yml","text":"<pre><code>mysql: io.vertx.up.plugin.jdbc.MySqlInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10072-configuration-vertx-mysqlyml/#13-vertx-mysqlyml","title":"1.3. vertx-mysql.yml","text":"<p>All the mysql configurations are put into <code>vertx-mysql.yml</code> the root node <code>mysql</code> as following:</p> <pre><code>mysql:\nhost: localhost\nport: 3306\nusername: root\npassword: root\ndatabase: DB_ZERO\n</code></pre> <p>Above all keys are vert.x native configuration and it could be passed into vert.x mysql client directly, you can refer the link to check all the valid configuration information: http://vertx.io/docs/vertx-mysql-postgresql-client/java/#_configuration</p>"},{"location":"vertx-zero-tutorial/d10072-configuration-vertx-mysqlyml/#2-summary","title":"2. Summary","text":"<p>Here are the mysql standalone configuration part and in forward tutorials we'll introduce the client usage in zero system. The limitation here is that current version one zero system could support one mysql database only, you could not connect to multi database with zero system at the same time.</p>"},{"location":"vertx-zero-tutorial/d10073-configuration-vertx-mongoyml/","title":"Configuration, vertx-mongo.yml","text":"<p>Another native client that zero system supported is <code>MongoClient</code> in vert.x, Reference. You can read current tutorials to check the details about how to configure mongo client in zero system.</p>"},{"location":"vertx-zero-tutorial/d10073-configuration-vertx-mongoyml/#1-configuration","title":"1. Configuration","text":""},{"location":"vertx-zero-tutorial/d10073-configuration-vertx-mongoyml/#11-vertxyml","title":"1.1. vertx.yml","text":"<p>Be sure the extension up.god.file name existing in <code>lime</code> node in the major configuration</p> <pre><code>zero:\nlime: mongo\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10073-configuration-vertx-mongoyml/#12-vertx-injectyml","title":"1.2. vertx-inject.yml","text":"<pre><code>mongo: io.vertx.tp.plugin.mongo.MongoInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10073-configuration-vertx-mongoyml/#13-vertx-mongoyml","title":"1.3. vertx-mongo.yml","text":"<pre><code>mongo:\ndb_name: ZERO_MESH\nport: 6017\nhost: 127.0.0.1\nconnection_string: mongodb://localhost:6017\n</code></pre> <p>Just like <code>vertx-mysql.yml</code> configuration, here all the <code>mongo</code> node keys are native supported by vert.x, you can provide all the native configuration keys here for mongo db, please refer http://vertx.io/docs/vertx-mongo-client/java/#_configuring_the_client .</p>"},{"location":"vertx-zero-tutorial/d10073-configuration-vertx-mongoyml/#2-summary","title":"2. Summary","text":"<p>Here are the mongo db standalone configuration part and in forward tutorials we'll introduce the client usage in zero system.</p>"},{"location":"vertx-zero-tutorial/d10074-configuration-vertx-etcd3yml/","title":"Configuration, vertx-etcd3.yml","text":"<p>When zero system is running in micro service mode, you should configure Registry Center ( Etcd3 in zero ), you can refer current tutorials to check etcd3 configuration.</p> <p>For etcd3 configuration, you can refer following three links</p> <ul> <li>etcd3: https://github.com/coreos/etcd</li> <li>e3w: ( Recommend Standalone ) https://github.com/soyking/e3w</li> <li>etcd-viewer: https://github.com/nikfoundas/etcd-viewer</li> </ul> <p>Above three etcd github address could help you to build etcd environment, we'll introduce some more details in forward tutorials as well, this chapter we focus on zero etcd configuration only.</p> <p>Etcd configuration is enabled in micro service only.</p>"},{"location":"vertx-zero-tutorial/d10074-configuration-vertx-etcd3yml/#1-configuration","title":"1. Configuration","text":""},{"location":"vertx-zero-tutorial/d10074-configuration-vertx-etcd3yml/#11-vertxyml","title":"1.1. vertx.yml","text":"<pre><code>zero:\nlime: etcd3\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10074-configuration-vertx-etcd3yml/#12-vertx-etcd3yml","title":"1.2. vertx-etcd3.yml","text":"<p>Because etcd3 act as Service Registry Center only and it's invisible to developers, there is no <code>Infix</code> to let you to visit etcd directly, the second part of etcd3 configuration is as following:</p> <pre><code>etcd:\nmicro: zero-istio\nnodes:\n- host: localhost\nport: 6181\n- host: localhost\nport: 6180\n- host: localhost\nport: 6179\ntimeout: 2\n</code></pre> <p>Above configuration described <code>etcd</code> client configuration, there are three nodes <code>6181, 6180, 6179</code>, you can configure these information by yourself. Once thing you should be careful is the <code>micro</code> key, it's the micro-service cluster name, it looks like a configuration root for all your micro services, be sure all the micro services that belong to one Application connect to the same <code>micro</code> etcd. Different <code>micro</code> in zero could not share the resources.</p> <p></p> <p>As above screen shot show, <code>zero-istio</code> is running more than one micro services, but it's completed an application, for other projects or other application such as <code>zero-hotel</code>, they may still run zero micro services or other applications. All the zero micro services that belong to <code>zero-istio</code> configuration have been put under the path <code>/zero/zero-istio</code> in etcd.</p>"},{"location":"vertx-zero-tutorial/d10074-configuration-vertx-etcd3yml/#2-summary","title":"2. Summary","text":"<p>Above all are the configuration part of etcd in micro service mode, once you have configure this part, the micro service mode will be enabled. zero system detected your application by <code>lime</code> to check whether you enabled etcd configuration.</p> <ul> <li><code>etcd</code> enabled: Your zero app will run in micro service mode.</li> <li><code>etcd</code> disabled: Your zero app will run in standalone.</li> </ul> <p>As we known, the same roles of <code>etcd</code> could be implemented by <code>zookeeper, consul</code> , but zero system will run inner <code>k8s</code> and <code>istio</code>, <code>k8s</code> used etcd as default, we have bind this component with <code>k8s</code> for future usage.</p>"},{"location":"vertx-zero-tutorial/d10075-configuration-vertx-rpcyml/","title":"Configuration, vertx-rpc.yml","text":"<p>In micro service mode, zero system has implemented simple rpc communication between different services, when you want to connect other services, you should set the <code>rpc</code> configuration.</p> <p>Rpc Client is enabled in micro service mode only.</p>"},{"location":"vertx-zero-tutorial/d10075-configuration-vertx-rpcyml/#1-configuration","title":"1. Configuration","text":""},{"location":"vertx-zero-tutorial/d10075-configuration-vertx-rpcyml/#11-vertxyml","title":"1.1. vertx.yml","text":"<pre><code>zero:\nlime: rpc\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10075-configuration-vertx-rpcyml/#12-vertx-rpcyml","title":"1.2. vertx-rpc.yml","text":"<pre><code>rpc:\nssl: false\nuniform:\ntype: PEM\nextension:\n{name}:\ntype: XXX\n</code></pre> <p>Please be careful about the attributes<code>uniform</code>and<code>extension</code>it's the same except following:</p> <ul> <li>The system will scan all client configuration under extension by name setted first. For example the target name is   <code>up-ceous</code>, you must set {name} to<code>up-ceous</code>, then when current service communicate with up-ceous service, the   client configuration will use it under extension instead of uniform .</li> <li>If there is no configuration under extension, the uniform configuration will be used. uniform just like default client   configuration.</li> </ul> <p>This configuration up.god.file is only used in SSL mode.</p>"},{"location":"vertx-zero-tutorial/d10075-configuration-vertx-rpcyml/#2-full-examples","title":"2. Full Examples","text":"<p>You can ignore the details of the example, this chapter focus on rpc client only, we'll introduce rpc server configuration in forward.</p> <p><pre><code>## vertx-server.yml\n# Rpc Server with PEM ( OpenSSLEngine )\n- name: ipc-cronus\ntype: ipc\nconfig:\nport: 6883\nhost: 0.0.0.0\nssl: true\ntype: PEM\ncert: tlk/server-cert.pem\nkey: tlk/server-key.pem\n# Rpc Server with Jsk ( JSKEngine )\n- name: ipc-cronus\ntype: ipc\nconfig:\nport: 6883\nhost: 0.0.0.0\nssl: true\ntype: JKS\njsk: tlk/server-key.jks\npassword: wibble\n</code></pre> <pre><code>## vertx-rpc.yml ( The name depend on lime )\n# Rpc Client use default\nrpc:\nssl: true\nuniform:\ntype: PEM\ncert: tlk/server-cert.pem\nkey: tlk/server-key.pem\n</code></pre> <pre><code># Rpc Client with spec service\nrpc:\nssl: true\nuniform:\ntype: PEM\ncert: tlk/server-cert.pem\nkey: tlk/server-key.pem\nextension:\nup-cerous:\ntype: JKS\njsk: tlk/server-key.jks\npassword: wibble\n</code></pre></p>"},{"location":"vertx-zero-tutorial/d10075-configuration-vertx-rpcyml/#3-summary","title":"3. Summary","text":"<p>Rpc client is a critical role in zero system to finish service communicating works, you should know how to configure different roles of rpc.</p> <ul> <li>Rpc Server</li> <li>Rpc Client</li> </ul> <p>Once you have configured above two parts in different micro services, these services could communicate internally directly in zero system. You can say goodbye to old Http EndPoint communication internally.</p>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/","title":"Vert.x Native, MySqlClient","text":"<p>In zero system, we consider more freedom to developers, in this kind of situation, it provide the specific injection for native clients such as following:</p> <p>Zero system fully supported vert.x clients here. this chapter we'll focus on MySqlClient to connect existing database.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6073: <code>up-gaea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#1-configuration","title":"1. Configuration","text":"<p>This chapter is duplicated with D10072 - Configuration, vertx-mysql.yml, because that's the preparing steps for mysql client.</p>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#11-vertxyml","title":"1.1. vertx.yml","text":"<pre><code>zero:\nlime: mysql\nvertx:\ninstance:\n- name: vertx-zeus\noptions:\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#12-vertx-injectyml","title":"1.2. vertx-inject.yml","text":"<pre><code>mysql: io.vertx.up.plugin.jdbc.MySqlInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#13-vertx-mysqlyml","title":"1.3. vertx-mysql.yml","text":"<p>All the mysql configurations are put into <code>vertx-mysql.yml</code> the root node <code>mysql</code> as following:</p> <pre><code>mysql:\nhost: localhost\nport: 3306\nusername: htl\npassword: \"pl,okmijn123\"\ndatabase: DB_ZERO\nprovider_class: \"io.vertx.ext.jdbc.spi.impl.HikariCPDataSourceProvider\"\n</code></pre> <p>All above configuration is for mysql native configuration supported, but for <code>up-gaea</code> project, there need some additional configuration ( Server Config ).</p>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#2-server-configuration","title":"2. Server Configuration","text":""},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#vertx-serveryml","title":"vertx-server.yml","text":"<pre><code>server:\n- name: up-gaea\ntype: http\nconfig:\nport: 6073\nhost: 0.0.0.0\n</code></pre> <p>Finally when you have finished configuration, the folder structure of project should be as following:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#3-source-code","title":"3. Source Code","text":""},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#31-api","title":"3.1. Api","text":"<pre><code>package up.god.micro.tabular;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface DbApi {\n@Path(\"native/{type}\")\n@GET\n@Address(\"ZERO://QUEUE/NATIVE/GET\")\nString sayDb(@PathParam(\"type\") String type);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#32-consumer","title":"3.2. Consumer","text":"<pre><code>package up.god.micro.tabular;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.ext.sql.ResultSet;\nimport io.vertx.ext.sql.SQLClient;\nimport io.vertx.up.aiki.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.atom.Envelop;\nimport javax.inject.infix.MySql;\n@Queue\npublic class DbWorker {\n@MySql\nprivate transient SQLClient client;\n@Address(\"ZERO://QUEUE/NATIVE/GET\")\npublic void sayDb(final Message&lt;Envelop&gt; message) {\nfinal String type = Ux.getString(message);\nthis.client.queryWithParams(\"SELECT * FROM SYS_TABULAR WHERE S_TYPE=?\",\nnew JsonArray().add(type), handler -&gt; {\n// Success or Failure\nif (handler.succeeded()) {\nfinal ResultSet res = handler.result();\n// Build result json array\nfor (final JsonArray item : res.getResults()) {\nSystem.out.println(item);\n}\nmessage.reply(Envelop.success(res.getResults()));\n} else {\n// Replied with error, now only print stack\nhandler.cause().printStackTrace();\nmessage.reply(Envelop.ok());\n}\n});\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#4-console","title":"4. Console","text":"<p>When you start this application you should see following logs:</p> <pre><code>infix-afflux-runner            | io.vertx.ext.asyncsql.impl.MYSQLClientImpl                   -| \\\nCreating configuration for localhost:3306\n</code></pre> <p>It means that the connection has been built, then when you send following request, you should get the data as following:</p> <p>URL : http://localhost:6073/api/native/room.status</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": [\n[\n8,\nnull,\n\"\u53ef\u64cd\u4f5c\",\n\"Operation\",\nnull,\n\"room.status\",\n\"{\\\"visible\\\":false}\",\n1,\n1,\n\"ENhwBAJPZuSgIAE5EDakR6yrIQbOoOPq\",\n\"cn\",\nnull,\n\"2018-02-07T04:09:32.000\",\nnull,\nnull\n],\n......\n]\n]\n</code></pre>"},{"location":"vertx-zero-tutorial/d10076-vertx-native-mysqlclient/#5-summary","title":"5. Summary","text":"<p>Here are some points need to be mention.</p> <ol> <li>There is an annotation <code>javax.inject.infix.MySql</code> could be used to inject SQLClient, it's the same as <code>@Inject</code> of    JSR303, but you must be sure your configuration of MySql has been setup correctly.</li> <li>Another thing is that here we used <code>io.vertx.ext.sql.SQLClient</code> to hold the created reference, it's not the reference    of <code>io.vertx.ext.asyncsql.MySQLClient</code> because the native vert.x document    mentioned: http://vertx.io/docs/vertx-mysql-postgresql-client/java/#_specifying_a_pool_name</li> <li>The last point is that it's best to use <code>Envelop.success</code> to build response and let message replied, do not reply the    data directly, you can pass any type of data into <code>Envelop.success</code> method.</li> </ol> <p>\u0000</p>"},{"location":"vertx-zero-tutorial/d10077-third-part-mongo-setup/","title":"Reference, Mongo Setup","text":"<p>This chapter belong to third part tutorial, not related to zero system here, but we ignored all third part installing steps. For mongo db part, once you finished installing, you can set the configuration and start up shell script as following:</p> <pre><code>OS: MacOS 10.13.3\nMongoConf: /usr/local/etc/mongod.conf\nShell: vie-mongo.sh\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-third-part-mongo-setup/#1-conf-file","title":"1. Conf File","text":"<p>You can set default mongo db configuration via conf up.god.file <code>/usr/local/etc/mongod.conf</code>, the content is as following:</p> <pre><code>systemLog:\ndestination: up.god.file\npath: /Users/lang/Runtime/service-mesh/mongodb/logs/mongo.log\nlogAppend: true\nstorage:\ndbPath: /Users/lang/Runtime/service-mesh/mongodb/db/\nnet:\nbindIp: 127.0.0.1\nport: 6017\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-third-part-mongo-setup/#2-start-up","title":"2. Start Up","text":"<p>Then write executed script <code>vie-mongo.sh</code> as following ( Authorization Enabled ) :</p> <pre><code>#!/usr/bin/env bash\nmongod --auth --config /usr/local/etc/mongod.conf\n</code></pre> <p>When you started mongo db, you should see the logs as following:</p> <pre><code>2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] MongoDB starting : pid=31638 port=6017 dbpath=/Users/lang/Runtime/service-mesh/mongodb/db/ 64-bit host=LangdeMacBook-Pro.local\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] db version v3.6.2\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] git version: 489d177dbd0f0420a8ca04d39fd78d0a2c539420\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2n  7 Dec 2017\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] allocator: system\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] modules: none\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] build environment:\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten]     distarch: x86_64\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten]     target_arch: x86_64\n2018-02-11T16:29:24.457+0800 I CONTROL  [initandlisten] options: { config: \"/usr/local/etc/mongod.conf\", net: { bindIp: \"127.0.0.1\", port: 6017 }, security: { authorization: \"enabled\" }, storage: { dbPath: \"/Users/lang/Runtime/service-mesh/mongodb/db/\" }, systemLog: { destination: \"up.god.file\", logAppend: true, path: \"/Users/lang/Runtime/service-mesh/mongodb/logs/mongo.log\" } }\n2018-02-11T16:29:24.458+0800 I -        [initandlisten] Detected data files in /Users/lang/Runtime/service-mesh/mongodb/db/ created by the 'wiredTiger' storage engine, so setting the active storage engine to 'wiredTiger'.\n2018-02-11T16:29:24.458+0800 I STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=7680M,session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),statistics_log=(wait=0),verbose=(recovery_progress),\n2018-02-11T16:29:24.622+0800 I STORAGE  [initandlisten] WiredTiger message [1518337764:622115][31638:0x7fff90dbb340], txn-recover: Main recovery loop: starting at 46/10496\n2018-02-11T16:29:24.716+0800 I STORAGE  [initandlisten] WiredTiger message [1518337764:716386][31638:0x7fff90dbb340], txn-recover: Recovering log 46 through 47\n2018-02-11T16:29:24.782+0800 I STORAGE  [initandlisten] WiredTiger message [1518337764:782052][31638:0x7fff90dbb340], txn-recover: Recovering log 47 through 47\n2018-02-11T16:29:25.037+0800 I FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory '/Users/lang/Runtime/service-mesh/mongodb/db/diagnostic.data'\n2018-02-11T16:29:25.038+0800 I NETWORK  [initandlisten] waiting for connections on port 6017\n</code></pre> <p>Be sure you could see the segment <code>security: { authorization: \"enabled\" }</code></p>"},{"location":"vertx-zero-tutorial/d10077-third-part-mongo-setup/#3-create-account","title":"3. Create Account","text":"<p>1 - connect to mongo db with <code>mongo</code> command:</p> <pre><code>\u279c  ~ mongo localhost:6017\nMongoDB shell version v3.6.2\nconnecting to: mongodb://localhost:6017/test\nMongoDB server version: 3.6.2\n&gt;\n</code></pre> <p>2 - switch default database <code>admin</code></p> <pre><code>&gt; use admin\nswitched to db admin\n</code></pre> <p>3 - database authorized and login:</p> <pre><code>&gt; db.auth(\"admin\",\"admin\")\n1\n</code></pre> <p>4 - switch to database <code>ZERO_MESH</code></p> <pre><code>&gt; use ZERO_MESH\nswitched to db ZERO_MESH\n</code></pre> <p>5 - create user for <code>ZERO_MESH</code> database with following:</p> <pre><code>&gt; db.createUser({ user:'zero_mongo',pwd:'zero_mongo',roles:[{role:'dbOwner',db:'ZERO_MESH'}]});\nSuccessfully added user: {\n\"user\" : \"zero_mongo\",\n    \"roles\" : [\n{\n\"role\" : \"dbOwner\",\n            \"db\" : \"ZERO_MESH\"\n}\n]\n}\n</code></pre> <p>6 - check the results, please be sure <code>_id</code> contains the prefix of database name is not <code>admin</code> here.</p> <pre><code>&gt; use admin\nswitched to db admin\n&gt; db.system.users.find({user:'zero_mongo'});\n{ \"_id\" : \"ZERO_MESH.zero_mongo\", \"user\" : \"zero_mongo\", \"db\" : \"ZERO_MESH\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"UO+X+9i/uAqGXQ2EIliRVg==\", \"storedKey\" : \"oK3WotUQHTs3dvpNeLHiYzTgP4w=\", \"serverKey\" : \"+Hgbv9XO2NRfRe7ZFa0DVsyRCJo=\" } }, \"roles\" : [ { \"role\" : \"dbOwner\", \"db\" : \"ZERO_MESH\" } ] }\n</code></pre> <p>7 - database authorized with new created user</p> <pre><code>&gt; use ZERO_MESH\nswitched to db ZERO_MESH\n&gt; db.auth(\"zero_mongo\",\"zero_mongo\");\n1\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-third-part-mongo-setup/#4-summary","title":"4. Summary","text":"<p>Then you can connect with some mongo client such as Compass to connect to this database, your mongo db has been configured successfully.</p> <p>Step 1:</p> <p></p> <p>Step 2:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/","title":"Vert.x Native, MongoClient","text":"<p>For mongo db configuration you could refer previous tutorials D10077 - Reference, Mongo Setup to check more details, now this chapter we'll go back to zero system to see how to enable vert.x native client for mongo db.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6073: <code>up-gaea</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#1-configuration","title":"1. Configuration","text":"<p>This chapter is duplicated with D10073 - Configuration, vertx-mongo.yml, because that's the preparing steps for mysql client.</p>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#11-vertxyml","title":"1.1. vertx.yml","text":"<pre><code>zero:\nlime: mysql, mongo\nvertx:\ninstance:\n- name: vertx-zeus\noptions:\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#12-vertx-injectyml","title":"1.2. vertx-inject.yml","text":"<pre><code>mongo: io.vertx.tp.plugin.mongo.MongoInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#13-vertx-mongoyml","title":"1.3. vertx-mongo.yml","text":"<p>All the mongo configurations are put into <code>vertx-mongo.yml</code> the root node <code>mongo</code> as following:</p> <pre><code>mongo:\ndb_name: ZERO_MESH\nport: 6017\nhost: 127.0.0.1\nconnection_string: mongodb://localhost:6017\nusername: zero_mongo\npassword: zero_mongo\n</code></pre> <p>All above configuration is for mongo native configuration supported, but for <code>up-gaea</code> project, there need some additional configuration ( Server Config ).</p>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#2-server-configuration","title":"2. Server Configuration","text":""},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#vertx-serveryml","title":"vertx-server.yml","text":"<pre><code>server:\n- name: up-gaea\ntype: http\nconfig:\nport: 6073\nhost: 0.0.0.0\n</code></pre> <p>Finally when you have finished configuration, the folder structure of project should be as following:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#3-source-code","title":"3. Source Code","text":""},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#31-api","title":"3.1. Api","text":"<pre><code>package up.god.micro.mongo;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic interface MongoApi {\n@Path(\"native/test\")\n@POST\n@Address(\"ZERO://QUEUE/NATIVE/MONGO\")\nJsonObject sayMongo(@BodyParam JsonObject params);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#32consumer","title":"3.2.Consumer","text":"<pre><code>package up.god.micro.mongo;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.mongo.MongoClient;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport javax.inject.infix.Mongo;\n@Queue\npublic class MongoWorker {\n@Mongo\nprivate transient MongoClient client;\n@Address(\"ZERO://QUEUE/NATIVE/MONGO\")\npublic void sayMongo(final Message&lt;Envelop&gt; message) {\nfinal JsonObject data = Ux.getJson(message);\nthis.client.insert(\"DB_TEST\", data, res -&gt; {\nif (res.succeeded()) {\nSystem.out.println(res.result());\nmessage.reply(Ux.to(data));\n} else {\nres.cause().printStackTrace();\nmessage.reply(Envelop.ok());\n}\n});\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#4-console","title":"4. Console","text":"<p>When you started the application you should see following output:</p> <pre><code>......\nCluster created with settings {hosts=[localhost:6017], mode=SINGLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}\nOpened connection [connectionId{localValue:1, serverValue:5}] to localhost:6017\nMonitor thread successfully connected to server with description ServerDescription{address=localhost:6017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[3, 6, 2]}, minWireVersion=0, maxWireVersion=6, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=5597013}\n......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#5-testing","title":"5. Testing","text":"<p>Then you could test with postman</p> <p>URL : http://localhost:6073/api/native/test</p> <p>Method : POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"Lang\",\n\"password\":\"pl,okmijnuhb123\",\n\"email\":\"lang.yu@email.com\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"username\": \"Lang\",\n\"password\": \"pl,okmijnuhb123\",\n\"email\": \"lang.yu@email.com\",\n\"_id\": \"5a8011506b0f4bc139b3f6ce\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10077-vertx-native-mongoclient/#6-summary","title":"6. Summary","text":"<p>Here this record has been added into mongo database, you can check the result from mongo db:</p> <p></p> <p>The record is you added in just request.</p>"},{"location":"vertx-zero-tutorial/d10079-reference-mini-k8s/","title":"Reference, Mini k8s","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:3d6e92829d619157b4386950a920cf6e8047ffe86f7a7dbfbfb42f7d75c92922 size 2654</p>"},{"location":"vertx-zero-tutorial/d10080-reference-istio/","title":"Reference, Istio","text":"<p>Quick Start</p> <p>Demo example will be install istio to <code>~/Tool/Zero/</code></p>"},{"location":"vertx-zero-tutorial/d10080-reference-istio/#1-environment-preparing","title":"1. Environment Preparing","text":"<p>1 - Install and download istio</p> <pre><code>curl -L https://git.io/getLatestIstio | sh -\n...... # Wait for ISO up.god.file downloading finished.\n</code></pre> <p>2 - Set Up environment.</p> <pre><code>Add /Users/lang/Tool/Zero/istio-0.2.12/bin to your path; \\\ne.g copy paste in your shell and/or ~/.profile:\nexport PATH=\"$PATH:/Users/lang/Tool/Zero/istio-0.2.12/bin\"\n# Then be sure the command \"istioctl\" could be used. ( Latest 0.2.12 )\nistioctl version\nVersion: 0.2.12\nGitRevision: 998e0e00d375688bcb2af042fc81a60ce5264009\nGitBranch: release-0.2\nUser: releng@0d29a2c0d15f\nGolangVersion: go1.8\n</code></pre> <p>3 - Install \"istio\" on local k8s</p> <pre><code>&gt;&gt; cd istio-0.2.12\n\n&gt;&gt; pwd\n/Users/lang/Tool/Zero/istio-0.2.12\n\n&gt;&gt; kubectl get svc -n istio-system\nNo resources found.\n\n&gt;&gt; kubectl apply -f install/kubernetes/istio.yaml ( None TLS mode )\nnamespace \"istio-system\" created\n...... ( All the progress logs will be output )\ndeployment \"istio-ca\" created\n</code></pre> <p>4 - Ensure the four services: <code>istio-pilot, istio-mixer, istio-ingress, istio-egress</code></p> <pre><code>&gt;&gt; kubectl get svc -n istio-system\nNAME            TYPE           CLUSTER-IP       ......\nistio-egress    ClusterIP      10.97.67.39     ......\nistio-ingress   LoadBalancer   10.111.235.49   ......\nistio-mixer     ClusterIP      10.106.88.96    ......\nistio-pilot     ClusterIP      10.106.188.200  ......\n&gt;&gt; kubectl get pods -n istio-system\nistio-ca-5cd46b967c-kmx58        1/1       Running   0          4m\nistio-egress-56c4d999bc-dv8md    1/1       Running   0          4m\nistio-ingress-5747bb855f-n74sz   1/1       Running   0          4m\nistio-mixer-77487797f6-d5ns9     2/2       Running   0          4m\nistio-pilot-86ddcb7ff5-cmcr5     1/1       Running   0          4m\n</code></pre>"},{"location":"vertx-zero-tutorial/d10080-reference-istio/#2-summary","title":"2. Summary","text":"<p>Then when you see above output, you can select <code>isito-system</code> namespace in the dashboard to check the result:</p> <p>When you see above screen shot it means that the istio has been run in mini k8s environment.</p>"},{"location":"vertx-zero-tutorial/d10081-reference-istio-addon/","title":"Reference, Istio Addon","text":"<p>If you want to enable metrics collection, you can do as following:</p> <p>Reference</p> <pre><code>kubectl apply -f install/kubernetes/addons/prometheus.yaml\nkubectl apply -f install/kubernetes/addons/grafana.yaml\nkubectl apply -f install/kubernetes/addons/servicegraph.yaml\n</code></pre> <p>It may take some time to process all the components installed.</p>"},{"location":"vertx-zero-tutorial/d10081-reference-istio-addon/#1-install-grafana","title":"1. Install Grafana","text":"<p>1 - You can type following command to configure port-forwarding for <code>grafana</code></p> <pre><code>kubectl -n istio-system port-forward \\\n$(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') \\\n3000:3000 &amp;\n</code></pre> <p>2 - Then open uri <code>http://localhost:3000/dashboard/db/istio-dashboard</code> with your browser, you should see following page:</p>"},{"location":"vertx-zero-tutorial/d10081-reference-istio-addon/#2-install-service-graph","title":"2. Install Service Graph","text":"<p>1 - You can type following command to configure port-forwarding for <code>servicegraph</code></p> <pre><code>kubectl -n istio-system port-forward \\\n$(kubectl get pod -n istio-system -l app=servicegraph -o jsonpath='{.items[0].metadata.name}') \\\n8088:8088 &amp;\n</code></pre> <p>2 - The open url <code>http://localhost:8088/dotviz</code> or <code>http://localhost:8088/graph</code> with your browser, if there exist the services, you should see JSON data or graph.</p>"},{"location":"vertx-zero-tutorial/d10081-reference-istio-addon/#3-zipkin-dashboard","title":"3. Zipkin Dashboard","text":"<p>1 - You can type following command to configure port-forwarding for <code>zipkin</code></p> <pre><code>kubectl -n istio-system port-forward \\\n$(kubectl get pod -n istio-system -l app=zipkin -o jsonpath='{.items[0].metadata.name}') \\\n9411:9411 &amp;\n</code></pre> <p>2 - Then open uri <code>http://localhost:9411/zipkin/</code> with your browser, you should see following page:</p>"},{"location":"vertx-zero-tutorial/d10081-reference-istio-addon/#4-prometheus","title":"4. Prometheus","text":"<p>1 - You can type following command to configure port-forwarding for <code>prometheus</code></p> <pre><code> kubectl -n istio-system port-forward \\\n$(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') \\\n9090:9090 &amp;\n</code></pre> <p>2 - Then open uri <code>http://localhost:9090/graph</code> with your browser, you should see following page:</p> <p></p>"},{"location":"vertx-zero-tutorial/d10081-reference-istio-addon/#5-summary","title":"5. Summary","text":"<p>Then the istio addon environment has been finished and prepared.</p>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/","title":"Micro, Environment Preparing","text":"<p>This chapter we focus on zero system micro environment preparing tutorials. Because zero system standard environment is k8s and k8s used Etcd from background, in this kind of situation, zero system also used Etcd as service registry center.</p>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/#1-etcd-docker-environment","title":"1. Etcd Docker Environment","text":"<p>Files: <code>zero-etcd3, zero-etcd3.sh, zero-etcd3-run.sh</code></p>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/#11-dockerfile-zero-etcd3","title":"1.1. Dockerfile ( zero-etcd3 )","text":"<p>Firstly you can prepare a dockerfile as following:</p> <pre><code>FROM quay.io/coreos/etcd:latest\n</code></pre>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/#12-build-image-zero-etcd3sh","title":"1.2. Build Image ( zero-etcd3.sh )","text":"<p>Then you can build new docker image with this shell</p> <pre><code>## zero-etcd3.sh\n#!/usr/bin/env bash\nimg_name=\"etcd3\"\ncontainer_name=up_${img_name}\ndocker stop ${container_name}\ndocker rm ${container_name}\ndocker rmi ${img_name}:latest\n\ndocker build -t ${img_name}:latest -f zero-etcd3 .\ndocker run -d \\\n-p 6179:2379 \\\n-p 6180:2380 \\\n--volume=${DATA_DIR}:/etcd-data \\\n--name ${container_name} ${img_name} \\\n/usr/local/bin/etcd \\\n--initial-cluster ${ETCD_NAME}=http://${ETCD_HOST}:2380 \\\n--initial-advertise-peer-urls http://${ETCD_HOST}:2380 \\\n--data-dir=/etcd-data --name ${ETCD_NAME} \\\n--listen-peer-urls http://${ETCD_HOST}:2380 \\\n--listen-client-urls http://${ETCD_HOST}:2379 \\\n--advertise-client-urls http://${ETCD_HOST}:2379\n</code></pre>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/#13-run-the-image","title":"1.3. Run the image","text":"<p>The last shell is provided to you to run the image.</p> <pre><code>#!/usr/bin/env bash\nexport DATA_DIR=/Users/lang/Runtime/service-mesh/etcd/data\nexport ETCD_NAME=up.zero3\nexport ETCD_HOST=0.0.0.0\n./zero-etcd3.sh\n</code></pre> <p>Another option is that you can refer <code>https://github.com/soyking/e3w</code> to check e3w project, this project could help you to run the mini etcd3 cluster in docker environment instead of single one.</p>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/#2-start-up","title":"2. Start Up","text":"<p>Once you have run the etcd3, you can see following output:</p> <pre><code>etcd_1  | 07:33:39 etcd2 | 2018-02-12 07:33:39.746291 I | raft: raft.node: 9aaf2895bbe4c2bf elected leader aaa18a72e501fa3c at term 92\netcd_1  | 07:33:39 etcd1 | 2018-02-12 07:33:39.746145 I | raft: raft.node: ab243b72cddf9103 elected leader aaa18a72e501fa3c at term 92\netcd_1  | 07:33:39 etcd3 | 2018-02-12 07:33:39.753086 I | etcdserver: published {Name:infra3 ClientURLs:[http://etcd:32379]} to cluster 479a0ce20b62cfb4\netcd_1  | 07:33:39 etcd3 | 2018-02-12 07:33:39.753674 I | embed: ready to serve client requests\netcd_1  | 07:33:39 etcd2 | 2018-02-12 07:33:39.754368 I | etcdserver: published {Name:infra2 ClientURLs:[http://etcd:22379]} to cluster 479a0ce20b62cfb4\netcd_1  | 07:33:39 etcd2 | 2018-02-12 07:33:39.754401 I | embed: ready to serve client requests\netcd_1  | 07:33:39 etcd1 | 2018-02-12 07:33:39.756067 I | embed: ready to serve client requests\netcd_1  | 07:33:39 etcd1 | 2018-02-12 07:33:39.756437 I | etcdserver: published {Name:infra1 ClientURLs:[http://etcd:2379]} to cluster 479a0ce20b62cfb4\netcd_1  | 07:33:39 etcd1 | 2018-02-12 07:33:39.759668 N | embed: serving insecure client requests on [::]:2379, this is strongly discouraged!\netcd_1  | 07:33:39 etcd2 | 2018-02-12 07:33:39.760191 N | embed: serving insecure client requests on [::]:22379, this is strongly discouraged!\netcd_1  | 07:33:39 etcd3 | 2018-02-12 07:33:39.761128 N | embed: serving insecure client requests on [::]:32379, this is strongly discouraged!\n</code></pre> <p>Here you can see <code>etcd1, etcd2, etcd3</code> three threads, and then you can setup etcd-viewer to check etcd3 status: https://github.com/nikfoundas/etcd-viewer. Once thing should be mentioned is that when you use etcd-viewer, you should set local network ip address instead of <code>localhost</code> such as following:</p> <p>Here when you connect etcd with etcd-viewer, you should use <code>192.168.30.25</code> instead of <code>localhost</code>, and you could see <code>zero-istio</code> here, it's demo micro apps.</p>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/#3-architecture","title":"3. Architecture","text":"<p>In zero system, we could configure different zero app ( contains many micro service nodes ) in one etcd, the top configuration path is the name of zero node. You can refer D10074 - Configuration, vertx-etcd3.yml to check etcd3 configuration in zero. Here you could see following configuration information of <code>vertx-etcd3.yml</code> :</p> <pre><code>etcd:\nmicro: zero-istio\nnodes:\n- host: localhost\nport: 6181\n- host: localhost\nport: 6180\n- host: localhost\nport: 6179\ntimeout: 2\n</code></pre> <p>Be careful about the <code>micro</code> property, it means that you can run multi Applications on one etcd environment. The micro describes the name for all micro services in one application, different micro name won't be communicated internally in zero system. You must set all your micro services of zero instance with one unique name, the whole architecture is as following:</p> <p>The <code>micro</code> property just like application namespace concept, as above pictures there are two applications: zero-istio and app-tlk, these two applications shared one Etcd3 instance as registry center but these two applications are standalone, could not communicate with gRpc.</p>"},{"location":"vertx-zero-tutorial/d10082-micro-environment-preparing/#4-summary","title":"4. Summary","text":"<p>This chapter focus on micro environment preparing in zero system, you can do as tutorials explained to setup your micro service environment.</p>"},{"location":"vertx-zero-tutorial/d10083-micro-rpc-mode/","title":"Micro, Rpc Mode","text":"<p>In zero system, it support two modes of Rpc:</p> <ul> <li>Stream Mode</li> <li>Direct Mode</li> </ul> <p>Because rpc communication is used in zero different nodes only, we call it <code>IPC</code> -- Internal Process Communication, this channel could help us to do many works in micro service environment.</p>"},{"location":"vertx-zero-tutorial/d10083-micro-rpc-mode/#1-roles","title":"1. Roles","text":"<p>In zero system, it support three rpc nodes, all these nodes contain different roles:</p> <ul> <li>Originator</li> <li>Coordinator</li> <li>Terminator</li> </ul> <p>All these nodes should be configured as <code>rpc server</code> instead of others.</p>"},{"location":"vertx-zero-tutorial/d10083-micro-rpc-mode/#11-configuration","title":"1.1. Configuration","text":"<p>Above three roles could be defined by different attributes, zero system will detect them on your method, another thing is that these roles focus on method instead of service, it means that your method function has the role attribute, but one service could contain <code>Originator, Coordinator, Terminator</code> etc. In the service you can do this configuration as following:</p> <pre><code>    // Originator \n@Ipc(to = \"IPC://EVENT/ADDR\", name = \"ipc-coeus\")\npublic JsonObject ipc(@BodyParam final JsonObject data) ...\n// Coordinator\n@Ipc(value = \"IPC://EVENT/ADDR\",\nname = \"ipc-crius\", to = \"IPC://EVENT/FINAL\")\npublic String send(final Envelop envelop) ...\n// Terminator\n@Ipc(value = \"IPC://EVENT/FINAL\")\npublic String send(final Envelop envelop) ...\n// Terminator -&gt; JVM Specification, single value could be ignored.\n@Ipc(\"IPC://EVENT/FINAL\")\npublic String send(final Envelop envelop) ...\n</code></pre> <p>From above java code you should know the role definition focus on method, when your service contains many classes with different methods, these methods could be different roles.</p>"},{"location":"vertx-zero-tutorial/d10083-micro-rpc-mode/#2-stream-mode","title":"2. Stream Mode","text":"<p>In stream mode, all the data flow should be single direction, it could not be reverted, the data flow is as following:</p> <p></p> <p>Above pictures contains three ipc data flow:</p> <ol> <li><code>Service A -&gt; Service B</code></li> <li><code>Service C -&gt; Service D -&gt; Service B</code></li> <li><code>Service C -&gt; Service D -&gt; Service E -&gt; Service F -&gt; Service B</code></li> </ol> <p>Based on above ipc workflow you should know:</p> <ol> <li><code>Service A &amp; Service C</code> are originator, it means that this role could receive the request from client</li> <li><code>Service B</code> is the terminator, it could reply the final response to client.</li> <li>Other nodes <code>Service F, Service E, Service D</code> are coordinators, they could receive from previous service nodes and    continue to process the method and send the result to the next nodes.</li> </ol>"},{"location":"vertx-zero-tutorial/d10083-micro-rpc-mode/#3-direct-mode","title":"3. Direct Mode","text":"<p>This mode is frequently used in our micro service business requirements, we call Rpc Service directly with rpc client, but in this kind of situation, there is only one role that often be used: Terminator/Coordinator, here the Consumer act as Originator instead, in this kind of situation, it's not needed to provide Originator role.</p> <p></p> <p>This mode is used frequently in zero micro service project.</p>"},{"location":"vertx-zero-tutorial/d10083-micro-rpc-mode/#4-summary","title":"4. Summary","text":"<p>Actually stream mode and direct mode are not conflicts, but for different usage here.</p> <ul> <li>Direct Mode just like the bridge between <code>Consumer</code> and <code>Rpc Node Tier</code>.</li> <li>Stream Mode describes the internal <code>Rpc Node Tier</code> structure for stream data flow use.</li> </ul> <p>You can consider the real business scenario and select the usage.</p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/","title":"Micro, Configuration","text":"<p>From this chapter we'll focus on RPC usage in zero system, because they are micro environment, we need to prepare more service nodes here.</p> <p>Demo Projects and environment</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6201 -- -- up-atlas Common Service 6301 6311 ipc-epimetheus up-epimetheus Originator 6401 6411 ipc-coeus up-coeus Coordinator A 6402 6412 ipc-crius up-crius Coordinator B 6403 6413 ipc-cronus up-cronus Coordinator C 6501 6511 ipc-hecate up-hecate Terminator <p>Why we need so many projects ? Because in micro service tutorials we'll focus on Service Registry, Discovery and Communication, we consider use more projects to describe different scenarios and let developers know how to develop micro services in zero framework.</p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#1-etcd-configuration","title":"1. Etcd Configuration","text":"<p>You can refer D10074 - Configuration, vertx-etcd3.yml tutorials for etcd configuration for zero node. Because of our examples here we listed following different configurations</p> <ul> <li>Api Gateway Configuration</li> <li>Common Service ( None Rpc Server )</li> <li>Service Node ( With Rpc Server, Originator/Coordinator/Terminator )</li> </ul> <p>As we introduced in previous tutorials, here all the configuration for etcd3 should be the same as following, in my demo we used around 3 nodes of etcd <code>6181, 6180, 6179</code>, you can correct the configuration info based on your own environment setting. The last thing is that the <code>micro</code> for all of our zero instances are <code>zero-istio</code>:</p> <p>vertx-etcd3.yml</p> <pre><code>etcd:\nmicro: zero-istio\nnodes:\n- host: localhost\nport: 6181\n- host: localhost\nport: 6180\n- host: localhost\nport: 6179\ntimeout: 2\n</code></pre>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#2-api-gateway-up-athena","title":"2. Api Gateway ( up-athena )","text":""},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#21-configuration","title":"2.1. Configuration","text":"<p>The first thing is that to configure api gateway, the whole <code>src/main/resources</code> folder structure is as following:</p> <p></p> <p>Api gateway will scan etcd service center to see the registered services here,</p> <p>vertx.yml</p> <pre><code>zero:\nlime: etcd3\nvertx:\ninstance:\n- name: zero-micro\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre> <p>vertx-server.yml</p> <pre><code>server:\n- name: up-athena\ntype: api\nconfig:\nport: 6100\nhost: 0.0.0.0\n</code></pre> <p>Be careful of the <code>type</code> property in vertx-server.yml, this property in api gateway must be <code>api</code> instead of <code>http</code>. When your zero instance will run as Api Gateway, you must set unique <code>api</code> configuration in <code>vertx-server.yml</code> up.god.file.</p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#22-console","title":"2.2. Console","text":"<p>When you start zero api gateway, you should see following output message.</p> <pre><code>......\n[ ZERO ] ( node = server, type = API ) filtered configuration port set = [6100].\n......\n[ ZERO ] ( Etcd Center ) Etcd configuration center is enabled !\n[ ZERO ] ( node = server, type = API ) filtered configuration port set = [6100].\n[ ZERO ] ( Etcd Center: zero-istio ) Etcd Client timeout = \"2s\" with nodes = 3\n[ ZERO ] ( Etcd Center ) Etcd network checking has been passed successfully !\nSetting up Etcd4j Netty client\n[ ZERO ] The raw data ( node = circuit, type = Circuit ) before validation is {}.\n......\n[ ZERO ] ( Api Gateway ) ZeroApiAgent has been started successfully. Endpoint: http://0.0.0.0:6100/.\n......\n</code></pre> <p>Then you can wait for some seconds, there should be some additional logs output as following every 3 seconds.</p> <pre><code>vert.x-worker-thread-2 ...... \\\n[ ZERO ] ( Discovery ) Records ( added = 0, updated = 5, deleted = 0 ) have been refreshed! vert.x-worker-thread-3 ...... \\\n[ ZERO ] ( Discovery ) Records ( added = 0, updated = 5, deleted = 0 ) have been refreshed!\n</code></pre> <p>In zero api gateway there are two threads scanned etcd service center every 2 seconds, when you start new service and registry into etcd service center, these two threads will scan the added new threads and put into service discovery in api gateway. In this kind of situation you can implement service up/down at any time.</p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#3-common-up-atlas","title":"3. Common ( up-atlas )","text":""},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#31-configuration","title":"3.1. Configuration","text":"<p>In the example we also started a common service, this service does not expose <code>Rpc</code> port but it will use <code>RpcClient</code> instead.</p> <p></p> <p>vertx.yml</p> <pre><code>zero:\nlime: etcd3, rpc\nvertx:\ninstance:\n- name: zero-micro\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre> <p>vertx-server.yml</p> <pre><code>server:\n- name: up-atlas\ntype: http\nconfig:\nport: 6201\nhost: 0.0.0.0\n</code></pre>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#32-rpc-client","title":"3.2. Rpc Client","text":"<p>There are some new configuration that should be mentioned is that if you want to use <code>RpcClient</code> to call remote rpc services, you must do some additional configuration.</p> <p>From vert.x 3.5.1, the api of Rpc <code>useSsl</code> has been changed and Rpc Server could use <code>HttpServerOptions</code> instead of the old configuration, be careful.</p> <p>vertx-rpc.yml</p> <pre><code>rpc:\nssl: false\nuniform:\ntype: PEM\n</code></pre> <p>vertx-inject.yml</p> <pre><code>rpc: io.vertx.tp.plugin.rpc.RpcInfix\n</code></pre> <p>Above Rpc configuration is required.</p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#33-console","title":"3.3. Console","text":"<p>When you started this service, you should see more logs output that you haven't seen before:</p> <pre><code>......\n[ ZERO ] ( Etcd Center ) Etcd configuration center is enabled !\n[ ZERO ] ( Etcd Center: zero-istio ) Etcd Client timeout = \"2s\" with nodes = 3\n[ ZERO ] ( Etcd Center ) Etcd network checking has been passed successfully !\nSetting up Etcd4j Netty client\nHV000001: Hibernate Validator 6.0.7.Final\n......\n[ ZERO ] ---&gt; ZERO://MICRO/REGISTRY/START ( Http Server ) ZeroHttpAgent ( name = up-atlas ) is sending data to internal address.\n[ ZERO ] ( Etcd Center ) The status up-atlas of service RUNNING has been registried to /zero/zero-istio/endpoint/services/up-atlas:10.0.0.7:6201\n[ ZERO ] ( Etcd Catalog ) The following routes has been push to:\n    [ Up Micro ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Micro ] Configuration Path = /zero/zero-istio/endpoint/routes/up-atlas:10.0.0.7:6201, [ Up Micro ] Service Name = up-atlas,\n    [ Up Micro ] EndPoint = http://10.0.0.7:6201\n    [ Up Micro ] Route Uris = [ Up Micro ]     [ Up Micro ] \u221a Successfully to registered Routes, wait for discovery......SUCCESS \u221a\n[ ZERO ] ZERO://MICRO/REGISTRY/START &lt;--- ( Micro Worker ) ZeroHttpRegistry ( name = up-atlas ) get data from internal address.\n</code></pre> <p>From above logs we could see the configuration path on <code>etcd</code> .</p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#4-service-node","title":"4. Service Node","text":"<p>The last configuration is service node configuration: <code>up-coeus, up-crius, up-cronus, up-epimetheus, up-hecate</code> , except service name, port, other configuration is the same.</p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#41-configuration","title":"4.1. Configuration","text":"<p>Here we only list the project <code>up-crius</code> , the folder structure of this project is as following:</p> <p></p> <p>vertx.yml</p> <pre><code>zero:\nlime: etcd3, rpc\nvertx:\ninstance:\n- name: zero-micro\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre> <p>vertx-rpc.yml</p> <pre><code>rpc:\nssl: false\nuniform:\ntype: PEM\n</code></pre> <p>vertx-server.yml</p> <pre><code>server:\n- name: up-crius\ntype: http\nconfig:\nport: 6402\nhost: 0.0.0.0\n- name: ipc-crius\ntype: ipc\nconfig:\nport: 6412\nhost: 0.0.0.0\n</code></pre>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#42-console","title":"4.2. Console","text":"<p>Then when you start this node here, you should see following message:</p> <pre><code>......\n[ ZERO ] ( Etcd Center ) Etcd configuration center is enabled !\n[ ZERO ] ( Etcd Center: zero-istio ) Etcd Client timeout = \"2s\" with nodes = 3\n[ ZERO ] ( Etcd Center ) Etcd network checking has been passed successfully !\nSetting up Etcd4j Netty client\n......\n\n# Http Endpoint part, it's the same as Common\n[ ZERO ] ---&gt; ZERO://MICRO/REGISTRY/START ( Http Server ) ZeroHttpAgent ( name = up-crius ) is sending data to internal address.\n[ ZERO ] ( Etcd Center ) The status up-crius of service RUNNING has been registried to /zero/zero-istio/endpoint/services/up-crius:10.0.0.7:6402\n[ ZERO ] ( Etcd Catalog ) The following routes has been push to:\n    [ Up Micro ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Micro ] Configuration Path = /zero/zero-istio/endpoint/routes/up-crius:10.0.0.7:6402, [ Up Micro ] Service Name = up-crius,\n    [ Up Micro ] EndPoint = http://10.0.0.7:6402\n    [ Up Micro ] Route Uris = [ Up Micro ]     [ Up Micro ] \u221a Successfully to registered Routes, wait for discovery......SUCCESS \u221a\n[ ZERO ] ZERO://MICRO/REGISTRY/START &lt;--- ( Micro Worker ) ZeroHttpRegistry ( name = up-crius ) get data from internal address.\n\n# Rpc Service part\n[ ZERO ] ---&gt; ZERO://MICRO/IPC/START ( Rpc Server ) ZeroRpcAgent ( name = ipc-crius ) is sending data to internal address.\n[ ZERO ] ( Etcd Center ) The status ipc-crius of service RUNNING has been registried to /zero/zero-istio/ipc/services/ipc-crius:10.0.0.7:6412\n[ ZERO ] ( Etcd Catalog ) The following routes has been push to:\n    [ Up Rpc   ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Rpc   ] Configuration Rpc Point = /zero/zero-istio/ipc/routes/ipc-crius:10.0.0.7:6412, [ Up Rpc   ] Service Name = ipc-crius,\n    [ Up Rpc   ] Ipc Channel = grpc://10.0.0.7:6412\n    [ Up Rpc   ] Ipc Address = [ Up Rpc   ] \u221a Successfully to registered IPCs, wait for community......SUCCESS \u221a\n[ ZERO ] ZERO://MICRO/IPC/START &lt;--- ( Micro Worker ) ZeroRpcRegistry ( name = ipc-crius ) get data from internal address.\n</code></pre> <p>You should repeat the configuration steps of 4 on <code>up-coeus, up-crius, up-cronus, up-epimetheus, up-hecate</code></p>"},{"location":"vertx-zero-tutorial/d10084-micro-yaml-configuration/#5-summary","title":"5. Summary","text":"<p>When you have finished all the configuration, your zero system micro environment has been finished, in this kind of situation you can continue the further tutorial for all the micro service demos ( Especially for Rpc demos ).</p>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/","title":"Micro, Future with Utility X","text":"<p>This chapter we still stay at the first Rpc example, but we switch our programming style with Utility X to let your rpc code more simple.</p>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#1-services","title":"1. Services","text":"<p>This demo services should be as following:</p> <p></p> <p>Here are three projects in current demo:</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6201 -- -- up-atlas Common Service 6401 6411 ipc-coeus up-coeus Coordinator A"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#21-futureapi-service-up-atlas","title":"2.1. FutureApi ( service: up-atlas )","text":"<pre><code>package up.god.micro.rpc;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface FutureApi {\n@Path(\"ipc/future/{name}\")\n@GET\n@Address(\"ZERO://RPC/SECOND\")\nString sayHello(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#22-futureworker-service-up-atlas","title":"2.2. FutureWorker ( service: up-atlas )","text":"<pre><code>package up.god.micro.rpc;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class FutureWorker {\n@Address(\"ZERO://RPC/SECOND\")\npublic Future&lt;JsonObject&gt; sayHello(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nfinal JsonObject params = new JsonObject().put(\"name\", name);\nreturn Ux.thenRpc(\"ipc-coeus\", \"RPC://SAY/FUTURE\", params);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#23-helloinsider-service-up-coeus","title":"2.3. HelloInsider ( service: up-coeus )","text":"<p>Here we list completed rpc services so that developers could compare different styles in rpc service</p> <pre><code>package up.god.ipc;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.atom.unity.Uson;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class HelloInsider {\n@Ipc(\"RPC://SAY/HELLO\")\npublic Envelop sayHello(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nSystem.out.println(data);\nreturn Envelop.success(data);\n}\n// New added method to this service.\n@Ipc(\"RPC://SAY/FUTURE\")\npublic Future&lt;JsonObject&gt; sayFuture(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\n// You can use Jooq here directly \nreturn Uson.create(data).toFuture();\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#3-testing","title":"3. Testing","text":"<p>Then you can start three services and testing:</p> <p>URL : http://localhost:6100/api/ipc/future/huan.huan</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"huan.huan\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#4-console","title":"4. Console","text":""},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#41-start-up-console","title":"4.1. Start Up Console","text":"<p>Here you should focus on some specific logs in console output when services are started up.</p> <p>common service: up-atlas</p> <pre><code>    [ Up Micro ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Micro ] Configuration Path = /zero/zero-istio/endpoint/routes/up-atlas:10.0.0.6:6201, [ Up Micro ] Service Name = up-atlas,\n    [ Up Micro ] EndPoint = http://10.0.0.6:6201\n    [ Up Micro ] Route Uris = [ Up Micro ]     /api/ipc/future/:name\n    [ Up Micro ]     /api/rpc/:name\n    [ Up Micro ] \u221a Successfully to registered Routes, wait for discovery......SUCCESS \u221a\n</code></pre> <p>coordinator: up-coeus</p> <pre><code>    [ Up Rpc   ] &lt;Application Name&gt; = \"zero-istio\",\n    [ Up Rpc   ] Configuration Rpc Point = /zero/zero-istio/ipc/routes/ipc-coeus:10.0.0.6:6411, [ Up Rpc   ] Service Name = ipc-coeus,\n    [ Up Rpc   ] Ipc Channel = grpc://10.0.0.6:6411\n    [ Up Rpc   ] Ipc Address = [ Up Rpc \u221a ]     RPC://SAY/FUTURE\n    [ Up Rpc \u221a ]     RPC://SAY/HELLO\n    [ Up Rpc   ] \u221a Successfully to registered IPCs, wait for community......SUCCESS \u221a\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#42-request-flow","title":"4.2. Request Flow","text":"<p>coordinator: up-coeus</p> <pre><code>[ ZERO ] --&gt; ( Terminator ) found, will provide response. ......\n......\n[ ZERO ] Current flow is Future&lt;T&gt;, return type = class io.vertx.core.impl.SucceededFuture\n</code></pre> <p>common service: up-atlas</p> <pre><code>[ ZERO ] ( Rpc Client ) Build channel ( host = 10.0.0.6, port = 6411, hashCode = 461512011 )\n[ ZERO ] ( Rpc Client ) Final Traffic Data will be IpcData......\n[ ZERO ] ( Rpc Client ) Response Json data is {\"name\":\"huan.huan\"}\n[ ZERO ] ( Rpc -&gt; thenRpc ) Client = 1864168592, Ipc ( ipc-coeus,RPC://SAY/FUTURE )......\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-future-with-utility-x/#5-summary","title":"5. Summary","text":"<p>This chapter programming style is recommend by zero system because all the workflow will be async. Here from the console output message the developers could know rpc details. Another thing here that developers should know:</p> <ul> <li>We recommend use <code>Ux.thenRpc</code> instead of native <code>RpcClient</code> in previous chapter because it's simple and fluent.</li> <li>There are node role output in console, but the role here depend on the annotation content, not the role we defined   here.</li> </ul> <p>In this example we could see our node <code>up-coeus</code> is Coordinator, but the message output show that:</p> <pre><code>[ ZERO ] --&gt; ( Terminator ) found, will provide response. ......\n</code></pre> <p>Actually here <code>up-coeus</code> role is Terminator instead of Coordinator because this node has not forward service node.</p>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/","title":"Micro, Simple Rpc","text":"<p>From this tutorials we started to move to Rpc tutorials in zero system, at first let's move to the first example.</p>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#1-services","title":"1. Services","text":"<p>The whole example web request flow should be as following picture described:</p> <p></p> <p>Here are three projects in current demo:</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6201 -- -- up-atlas Common Service 6401 6411 ipc-coeus up-coeus Coordinator A"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#2-source-code","title":"2. Source Code","text":"<p>Although above picture described complex micro environment web request flow, but in zero system, developers do not care about service details such as Discovery, Registry, Communication</p>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#21-singleapi-service-up-atlas","title":"2.1. SingleApi ( service: up-atlas )","text":"<pre><code>package up.god.micro.rpc;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface SingleApi {\n@Path(\"rpc/{name}\")\n@GET\n@Address(\"ZERO://RPC/FIRST\")\nString sayHello(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#22-singleworker-service-up-atlas","title":"2.2. SingleWorker ( service: up-atlas )","text":"<pre><code>package up.god.micro.rpc;\nimport io.vertx.core.eventbus.Message;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.aiki.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.atom.Envelop;\nimport io.vertx.up.plugin.rpc.RpcClient;\nimport javax.inject.infix.Rpc;\n@Queue\npublic class SingleWorker {\n@Rpc\nprivate transient RpcClient client;\n@Address(\"ZERO://RPC/FIRST\")\npublic void sayHello(final Message&lt;Envelop&gt; message) {\nfinal String name = Ux.getString(message);\nfinal JsonObject params = new JsonObject().put(\"name\", name);\nthis.client.connect(\"ipc-coeus\", \"RPC://SAY/HELLO\", params, res -&gt; {\nif (res.succeeded()) {\nmessage.reply(Envelop.success(res.result()));\n} else {\nres.cause().printStackTrace();\nmessage.reply(Envelop.failure(res.cause().getMessage()));\n}\n});\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#23-helloinsider-service-up-coeus","title":"2.3. HelloInsider ( service: up-coeus )","text":"<pre><code>package up.god.ipc;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.atom.Envelop;\npublic class HelloInsider {\n@Ipc(\"RPC://SAY/HELLO\")\npublic Envelop sayHello(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nSystem.out.println(data);\nreturn Envelop.success(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#3-testing","title":"3. Testing","text":"<p>Then start above three services and testing with Postman ( The 6100 is api gateway port )</p> <p>URL : http://localhost:6100/api/rpc/lang.yu</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"lang.yu\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#4-console","title":"4. Console","text":"<p>When you send the request you should see some message output:</p> <p>service: up-atlas</p> <pre><code>[ ZERO ] ( Rpc Client ) Build channel ( host = 10.0.0.7, port = 6411, hashCode = 58401608 )\n[ ZERO ] ( Rpc Client ) Final Traffic Data will be IpcData......\n[ ZERO ] ( Rpc Client ) Response Json data is {\"name\":\"lang.yu\"}\n</code></pre> <p>service: up-coeus</p> <pre><code>[ ZERO ] --&gt; ( Terminator ) found, will provide response. method ......\n{\"name\":\"lang.yu\"}\n[ ZERO ] Current flow is Envelop, return type = class io.vertx.up.atom.Envelop\n</code></pre>"},{"location":"vertx-zero-tutorial/d10085-micro-simple-rpc/#5-summary","title":"5. Summary","text":"<p>From this demo, you could see the whole web request workflow has been finished in zero system. Here we used another new annotation <code>javax.inject.infix.Rpc</code>, this annotation is defined by zero system. You can inject <code>RpcClient</code> directly here, the reference of <code>RpcClient</code> is the type of <code>io.vertx.up.plugin.rpc.RpcClient</code>.</p> <p>Another annotation to describe Rpc address is <code>io.vertx.up.annotations.Ipc</code> , this annotation could tell zero system which method will be executed in Rpc Server, in further tutorials we'll introduce more usage of these annotations here.\u0000</p> <p>\u0000</p> <p>\u0000`</p>"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/","title":"Micro, Multi Rpc Calls","text":"<p>From this chapter the picture will ignore the service details ( Sender/Consumer/EventBus ), show the service communication only.</p>"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#1-services","title":"1. Services","text":"<p>Here are four projects in this demo:</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6201 -- -- up-atlas Common Service 6401 6411 ipc-coeus up-coeus Coordinator A 6402 6412 ipc-crius up-crius Coordinator B"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#21-multiapi-service-up-atlas","title":"2.1. MultiApi ( service: up-atlas )","text":"<pre><code>package up.god.micro.multi;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface MultiApi {\n@Path(\"ipc/multi/{name}\")\n@GET\n@Address(\"ZERO://RPC/MULTI\")\nString sayHello(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#22-multiworker-service-up-atlas","title":"2.2. MultiWorker ( service: up-atlas )","text":"<pre><code>package up.god.micro.multi;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class MultiWorker {\n@Address(\"ZERO://RPC/MULTI\")\n@SuppressWarnings(\"unchecked\")\npublic Future&lt;JsonObject&gt; sayHello(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nfinal JsonObject params = new JsonObject().put(\"name\", name);\nreturn Ux.thenParallelJson(\nUx.thenRpc(\"ipc-crius\", \"RPC://SAY/MULTI\", params),\nUx.thenRpc(\"ipc-coeus\", \"RPC://SAY/MULTI\", params)\n);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#23-multiinsider-service-up-crius","title":"2.3. MultiInsider ( service: up-crius )","text":"<pre><code>package up.god.ipc;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class MultiInsider {\n@Ipc(\"RPC://SAY/MULTI\")\npublic Future&lt;JsonObject&gt; sayMulti(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\ndata.put(\"service\", \"up-crius\");\nreturn Future.succeededFuture(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#24-multiinsider-service-up-coeus","title":"2.4. MultiInsider ( service: up-coeus )","text":"<pre><code>package up.god.ipc;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class MultiInsider {\n@Ipc(\"RPC://SAY/MULTI\")\npublic Future&lt;JsonObject&gt; sayMulti(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\ndata.put(\"service\", \"up-coeus\");\nreturn Future.succeededFuture(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#3-testing","title":"3. Testing","text":"<p>When you started all above services, you can see more information in console, and then testing with Postman</p> <p>URL : http://localhost:6100/api/ipc/multi/lang.huan</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"0\": {\n\"name\": \"lang.huan\",\n\"service\": \"up-crius\"\n},\n\"1\": {\n\"name\": \"lang.huan\",\n\"service\": \"up-coeus\"\n}\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10087-micro-multi-rpc-calls/#4-summary","title":"4. Summary","text":"<p>This chapter show that one service connect to two rpc services scenarios, you can check more details of this example. Here you can use <code>Ux.thenParallelJson</code> method to merge one or more <code>Future&lt;JsonObject&gt;</code> type, also you can modify the worker as following:</p> <pre><code>    @Address(\"ZERO://RPC/MULTI\")\n@SuppressWarnings(\"unchecked\")\npublic Future&lt;JsonObject&gt; sayHello(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nfinal JsonObject params = new JsonObject().put(\"name\", name);\nreturn Ux.thenParallelJson(\nUx.thenRpc(\"ipc-crius\", \"RPC://SAY/MULTI\", params),\nUx.thenRpc(\"ipc-coeus\", \"RPC://SAY/MULTI\", params)\n).compose(item -&gt; {\nfinal JsonObject crius = item.getJsonObject(\"0\");\nfinal JsonObject coeus = item.getJsonObject(\"1\");\nreturn Future.succeededFuture(new JsonObject()\n.put(\"name\", crius.getValue(\"name\"))\n.put(\"first\", crius.getValue(\"service\"))\n.put(\"second\", coeus.getValue(\"service\"))\n);\n});\n}\n</code></pre> <p>Then you should get following response instead of original:</p> <pre><code>{\n\"data\": {\n\"name\": \"lang.huan\",\n\"first\": \"up-crius\",\n\"second\": \"up-coeus\"\n}\n}\n</code></pre> <p>You can do your own calculation based on response from different rpc services, then you can provide correct response to client.</p>"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/","title":"Micro Stream, Sender ( Agent ) to Terminator","text":"<p>From this chapter we'll focus on rpc stream mode, this mode we'll meet different role ( method ) such as <code>Originator, Coordinator, Terminator</code> etc.</p>"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/#1-services","title":"1. Services","text":"<p>Demo Projects and environment</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6301 6311 ipc-epimetheus up-epimetheus Originator 6501 6511 ipc-hecate up-hecate Terminator"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/#2-source-code","title":"2. Source Code","text":"<p>We have introduced interface style to ignore Actor, it's disabled in rpc communication, it means that if you send rpc request from Sender ( Agent ), you could not send the message to internal Consumer ( Worker ), the interface style is used in communication between Sender and Consumer.</p>"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/#21-simpleapi-service-up-epimetheus","title":"2.1. SimpleApi ( service: up-epimetheus )","text":"<pre><code>package up.god.micro.agent;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport io.vertx.up.annotations.Ipc;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface SimpleApi {\n@Path(\"ipc/stream/agent1/{name}\")\n@GET\n@Ipc(to = \"RPC://IPC/NODE/AGENT1\", name = \"ipc-hecate\")\nJsonObject saySimple(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/#22-simpleactor-service-up-epimetheus","title":"2.2. SimpleActor ( service: up-epimetheus )","text":"<pre><code>package up.god.micro.agent;\nimport io.vertx.core.json.JsonObject;\npublic class SimpleActor implements SimpleApi {\n@Override\npublic JsonObject saySimple(final String name) {\nreturn new JsonObject()\n.put(\"name\", name)\n.put(\"originator\", \"ipc-epimetheus\");\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/#23-simpleinsider-service-up-hecate","title":"2.3. SimpleInsider ( service: up-hecate )","text":"<pre><code>package up.god.ipc;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class SimpleInsider {\n@Ipc(\"RPC://IPC/NODE/AGENT1\")\npublic JsonObject saySimple(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nreturn data.put(\"terminator\", \"ipc-hecate\");\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/#3-testing","title":"3. Testing","text":"<p>Once you started above three services, you can test this service as following:</p> <p>URL : http://localhost:6100/api/ipc/stream/agent1/huan</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"huan\",\n\"originator\": \"ipc-epimetheus\",\n\"terminator\": \"ipc-hecate\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10088-micro-stream-sender-agent-to-terminator/#4-summary","title":"4. Summary","text":"<p>From above testing you could see that rpc between <code>Originator</code> and <code>Terminator</code> has been communicated successfully, it's very simple demo to show two roles communication between two roles.</p>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/","title":"Micro Stream, Consumer ( Worker ) to Terminator","text":"<p>From this chapter we'll focus on rpc stream mode, this mode we'll meet different role ( method ) such as <code>Originator, Coordinator, Terminator</code> etc. This chapter tutorial is different from D10088 - Micro Stream, Sender ( Agent ) to Terminator,</p> <ul> <li>In D10088, The <code>Originator</code> is Sender ( Agent ), it means that the request came from <code>eventloop</code> of vert.x;</li> <li>In current tutorial, The <code>Originator</code> is Consumer ( Worker ), it means that the request came from <code>workerpool</code> of   vert.x;</li> </ul>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#1-services","title":"1. Services","text":"<p>Demo Projects and environment</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6301 6311 ipc-epimetheus up-epimetheus Originator 6501 6511 ipc-hecate up-hecate Terminator"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#21-consumeapi-service-up-epimetheus","title":"2.1. ConsumeApi ( service: up-epimetheus )","text":"<pre><code>package up.god.micro.worker;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface ConsumeApi {\n@Path(\"ipc/stream/consumer1/{name}\")\n@GET\n@Address(\"ZERO://IPC/NODE/WORKER1\")\nString sayWorker1(@PathParam(\"name\") String name);\n@Path(\"ipc/stream/consumer2/{name}\")\n@GET\n@Address(\"ZERO://IPC/NODE/WORKER2\")\nString sayWorker2(@PathParam(\"name\") String name);\n@Path(\"ipc/stream/consumer3/{name}\")\n@GET\n@Address(\"ZERO://IPC/NODE/WORKER3\")\nString sayWorker3(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#22-consumeworker-service-up-epimetheus","title":"2.2. ConsumeWorker ( service: up-epimetheus )","text":"<p>Future mode used in current tutorials</p> <pre><code>package up.god.micro.worker;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class ConsumeWorker {\n@Address(\"ZERO://IPC/NODE/WORKER1\")\n@Ipc(to = \"RPC://IPC/NODE/WORKER1\", name = \"ipc-hecate\")\npublic Future&lt;JsonObject&gt; worker1(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nreturn Future.succeededFuture(new JsonObject()\n.put(\"name\", name)\n.put(\"originator\", \"ipc-epimetheus\"));\n}\n@Address(\"ZERO://IPC/NODE/WORKER2\")\n@Ipc(to = \"RPC://IPC/NODE/WORKER2\", name = \"ipc-hecate\")\npublic Future&lt;JsonObject&gt; worker2(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nreturn Future.succeededFuture(new JsonObject()\n.put(\"name\", name)\n.put(\"originator\", \"ipc-epimetheus\"));\n}\n@Address(\"ZERO://IPC/NODE/WORKER3\")\n@Ipc(to = \"RPC://IPC/NODE/WORKER3\", name = \"ipc-hecate\")\npublic Future&lt;JsonObject&gt; worker3(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nreturn Future.succeededFuture(new JsonObject()\n.put(\"name\", name)\n.put(\"originator\", \"ipc-epimetheus\"));\n}\n}\n</code></pre> <p>Here are some rules when you use current tutorial knowledge to write worker:</p> <ol> <li>In Sender ( Agent ), the annotations <code>@Ipc</code> and <code>@Address</code> could not be used at the same time, but here it's    allowed.</li> <li>The method must contains return value, you should not use <code>void</code> for the consumer method.</li> <li>In current tutorials, the return type of <code>Consumer</code> methods are all <code>Future&lt;T&gt;</code> instead of others.</li> </ol>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#23-workerinsider-service-up-hecate","title":"2.3. WorkerInsider ( service: up-hecate )","text":"<pre><code>package up.god.ipc;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class WorkerInsider {\n@Ipc(\"RPC://IPC/NODE/WORKER1\")\npublic JsonObject sayWorker1(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nreturn data.put(\"terminator\", \"ipc-hecate\")\n.put(\"worker\", \"worker1\");\n}\n@Ipc(\"RPC://IPC/NODE/WORKER2\")\npublic Envelop sayWorker2(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nreturn Envelop.success(data\n.put(\"terminator\", \"ipc-hecate\")\n.put(\"worker\", \"worker2\"));\n}\n@Ipc(\"RPC://IPC/NODE/WORKER3\")\npublic Future&lt;JsonObject&gt; sayWorker3(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nreturn Future.succeededFuture(data\n.put(\"terminator\", \"ipc-hecate\")\n.put(\"worker\", \"worker3\"));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#3-testing","title":"3. Testing","text":"<p>Then when you start three services, you can do the testing:</p>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#31-case-1","title":"3.1. Case 1","text":"<p>URL : http://localhost:6100/api/ipc/stream/consumer1/huan1</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"huan1\",\n\"originator\": \"ipc-epimetheus\",\n\"terminator\": \"ipc-hecate\",\n\"worker\": \"worker1\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#32-case-2","title":"3.2. Case 2","text":"<p>URL : http://localhost:6100/api/ipc/stream/consumer2/huan2</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"huan2\",\n\"originator\": \"ipc-epimetheus\",\n\"terminator\": \"ipc-hecate\",\n\"worker\": \"worker2\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#33-case-3","title":"3.3. Case 3","text":"<p>URL : http://localhost:6100/api/ipc/stream/consumer3/huan3</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"huan3\",\n\"originator\": \"ipc-epimetheus\",\n\"terminator\": \"ipc-hecate\",\n\"worker\": \"worker3\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10089-micro-consumer-worker-to-terminator/#4-summary","title":"4. Summary","text":"<p>Here we provide three demos to show how to write the method in <code>Rpc Server</code>, except the input data type <code>Envelop</code>, you can choose different return type of the methods as you want. The method signature is as following:</p> <pre><code>public Future&lt;JsonObject&gt; worker1(final Envelop envelop)\n</code></pre>"},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/","title":"Micro Stream, Consumer Sync Mode to Terminator","text":"<p>As we known before, zero system provide different modes for consumer programming style, here we provide Sync mode of consumer to communicate with Rpc Services.</p>"},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/#1-services","title":"1. Services","text":"<p>Demo Projects and environment</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6301 6311 ipc-epimetheus up-epimetheus Originator 6501 6511 ipc-hecate up-hecate Terminator"},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/#21-envelopapi-service-up-epimetheus","title":"2.1. EnvelopApi ( service: up-epimetheus )","text":"<pre><code>package up.god.micro.worker;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface EnvelopApi {\n@Path(\"ipc/stream/envelop1/{name}\")\n@GET\n@Address(\"ZERO://IPC/NODE/ENVELOP1\")\nString sayEnvelop(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/#22-envelopworker-service-up-epimetheus","title":"2.2. EnvelopWorker ( service: up-epimetheus )","text":"<pre><code>package up.god.micro.worker;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class EnvelopWorker {\n@Address(\"ZERO://IPC/NODE/ENVELOP1\")\n@Ipc(to = \"RPC://IPC/NODE/ENVELOP1\", name = \"ipc-hecate\")\npublic Envelop execute(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nreturn Envelop.success(new JsonObject()\n.put(\"name\", name)\n.put(\"originator\", \"ipc-epimetheus\"));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/#23-envelopinsider-service-up-hecate","title":"2.3. EnvelopInsider ( service: up-hecate )","text":"<pre><code>package up.god.ipc;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class EnvelopInsider {\n@Ipc(\"RPC://IPC/NODE/ENVELOP1\")\npublic JsonObject sayEnvelop(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nreturn data.put(\"terminator\", \"ipc-hecate\")\n.put(\"type\", \"envelop\");\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/#3-testing","title":"3. Testing","text":"<p>When you started above three services, you can testing this demo</p> <p>URL : http://localhost:6100/api/ipc/stream/envelop1/huan1</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"huan1\",\n\"originator\": \"ipc-epimetheus\",\n\"terminator\": \"ipc-hecate\",\n\"type\": \"envelop\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10090-micro-stream-consumer-sync/#4-summary","title":"4. Summary","text":"<p>This demo data flow is the same as previous, the little difference is the consumer method signature. The consumer in current tutorial is:</p> <pre><code>public Envelop execute(final Envelop envelop)\n</code></pre> <p>As you known it's Sync Mode consumer that zero system defined.</p>"},{"location":"vertx-zero-tutorial/d10091-micro-stream-consumer-async-to-terminator/","title":"D10091 micro stream consumer async to terminator","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:f36950233f8b14cf51f4b52cfc1fe77b8590c807a0a0dc17b5d4f6b018280d68 size 2641</p>"},{"location":"vertx-zero-tutorial/d10092-micro-stream-consumer-t-mode-to-terminator/","title":"D10092 micro stream consumer t mode to terminator","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:a5024f3e825f533f3be0af6dab6e0003b410f6817b42d04adf5d976aa86a304b size 2973</p>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/","title":"Micro Stream, Originator/Coordinator/Terminator","text":"<p>This chapter we'll introduce a complex example of stream mode, based on this example you can build basic mesh service data flow in zero system.</p>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#1-services","title":"1. Services","text":"<p>Demo Projects and environment</p> Http Port Ipc Port Ipc Service Name Project Role 6100 -- -- up-athena Api Gateway 6301 6311 ipc-epimetheus up-epimetheus Originator 6401 6411 ipc-coeus up-coeus Coordinator A 6402 6412 ipc-crius up-crius Coordinator B 6501 6511 ipc-hecate up-hecate Terminator"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#2-source-code","title":"2. Source Code","text":""},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#21-huttapi-service-up-epimetheus","title":"2.1. HuttApi ( service: up-epimetheus )","text":"<pre><code>package up.god.micro.mesh;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\n@EndPoint\n@Path(\"/api\")\npublic interface HuttApi {\n@Path(\"ipc/mesh/hutt/{name}\")\n@GET\n@Address(\"ZERO://IPC/NODE/HUTT\")\nString sayHutt(@PathParam(\"name\") String name);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#22-huttworker-service-up-epimetheus","title":"2.2. HuttWorker ( service: up-epimetheus )","text":"<pre><code>package up.god.micro.mesh;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class HuttWorker {\n@Address(\"ZERO://IPC/NODE/HUTT\")\n@Ipc(to = \"RPC://IPC/NODE/HUTT\", name = \"ipc-coeus\")\npublic Future&lt;JsonObject&gt; sayHutt(final Envelop envelop) {\nfinal String name = Ux.getString(envelop);\nreturn Future.succeededFuture(new JsonObject()\n.put(\"name\", name)\n.put(\"originator\", \"ipc-epimetheus\"));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#23-huttinsider-service-up-coeus","title":"2.3. HuttInsider ( service: up-coeus )","text":"<pre><code>package up.god.ipc.mesh;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class HuttInsider {\n@Ipc(value = \"RPC://IPC/NODE/HUTT\",\nto = \"RPC://IPC/NODE/HUTT1\", name = \"ipc-crius\")\npublic String next(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\ndata.put(\"coordinator1\", \"ipc-coeus\");\nreturn data.encode();\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#24-huttinsider-service-up-crius","title":"2.4. HuttInsider ( service: up-crius )","text":"<pre><code>package up.god.ipc.mesh;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class HuttInsider {\n@Ipc(value = \"RPC://IPC/NODE/HUTT1\",\nto = \"RPC://IPC/NODE/HUTTS\", name = \"ipc-hecate\")\npublic JsonObject next(final Envelop envelop) {\nfinal String content = envelop.data();\nreturn new JsonObject(content)\n.put(\"coordinator2\", \"ipc-cronus\");\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#25-huttinsider-service-up-hecate","title":"2.5. HuttInsider ( service: up-hecate )","text":"<pre><code>package up.god.ipc.mesh;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Ipc;\nimport io.vertx.up.commune.Envelop;\npublic class HuttInsider {\n@Ipc(value = \"RPC://IPC/NODE/HUTTS\")\npublic JsonObject sayHutt(final Envelop envelop) {\nfinal JsonObject data = envelop.data();\nreturn data.put(\"terminator\", \"ipc-hecate\")\n.put(\"type\", \"async\");\n}\n}\n</code></pre> <p>Here please be careful about different role configuration for stream, you can refer D10083 - Micro, Rpc Mode to check different role configuration tutorials.</p>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#3-testing","title":"3. Testing","text":"<p>Here you must start five services and mount to Api Gateway and then you can test current demo as following:</p> <p>URL : http://localhost:6100/api/ipc/mesh/hutt/huan1</p> <p>Method : GET</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"name\": \"huan1\",\n\"originator\": \"ipc-epimetheus\",\n\"coordinator1\": \"ipc-coeus\",\n\"coordinator2\": \"ipc-cronus\",\n\"terminator\": \"ipc-hecate\",\n\"type\": \"async\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10093-micro-stream-originatorcoordinatorterminator/#4-summary","title":"4. Summary","text":"<p>Based on above response data you can see the data flow went through four nodes, the point that you should know is that in this mode the data flow could not be revert, it means that the direction is <code>Single</code>, you can pass the data to next service node only.</p>"},{"location":"vertx-zero-tutorial/d10094-exception-defined-your-errors/","title":"Exception, Defined your Errors","text":"<p>Zero system provide simple error define for user.</p>"},{"location":"vertx-zero-tutorial/d10094-exception-defined-your-errors/#1-configuration","title":"1. Configuration","text":"<p>In your class path, create a new up.god.file named <code>vertx-error.yml</code>\uff0cthe format is as following:</p> <pre><code>E100001: User defined Error {0}, details = {1}\n</code></pre> <p>The detail implementation used MessageFormat, do not support named parameters.</p>"},{"location":"vertx-zero-tutorial/d10094-exception-defined-your-errors/#2-create-class","title":"2. Create Class","text":"<p>Create new class that you wanted as following</p> <pre><code>import io.horizon.exception.WebException;\npublic class TestRequestException extends\nWebException {\npublic TestRequestException(final Class&lt;?&gt; clazz,\nfinal String name,\nfinal String detail) {\nsuper(clazz, name, detail);\n}\n@Override\npublic int getCode() {\nreturn -100001;\n}\n}\n</code></pre> <ul> <li>Please ignore the first parameter <code>Class&lt;?&gt;</code>, it's for Zero to detect the error happened class position;</li> <li>The rest parameters could be pass any length, you could call <code>super(clazz, arg0, arg1, ...)</code></li> <li>Be sure to write the <code>getCode()</code> method, this method must be match with the <code>vertx-error.yml</code> prefix: <code>E&lt;code&gt;</code> as   message key</li> <li>If you want to change HttpStatusCode, you could overwrite <code>getStatus()</code> as following:</li> </ul> <pre><code>      public HttpStatusCode getStatus() {\n// Default exception for 400\nreturn HttpStatusCode.BAD_REQUEST;\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10094-exception-defined-your-errors/#3-build-envelop-with-error","title":"3. Build Envelop with Error","text":"<p>Then in your code, write following code:</p> <pre><code>    @Address(\"ZERO://USER\")\npublic Envelop reply(final Envelop message) {\nfinal User user = message.data(User.class);\nfinal WebException error = new TestRequestException(getClass(),\n\"Lang\", \"Detail\");\nreturn Envelop.failure(error);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10094-exception-defined-your-errors/#4-running-the-app","title":"4. Running the App","text":"<p>You'll see following error response:</p> <pre><code>{\n\"code\": -100001,\n\"message\": \"[ERR-100001] (UserWorker) ZeroException occurs: User defined Error Lang, details = Detail.\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10095-security-basic-authorization/","title":"Security, Basic Authorization","text":"<p>You can enable authorization in zero system as following steps:</p>"},{"location":"vertx-zero-tutorial/d10095-security-basic-authorization/#1-configuration","title":"1. Configuration","text":"<p>In your configuration <code>vertx.yml</code>, you must define lime extend node as following:</p> <pre><code>zero:\nlime: secure\n</code></pre> <p>Then it means that you must create new up.god.file named <code>vertx-secure.yml</code> instead with following content:</p> <pre><code>secure:\n# Standard Type\nmongox:\ntype: mongo\nconfig:\ncollectionName: DB_USER\nsaltStyle: NO_SALT\n</code></pre> <p>Zero system provide some standard authorization by type ( Now support mongo ).</p>"},{"location":"vertx-zero-tutorial/d10095-security-basic-authorization/#2-create-new-class","title":"2. Create new class","text":"<p>Then you can create new class as following:</p> <pre><code>import io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.mongo.MongoAuth;\nimport io.vertx.ext.web.handler.AuthHandler;\nimport io.vertx.up.annotations.Authenticate;\nimport io.vertx.up.annotations.Wall;\nimport io.vertx.tp.plugin.mongo.MongoInfix;\nimport io.vertx.up.secure.component.BasicOstium;\n@Wall(value = \"mongox\", path = \"/exp4/*\")\npublic class MongoKeeper {\n@Authenticate\npublic AuthHandler authenticate(final JsonObject config) {\nreturn BasicOstium.create(\nMongoAuth.create(MongoInfix.getClient(), config)\n);\n}\n}\n</code></pre> <p>This class is annotated with @Wall, if the path is not set, it will be the value <code>/*</code> for all routes, the value should be configured in <code>vertx-secure.yml.</code>in current example it's <code>mongox</code>. You can define more than one walls for each routes. Then you must create the <code>AuthHandler</code> method to create the AuthHandler, now you can use <code>BasicOstium</code> to create basic authorization handler, also this method must be annotated with <code>@Authenticate</code>.</p> <ul> <li>The method must be annotated with <code>@Authenticate</code> to mean that this method will provide <code>AuthHandler</code> for   authenticate.</li> <li>In this class, you must mot use any Inject Dependency to get instance such as <code>MongoClient</code>, because this @Wall will   be processed in start up phase instead of request phase.</li> <li>We recommend to use <code>BasicOstium</code> instead of standard vert.x <code>BasicAuthHandler</code> because the class <code>BasicOstium</code> will   bind to Resource Model instance <code>Envelop</code> to provide zero format http response.</li> </ul>"},{"location":"vertx-zero-tutorial/d10095-security-basic-authorization/#3-example-response","title":"3. Example response","text":"<p>Once you set the @Wall, you must send request with Authorization http header or your'll get following response:</p> <pre><code>{\n\"code\": -60012,\n\"message\": \"[ERR-60012] (BasicPhylum) Web Exception occus: (401) - (Security) Unauthorized request met in request.\"\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10096-exception-readable-message-to-help-ui/","title":"Exception, Readable message to help UI","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:495d5e11518d8bcd670153e57914236e93c4b317d7a2b8703a7d58126586fc33 size 1598</p>"},{"location":"vertx-zero-tutorial/d10097-jooqcrud-save-operation/","title":"D10097 jooqcrud save operation","text":"<p>version https://git-lfs.github.com/spec/v1 oid sha256:142d946755263f0a5f7dd04e62ad655ecd06baf7c4f39d86d8355e3f1d1b08a5 size 5725</p>"},{"location":"vertx-zero-tutorial/d10098-jsr340-filter-in-agent/","title":"JSR340 Filter in Agent","text":"<p>This tutorial will describe the usage of @WebFilter which will belong to JSR340 to implement Chain of Responsibility pattern in zero system, because there are some conflicts between Servlet and Vert.x, in zero system it won't implement @WebServlet annotation but @WebFilter/@WebListener instead.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6084: <code>up-tethys</code></li> </ul> <p>In zero system there are two places to programming: Sender/Consumer, in this situation we'll introduce both modes in our tutorials.</p>"},{"location":"vertx-zero-tutorial/d10098-jsr340-filter-in-agent/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10098-jsr340-filter-in-agent/#11-actor","title":"1.1. Actor","text":"<p>At first we'll implement an actor in our project that has been introduced before.</p> <pre><code>package up.god.micro.filter;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport jakarta.ws.rs.ContextParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@Path(\"/api\")\n@EndPoint\npublic class FilterAgent {\n@POST\n@Path(\"/jsr340/agent\")\npublic JsonObject filter(@BodyParam final JsonObject data,\n@ContextParam(\"key\") final String filtered) {\nreturn new JsonObject().put(\"filter\", filtered)\n.mergeIn(data);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10098-jsr340-filter-in-agent/#12-filter","title":"1.2. Filter","text":"<p>Then you can write the filter as following:</p> <pre><code>package up.god.micro.filter;\nimport io.vertx.core.VertxException;\nimport io.vertx.core.http.HttpServerRequest;\nimport io.vertx.core.http.HttpServerResponse;\nimport io.vertx.up.uca.web.filter.HttpFilter;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n@WebFilter(\"/api/jsr340/*\")\npublic class FirstFilter extends HttpFilter {\n@Override\npublic void doFilter(final HttpServerRequest request,\nfinal HttpServerResponse response)\nthrows IOException, VertxException {\nSystem.out.println(\"First Filter\");\nthis.put(\"key\", \"First Filter\");\n}\n}\n</code></pre> <p>Here are some points that you should be careful:</p> <ul> <li>In the filter, you should use annotation <code>javax.servlet.annotations.WebFilter</code> to mark filter component</li> <li>Once point that to be careful is that the class must inherit from <code>io.vertx.up.uca.web.filter.HttpFilter</code>.</li> <li>The parameters of <code>doFilter</code> is <code>HttpServerRequest/HttpServerResponse</code> in vert.x instead of JSR340.</li> <li>When your code flow went to Actor, you should use <code>@ContextParam</code> to extract the data.</li> </ul>"},{"location":"vertx-zero-tutorial/d10098-jsr340-filter-in-agent/#2-testing","title":"2. Testing","text":"<p>URL : http://localhost:6084/api/jsr340/agent</p> <p>Method: POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"Lang\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"filter\": \"First Filter\",\n\"username\": \"Lang\"\n}\n}\n</code></pre> <p>From above demo you can see that we have got the data in actor that had been put in filter component.</p>"},{"location":"vertx-zero-tutorial/d10098-jsr340-filter-in-agent/#3-summary","title":"3. Summary","text":"<p>Current tutorial described the filter usage that belong to JSR340, the filter will be triggered automatically if the uri is matching. You can do anythings in filter such as data conversion, request modification or reject current restful request.</p>"},{"location":"vertx-zero-tutorial/d10099-jsr340-filter-in-worker/","title":"JSR340 Filter in Worker","text":"<p>This tutorial will continue to introduce how to use JSR340 @WebFilter in zero system. Here are some points that should be mentioned because of some limitation between JSR340 and Vert.x:</p> <ul> <li>All the filters must implement <code>io.vertx.up.uca.web.filter.Filter</code> instead of JSR340;</li> <li>We recommend developers extend from <code>io.vertx.up.uca.web.filter.HttpFilter</code> directly because there are some abstract   implementations in parent filters.</li> <li>Please be careful of the signature of <code>doFilter</code> especially focus on the parameter types.</li> </ul> <p>Demo projects:</p> <ul> <li>Standalone - 6084: <code>up-tethys</code></li> </ul> <p>This tutorial will describe the usage of Filters in Consumer ( Worker ).</p>"},{"location":"vertx-zero-tutorial/d10099-jsr340-filter-in-worker/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10099-jsr340-filter-in-worker/#11-api","title":"1.1. Api","text":"<pre><code>package up.god.micro.filter;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic interface FilterApi {\n@POST\n@Path(\"/jsr340/worker\")\n@Address(\"ZERO://JSR340/WORKER\")\nJsonObject filter(@BodyParam final JsonObject data);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10099-jsr340-filter-in-worker/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.filter;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class FilterWorker {\n@Address(\"ZERO://JSR340/WORKER\")\npublic Future&lt;JsonObject&gt; work(final Envelop envelop) {\nfinal String key = envelop.context(\"key\", String.class);\nreturn Future.succeededFuture(new JsonObject().put(\"key\", key));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10099-jsr340-filter-in-worker/#13-filter","title":"1.3. Filter","text":"<p>Here the code is the same as agent as following</p> <pre><code>package up.god.micro.filter;\nimport io.vertx.core.VertxException;\nimport io.vertx.core.http.HttpServerRequest;\nimport io.vertx.core.http.HttpServerResponse;\nimport io.vertx.up.uca.web.filter.HttpFilter;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n@WebFilter(\"/api/jsr340/*\")\npublic class FirstFilter extends HttpFilter {\n@Override\npublic void doFilter(final HttpServerRequest request,\nfinal HttpServerResponse response)\nthrows IOException, VertxException {\nSystem.out.println(\"First Filter\");\nthis.put(\"key\", \"First Filter\");\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10099-jsr340-filter-in-worker/#2-testing","title":"2. Testing","text":"<p>Then you can test this feature as following:</p> <p>URL : http://localhost:6084/api/jsr340/worker</p> <p>Method : POST</p> <p>Response :</p> <pre><code>{\n\"data\": {\n\"key\": \"First Filter\"\n}\n}\n</code></pre> <p>Here please be careful about the api of <code>Envelop.context</code>, you can extract the data from this api include any data type, the signature of this method is as following:</p> <pre><code>public &lt;T&gt; T context(final String key, final Class&lt;T&gt; clazz)\n</code></pre>"},{"location":"vertx-zero-tutorial/d10099-jsr340-filter-in-worker/#3-summary","title":"3. Summary","text":"<p>Based on current tutorial you can know how to use filters in Consumer ( Worker ) of zero system, and now you can set any code logical before your API.</p>"},{"location":"vertx-zero-tutorial/d10100-jsr340-multi-filters/","title":"JSR340 Multi Filters","text":"<p>This tutorial we'll modify the demo that has been described in previous tutorial to write multi filters in zero system, in this kind of situation we could manage all the filters before your API, this feature is more useful and powerful.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6084: <code>up-tethys</code></li> </ul>"},{"location":"vertx-zero-tutorial/d10100-jsr340-multi-filters/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10100-jsr340-multi-filters/#11-api","title":"1.1. API","text":"<pre><code>package up.god.micro.filter;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@EndPoint\n@Path(\"/api\")\npublic interface FilterApi {\n@POST\n@Path(\"/jsr340/worker\")\n@Address(\"ZERO://JSR340/WORKER\")\nJsonObject filter(@BodyParam final JsonObject data);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10100-jsr340-multi-filters/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.filter;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\n@Queue\npublic class FilterWorker {\n@Address(\"ZERO://JSR340/WORKER\")\npublic Future&lt;JsonObject&gt; work(final Envelop envelop) {\nfinal String key = envelop.context(\"key\", String.class);\nfinal String key1 = envelop.context(\"key1\", String.class);\nreturn Future.succeededFuture(new JsonObject().put(\"key\", key).put(\"key1\", key1));\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10100-jsr340-multi-filters/#13-filters","title":"1.3. Filters","text":"<p>Here are two filters in this example, we'll manage all the filters by <code>io.vertx.up.annotations.Ordered</code>, The default order value is 0, it means that all the filters will be triggered in sequence by order.</p> <p>FirstFilter</p> <pre><code>package up.god.micro.filter;\nimport io.vertx.core.VertxException;\nimport io.vertx.core.http.HttpServerRequest;\nimport io.vertx.core.http.HttpServerResponse;\nimport io.vertx.up.uca.web.filter.HttpFilter;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n@WebFilter(\"/api/jsr340/*\")\npublic class FirstFilter extends HttpFilter {\n@Override\npublic void doFilter(final HttpServerRequest request,\nfinal HttpServerResponse response)\nthrows IOException, VertxException {\nSystem.out.println(\"First Filter\");\nthis.put(\"key\", \"First Filter\");\n}\n}\n</code></pre> <p>SecondFilter</p> <pre><code>package up.god.micro.filter;\nimport io.vertx.core.VertxException;\nimport io.vertx.core.http.HttpServerRequest;\nimport io.vertx.core.http.HttpServerResponse;\nimport io.vertx.up.annotations.Ordered;\nimport io.vertx.up.uca.web.filter.HttpFilter;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n@WebFilter(\"/api/jsr340/*\")\n@Ordered(2)\npublic class SecondFilter extends HttpFilter {\n@Override\npublic void doFilter(final HttpServerRequest request,\nfinal HttpServerResponse response)\nthrows IOException, VertxException {\nSystem.out.println(\"Second Filter\");\nthis.put(\"key1\", \"Second Filter\");\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10100-jsr340-multi-filters/#2-testing","title":"2. Testing","text":"<p>Then you can test this demo:</p> <p>URL : http://localhost:6084/api/jsr340/worker</p> <p>Method: POST</p> <p>Request :</p> <pre><code>{\n\"username\":\"Filter\"\n}\n</code></pre> <p>Response :</p> <pre><code>{\n\"data\": {\n\"key\": \"First Filter\",\n\"key1\": \"Second Filter\"\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10100-jsr340-multi-filters/#3-summary","title":"3. Summary","text":"<p>In this demo we defined 2 filters in sequence to implement the whole Chain of Responsibility pattern. In zero system, please be careful about the whole filter chain:</p> <ul> <li>All the filters could be managed by <code>io.vertx.up.annotations.Ordered</code>.</li> <li>The data could be passed by <code>RoutingContext</code> instead of other form, you can put the data into <code>RoutingContext</code>   by <code>put</code>.</li> <li>In Sender, you should extract data by <code>@ContextParam</code> or get <code>RoutingContext</code> reference to process it by yourself.</li> <li>In Consumer, you can call <code>Envelop.context</code> api to get the data from <code>RoutingContext</code>.</li> </ul>"},{"location":"vertx-zero-tutorial/d10101-vertx-native-redisclient/","title":"Vert.x Native, RedisClient","text":"<p>This tutorial will introduce how to use Redis in zero system.</p>"},{"location":"vertx-zero-tutorial/d10101-vertx-native-redisclient/#1-configuration","title":"1. Configuration","text":"<p>This chapter is duplicated with D10102 - Configuration, vertx-redis.yml, because that's the preparing steps for redis client.</p>"},{"location":"vertx-zero-tutorial/d10101-vertx-native-redisclient/#11-vertxyml","title":"1.1. vertx.yml","text":"<p>Be sure the extension up.god.file name existing in <code>lime</code> node:</p> <pre><code>zero:\nlime: redis\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10101-vertx-native-redisclient/#12-vertx-injectyml","title":"1.2. vertx-inject.yml","text":"<pre><code>redis: io.vertx.tp.plugin.redis.RedisInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10101-vertx-native-redisclient/#13-vertx-redisyml","title":"1.3. vertx-redis.yml","text":"<pre><code>redis:\nhost: 0.0.0.0\nport: 6379\n</code></pre> <p>Just like <code>vertx-mysql.yml</code> configuration, here all the <code>redis</code> node keys are native supported by vert.x, you can provide all the native configuration keys to <code>redis</code> in zero system.</p>"},{"location":"vertx-zero-tutorial/d10101-vertx-native-redisclient/#2-source-code","title":"2. Source Code","text":"<pre><code>package up.god.micro.redis;\nimport io.vertx.redis.RedisClient;\nimport io.vertx.up.annotations.EndPoint;\nimport javax.inject.infix.Redis;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n@Path(\"\")\n@EndPoint\npublic class RedisActor {\n@Redis\nprivate transient RedisClient client;\n@Path(\"/api/redis\")\n@GET\npublic String sayRedis(final String name) {\nSystem.out.println(this.client);\nreturn \"Redis, \" + name;\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10101-vertx-native-redisclient/#3-summary","title":"3. Summary","text":"<p>Here you can inject RedisClient based on above code.</p>"},{"location":"vertx-zero-tutorial/d10102-configuration-vertx-redisyml/","title":"Configuration, vertx-redis.yml","text":"<p>From <code>0.4.7</code>, zero system support native <code>RedisClient</code> that has been provided by vert.x, you can read current tutorial to check the details about how to configure redis client in zero system.</p>"},{"location":"vertx-zero-tutorial/d10102-configuration-vertx-redisyml/#1-configuration","title":"1. Configuration","text":""},{"location":"vertx-zero-tutorial/d10102-configuration-vertx-redisyml/#11-vertxyml","title":"1.1. vertx.yml","text":"<p>Be sure the extension up.god.file name existing in <code>lime</code> node:</p> <pre><code>zero:\nlime: redis\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10102-configuration-vertx-redisyml/#12-vertx-injectyml","title":"1.2. vertx-inject.yml","text":"<pre><code>redis: io.vertx.tp.plugin.redis.RedisInfix\n</code></pre>"},{"location":"vertx-zero-tutorial/d10102-configuration-vertx-redisyml/#13-vertx-redisyml","title":"1.3. vertx-redis.yml","text":"<pre><code>redis:\nhost: 0.0.0.0\nport: 6379\n</code></pre> <p>Just like <code>vertx-mysql.yml</code> configuration, here all the <code>redis</code> node keys are native supported by vert.x, you can provide all the native configuration keys to <code>redis</code> in zero system.</p>"},{"location":"vertx-zero-tutorial/d10102-configuration-vertx-redisyml/#2-summary","title":"2. Summary","text":"<p>Here are the redis standalong configuration part and in forward tutorials we'll introduce the client usage in zero system.</p>"},{"location":"vertx-zero-tutorial/d10103-configuration-vertx-secureyml/","title":"Configuration, vertx-secure.yml","text":"<p>From <code>0.4.7</code>, zero system support security limitation for Authorization and Authentication, if you want to enable this feature, you should set another extension configuration for <code>secure</code> node.</p>"},{"location":"vertx-zero-tutorial/d10103-configuration-vertx-secureyml/#1-configuration","title":"1. Configuration","text":""},{"location":"vertx-zero-tutorial/d10103-configuration-vertx-secureyml/#11-vertxyml","title":"1.1. vertx.yml","text":"<p>Be sure the extension up.god.file name existing in <code>lime</code> node in the major configuration.</p> <pre><code>zero:\nlime: secure\n</code></pre> <p>Because we'll use mongo as default authorization, you must finish mongo configuration based on: D10073 - Configuration, vertx-mongo.yml.</p>"},{"location":"vertx-zero-tutorial/d10103-configuration-vertx-secureyml/#12-vertx-secureyml","title":"1.2. vertx-secure.yml","text":"<p>For <code>MongoAuth</code> usage, you can set the configuration as following:</p> <pre><code>secure:\n# Standard Type\nmongox:\ntype: mongo\nconfig:\ncollectionName: DB_USER\nsaltStyle: NO_SALT\n</code></pre> <p>For Jwt authorization, you should set configuration as following:</p> <pre><code>secure:\n# Standard Type\njwt:\ntype: jwt\nconfig:\njwtOptions:\nalgorithm: HS256\nkeyStore:\ntype: jceks\npath: keys/keystore.jceks\npassword: zeroup\n</code></pre> <p>Here the <code>type</code> attribute now support <code>mongo</code>, <code>jwt</code> in zero system only, if you used <code>mongo</code> type the authorization header should be:</p> <pre><code>Basic bGFuZy55dToxQkJEODg2NDYwODI3MDE1RTVENjA1RUQ0NDI1MjI1MQ==\n</code></pre> <p>But for <code>jwt</code> , you should set the header as following:</p> <pre><code>Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJfaWQiOiJjMWZiN2JiZC1kOTkxLTQwODItYTY3ZS0yODliYzM5NzQzNTEiLCJpYXQiOjE1MjAxMTk1Mzh9.iL1ymVq8b7vgqt6nna6vUqCPvaPT3QJpw0Fl4q4xbA4\n</code></pre>"},{"location":"vertx-zero-tutorial/d10103-configuration-vertx-secureyml/#2-summary","title":"2. Summary","text":"<p>Here are the jwt/mongo standalone configuration part and in forward tutorials we'll introduce how to use <code>secure</code> mode in zero system.</p>"},{"location":"vertx-zero-tutorial/d10104-security-jwt-authorization/","title":"Security, Jwt Authorization","text":"<p>This tutorial we'll introduce the usage of <code>Jwt</code> Authorization in zero system, the workflow is as following:</p> <p>Generate Token :</p> <p></p> <p>Verify Token:</p> <p></p> <p>Here are two workflow in zero system that developers could define:</p> <ul> <li>Generate Token: When the user send request to login api, you can call <code>store</code> method to generate config and send   config back.</li> <li>Verify Token: Before zero system verified config, you can check with your own code logical here.</li> </ul> <p>In vert.x native JWT support, you must set your own code logical to process config, but in zero system, you could focus on two functions to process config only, zero has split the workflow and let developers process JWT more smartly.</p> <p>Demo projects:</p> <ul> <li>Standalone - 6084: <code>up-tethys</code></li> </ul> <p>For security configuration part you can refer: D10103 - Configuration, vertx-secure.yml for more details.</p>"},{"location":"vertx-zero-tutorial/d10104-security-jwt-authorization/#1-source-code","title":"1. Source Code","text":""},{"location":"vertx-zero-tutorial/d10104-security-jwt-authorization/#11-sender","title":"1.1. Sender","text":"<pre><code>package up.god.micro.jwt;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.EndPoint;\nimport jakarta.ws.rs.BodyParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n@Path(\"/api\")\n@EndPoint\npublic interface LoginActor {\n@POST\n@Path(\"/login\")\n@Address(\"ZERO://QUEUE/LOGIN\")\nJsonObject login(@BodyParam final JsonObject data);\n@POST\n@Path(\"/secure/jwt\")\n@Address(\"ZERO://QUEUE/JWT\")\nJsonObject secure(@BodyParam final JsonObject data);\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10104-security-jwt-authorization/#12-consumer","title":"1.2. Consumer","text":"<pre><code>package up.god.micro.jwt;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Address;\nimport io.vertx.up.annotations.Queue;\nimport io.vertx.up.commune.Envelop;\nimport io.vertx.up.secure.Security;\nimport javax.inject.Inject;\n@Queue\npublic class LoginWorker {\n@Inject\nprivate transient Security security;\n@Address(\"ZERO://QUEUE/LOGIN\")\npublic Future&lt;JsonObject&gt; login(final Envelop envelop) {\nfinal JsonObject data = Ux.getJson(envelop);\nreturn Ux.Mongo.findOne(\"DB_USER\", data)\n// 1.Once login successfully, you can call security api store to store config.\n.compose(item -&gt; this.security.store(item));\n}\n@Address(\"ZERO://QUEUE/JWT\")\npublic Future&lt;JsonObject&gt; secure(final Envelop envelop) {\nreturn Future.succeededFuture(new JsonObject());\n}\n}\n</code></pre> <p>Be careful about above code that you should <code>inject</code> the Security interface.</p>"},{"location":"vertx-zero-tutorial/d10104-security-jwt-authorization/#13-wall","title":"1.3. Wall","text":"<pre><code>package up.wall;\nimport io.vertx.core.Future;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.jwt.JWTAuthOptions;\nimport io.vertx.ext.web.handler.AuthHandler;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.annotations.Authenticate;\nimport io.vertx.up.annotations.Wall;\nimport io.vertx.up.secure.Security;\nimport io.vertx.up.secure.component.JwtOstium;\nimport io.vertx.up.secure.provider.authenticate.JwtAuth;\n@Wall(value = \"jwt\", path = \"/api/secure/*\")\n@SuppressWarnings(\"all\")\npublic class JwtWall implements Security {\n@Authenticate\npublic AuthHandler authenticate(final Vertx vertx,\nfinal JsonObject config) {\nreturn JwtOstium.create(JwtAuth.create(vertx, new JWTAuthOptions(config), this::verify));\n}\n@Override\npublic Future&lt;JsonObject&gt; store(final JsonObject filter) {\nfinal JsonObject seed = new JsonObject()\n.put(\"username\", filter.getString(\"username\"))\n.put(\"id\", filter.getString(\"_id\"));\n// Build the data that you want to store into config.\n// 1. Generate Token\nfinal String config = Ux.Jwt.config(seed);\n// 2. Store config into mongo db\nreturn Ux.Mongo.findOneAndReplace(\"DB_USER\", filter, \"config\", config);\n}\n@Override\npublic Future&lt;Boolean&gt; verify(final JsonObject data) {\nfinal JsonObject extracted = Ux.Jwt.extract(data);\n// 1. Extract data from config: Authorization Header.\nfinal String config = data.getString(\"jwt\");\n// 2. Set filters to check whether user id and config are matching in storage ( Mongo DB )\nfinal JsonObject filters = new JsonObject()\n.put(\"_id\", extracted.getString(\"id\"))\n.put(\"config\", config);\n// 3. If matching, you can return Future&lt;Boolean&gt;, if it's true, JWT will continue.\n// If false, the workflow will be terminal and 401 replied.\nreturn Ux.Mongo.existing(\"DB_USER\", filters);\n}\n}\n</code></pre>"},{"location":"vertx-zero-tutorial/d10104-security-jwt-authorization/#2-summary","title":"2. Summary","text":"<p>Once you have write above codes, you have set Jwt Authorization for <code>/api/secure/*</code> urls, in this way JWT has been enabled. But there are some points:</p> <ul> <li>In <code>store</code> method, you could process your own code logical.</li> <li>In <code>verify</code> method, you must return Future&lt;Boolean&gt; to identify config checking result.</li> </ul> <p>In real projects, the login method may be complex as following:</p> <p>Code came from Mobile App login.</p> <pre><code>package com.tlk.micro.login;\nimport com.tlk.atom.User;\nimport com.tlk.infra.up.god.cv.ID;\nimport com.tlk.infra.exception.PasswordWrongException;\nimport com.tlk.infra.exception.UserNotFoundException;\nimport io.vertx.core.Future;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.up.atom.unity.Uson;\nimport io.vertx.up.unity.Ux;\nimport io.vertx.up.fn.Fn;\nimport io.vertx.up.secure.Security;\nimport javax.inject.Inject;\npublic class LoginService implements LoginStub {\n@Inject\nprivate transient Security security;\n@Override\n@SuppressWarnings(\"all\")\npublic Future&lt;JsonObject&gt; login(final JsonObject params) {\nfinal String password = params.getString(\"password\");\nfinal String username = params.getString(\"username\");\nparams.remove(\"password\");\nreturn Ux.Mongo.findOne(User.TABLE, params)\n.compose(result -&gt; Fn.get(() -&gt; Ux.match(\n() -&gt; Ux.fork(\n() -&gt; Ux.on(getClass()).on(\"[App] username = {0} met password wrong error.\").info(username),\n() -&gt; Ux.thenError(PasswordWrongException.class, getClass(), username)),\nUx.branch(null == result,\n() -&gt; Ux.on(getClass()).on(\"[App] username = {0} does not exist.\").info(username),\n() -&gt; Ux.thenError(UserNotFoundException.class, getClass(), username)),\nUx.branch(null != result &amp;&amp; password.equals(result.getValue(\"password\")),\n() -&gt; Ux.on(getClass()).on(\"[App] username = {0} login successfully.\"),\n() -&gt; Uson.create(result).convert(ID.DB_KEY, ID.UI_KEY).toFuture()))\n))\n.compose(user -&gt; security.store(user));\n}\n}\n</code></pre> <p>Then you can write any kind of JWT code logical that you want in your projects.</p>"},{"location":"vertx-zero-tutorial/d10106-configuration-vertx-tpyml/","title":"Configuration, vertx-tp.yml","text":"<p>The suffix \"-tp\" means \"Third Part\", we recommend the filename to store different configuration files. This tutorial will describe the usage of Shared Data in vert.x. Zero system provide the <code>SharedClient</code> to enhance the feature of Shared Data of vert.x, in this way this client could be used in different requirements.</p>"},{"location":"vertx-zero-tutorial/d10106-configuration-vertx-tpyml/#1-configuration","title":"1. Configuration","text":""},{"location":"vertx-zero-tutorial/d10106-configuration-vertx-tpyml/#11-vertxyml","title":"1.1. vertx.yml","text":"<p>In major configuration up.god.file, you must extend to <code>vertx-tp.yml</code> up.god.file to enable this configuration.</p> <pre><code>zero:\nlime: mongo,readible,secure,tp\nvertx:\ninstance:\n- name: vx-zero\noptions:\n# Fix block 2000 limit issue.\nmaxEventLoopExecuteTime: 30000000000\n</code></pre>"},{"location":"vertx-zero-tutorial/d10106-configuration-vertx-tpyml/#12-vertx-tpyml","title":"1.2. vertx-tp.yml","text":"<p>This up.god.file must contain shared data information, actually there is only one configuration node named <code>shared</code>\uff0cif you want to enable this feature you can set as following:</p> <pre><code>shared:\nconfig:\nasync: true\n</code></pre>"},{"location":"vertx-zero-tutorial/d10106-configuration-vertx-tpyml/#13-vertx-injectxml","title":"1.3. vertx-inject.xml","text":"<p>The last configuration for shared data usage is that you must set <code>inject</code> in your configuration:</p> <pre><code>shared: io.vertx.tp.plugin.shared.MapInfix\n</code></pre> <p>Once you have finished above three configuration, the shared data will be enabled.</p>"},{"location":"vertx-zero-tutorial/d10106-configuration-vertx-tpyml/#2-summary","title":"2. Summary","text":"<p>Once you finished above configuration, you can use <code>SharedData</code> in zero system now. We repeated to describe standalone configuration for different component, it's for you to know the simple configuration for more details. </p>"}]}